<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>CPP</title><style>
/* cspell:disable-file */
/* webkit printing magic: print all background colors */
html {
	-webkit-print-color-adjust: exact;
}
* {
	box-sizing: border-box;
	-webkit-print-color-adjust: exact;
}

html,
body {
	margin: 0;
	padding: 0;
}
@media only screen {
	body {
		margin: 2em auto;
		max-width: 900px;
		color: rgb(55, 53, 47);
	}
}

body {
	line-height: 1.5;
	white-space: pre-wrap;
}

a,
a.visited {
	color: inherit;
	text-decoration: underline;
}

.pdf-relative-link-path {
	font-size: 80%;
	color: #444;
}

h1,
h2,
h3 {
	letter-spacing: -0.01em;
	line-height: 1.2;
	font-weight: 600;
	margin-bottom: 0;
}

.page-title {
	font-size: 2.5rem;
	font-weight: 700;
	margin-top: 0;
	margin-bottom: 0.75em;
}

h1 {
	font-size: 1.875rem;
	margin-top: 1.875rem;
}

h2 {
	font-size: 1.5rem;
	margin-top: 1.5rem;
}

h3 {
	font-size: 1.25rem;
	margin-top: 1.25rem;
}

.source {
	border: 1px solid #ddd;
	border-radius: 3px;
	padding: 1.5em;
	word-break: break-all;
}

.callout {
	border-radius: 3px;
	padding: 1rem;
}

figure {
	margin: 1.25em 0;
	page-break-inside: avoid;
}

figcaption {
	opacity: 0.5;
	font-size: 85%;
	margin-top: 0.5em;
}

mark {
	background-color: transparent;
}

.indented {
	padding-left: 1.5em;
}

hr {
	background: transparent;
	display: block;
	width: 100%;
	height: 1px;
	visibility: visible;
	border: none;
	border-bottom: 1px solid rgba(55, 53, 47, 0.09);
}

img {
	max-width: 100%;
}

@media only print {
	img {
		max-height: 100vh;
		object-fit: contain;
	}
}

@page {
	margin: 1in;
}

.collection-content {
	font-size: 0.875rem;
}

.column-list {
	display: flex;
	justify-content: space-between;
}

.column {
	padding: 0 1em;
}

.column:first-child {
	padding-left: 0;
}

.column:last-child {
	padding-right: 0;
}

.table_of_contents-item {
	display: block;
	font-size: 0.875rem;
	line-height: 1.3;
	padding: 0.125rem;
}

.table_of_contents-indent-1 {
	margin-left: 1.5rem;
}

.table_of_contents-indent-2 {
	margin-left: 3rem;
}

.table_of_contents-indent-3 {
	margin-left: 4.5rem;
}

.table_of_contents-link {
	text-decoration: none;
	opacity: 0.7;
	border-bottom: 1px solid rgba(55, 53, 47, 0.18);
}

table,
th,
td {
	border: 1px solid rgba(55, 53, 47, 0.09);
	border-collapse: collapse;
}

table {
	border-left: none;
	border-right: none;
}

th,
td {
	font-weight: normal;
	padding: 0.25em 0.5em;
	line-height: 1.5;
	min-height: 1.5em;
	text-align: left;
}

th {
	color: rgba(55, 53, 47, 0.6);
}

ol,
ul {
	margin: 0;
	margin-block-start: 0.6em;
	margin-block-end: 0.6em;
}

li > ol:first-child,
li > ul:first-child {
	margin-block-start: 0.6em;
}

ul > li {
	list-style: disc;
}

ul.to-do-list {
	padding-inline-start: 0;
}

ul.to-do-list > li {
	list-style: none;
}

.to-do-children-checked {
	text-decoration: line-through;
	opacity: 0.375;
}

ul.toggle > li {
	list-style: none;
}

ul {
	padding-inline-start: 1.7em;
}

ul > li {
	padding-left: 0.1em;
}

ol {
	padding-inline-start: 1.6em;
}

ol > li {
	padding-left: 0.2em;
}

.mono ol {
	padding-inline-start: 2em;
}

.mono ol > li {
	text-indent: -0.4em;
}

.toggle {
	padding-inline-start: 0em;
	list-style-type: none;
}

/* Indent toggle children */
.toggle > li > details {
	padding-left: 1.7em;
}

.toggle > li > details > summary {
	margin-left: -1.1em;
}

.selected-value {
	display: inline-block;
	padding: 0 0.5em;
	background: rgba(206, 205, 202, 0.5);
	border-radius: 3px;
	margin-right: 0.5em;
	margin-top: 0.3em;
	margin-bottom: 0.3em;
	white-space: nowrap;
}

.collection-title {
	display: inline-block;
	margin-right: 1em;
}

.page-description {
    margin-bottom: 2em;
}

.simple-table {
	margin-top: 1em;
	font-size: 0.875rem;
	empty-cells: show;
}
.simple-table td {
	height: 29px;
	min-width: 120px;
}

.simple-table th {
	height: 29px;
	min-width: 120px;
}

.simple-table-header-color {
	background: rgb(247, 246, 243);
	color: black;
}
.simple-table-header {
	font-weight: 500;
}

time {
	opacity: 0.5;
}

.icon {
	display: inline-block;
	max-width: 1.2em;
	max-height: 1.2em;
	text-decoration: none;
	vertical-align: text-bottom;
	margin-right: 0.5em;
}

img.icon {
	border-radius: 3px;
}

.user-icon {
	width: 1.5em;
	height: 1.5em;
	border-radius: 100%;
	margin-right: 0.5rem;
}

.user-icon-inner {
	font-size: 0.8em;
}

.text-icon {
	border: 1px solid #000;
	text-align: center;
}

.page-cover-image {
	display: block;
	object-fit: cover;
	width: 100%;
	max-height: 30vh;
}

.page-header-icon {
	font-size: 3rem;
	margin-bottom: 1rem;
}

.page-header-icon-with-cover {
	margin-top: -0.72em;
	margin-left: 0.07em;
}

.page-header-icon img {
	border-radius: 3px;
}

.link-to-page {
	margin: 1em 0;
	padding: 0;
	border: none;
	font-weight: 500;
}

p > .user {
	opacity: 0.5;
}

td > .user,
td > time {
	white-space: nowrap;
}

input[type="checkbox"] {
	transform: scale(1.5);
	margin-right: 0.6em;
	vertical-align: middle;
}

p {
	margin-top: 0.5em;
	margin-bottom: 0.5em;
}

.image {
	border: none;
	margin: 1.5em 0;
	padding: 0;
	border-radius: 0;
	text-align: center;
}

.code,
code {
	background: rgba(135, 131, 120, 0.15);
	border-radius: 3px;
	padding: 0.2em 0.4em;
	border-radius: 3px;
	font-size: 85%;
	tab-size: 2;
}

code {
	color: #eb5757;
}

.code {
	padding: 1.5em 1em;
}

.code-wrap {
	white-space: pre-wrap;
	word-break: break-all;
}

.code > code {
	background: none;
	padding: 0;
	font-size: 100%;
	color: inherit;
}

blockquote {
	font-size: 1.25em;
	margin: 1em 0;
	padding-left: 1em;
	border-left: 3px solid rgb(55, 53, 47);
}

.bookmark {
	text-decoration: none;
	max-height: 8em;
	padding: 0;
	display: flex;
	width: 100%;
	align-items: stretch;
}

.bookmark-title {
	font-size: 0.85em;
	overflow: hidden;
	text-overflow: ellipsis;
	height: 1.75em;
	white-space: nowrap;
}

.bookmark-text {
	display: flex;
	flex-direction: column;
}

.bookmark-info {
	flex: 4 1 180px;
	padding: 12px 14px 14px;
	display: flex;
	flex-direction: column;
	justify-content: space-between;
}

.bookmark-image {
	width: 33%;
	flex: 1 1 180px;
	display: block;
	position: relative;
	object-fit: cover;
	border-radius: 1px;
}

.bookmark-description {
	color: rgba(55, 53, 47, 0.6);
	font-size: 0.75em;
	overflow: hidden;
	max-height: 4.5em;
	word-break: break-word;
}

.bookmark-href {
	font-size: 0.75em;
	margin-top: 0.25em;
}

.sans { font-family: ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol"; }
.code { font-family: "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace; }
.serif { font-family: Lyon-Text, Georgia, ui-serif, serif; }
.mono { font-family: iawriter-mono, Nitti, Menlo, Courier, monospace; }
.pdf .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK JP'; }
.pdf:lang(zh-CN) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK SC'; }
.pdf:lang(zh-TW) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK TC'; }
.pdf:lang(ko-KR) .sans { font-family: Inter, ui-sans-serif, -apple-system, BlinkMacSystemFont, "Segoe UI", Helvetica, "Apple Color Emoji", Arial, sans-serif, "Segoe UI Emoji", "Segoe UI Symbol", 'Twemoji', 'Noto Color Emoji', 'Noto Sans CJK KR'; }
.pdf .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .code { font-family: Source Code Pro, "SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.pdf .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK JP'; }
.pdf:lang(zh-CN) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK SC'; }
.pdf:lang(zh-TW) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK TC'; }
.pdf:lang(ko-KR) .serif { font-family: PT Serif, Lyon-Text, Georgia, ui-serif, serif, 'Twemoji', 'Noto Color Emoji', 'Noto Serif CJK KR'; }
.pdf .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK JP'; }
.pdf:lang(zh-CN) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK SC'; }
.pdf:lang(zh-TW) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK TC'; }
.pdf:lang(ko-KR) .mono { font-family: PT Mono, iawriter-mono, Nitti, Menlo, Courier, monospace, 'Twemoji', 'Noto Color Emoji', 'Noto Sans Mono CJK KR'; }
.highlight-default {
	color: rgba(55, 53, 47, 1);
}
.highlight-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.highlight-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.highlight-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.highlight-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.highlight-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.highlight-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.highlight-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.highlight-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.highlight-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.highlight-gray_background {
	background: rgba(241, 241, 239, 1);
}
.highlight-brown_background {
	background: rgba(244, 238, 238, 1);
}
.highlight-orange_background {
	background: rgba(251, 236, 221, 1);
}
.highlight-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.highlight-teal_background {
	background: rgba(237, 243, 236, 1);
}
.highlight-blue_background {
	background: rgba(231, 243, 248, 1);
}
.highlight-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.highlight-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.highlight-red_background {
	background: rgba(253, 235, 236, 1);
}
.block-color-default {
	color: inherit;
	fill: inherit;
}
.block-color-gray {
	color: rgba(120, 119, 116, 1);
	fill: rgba(120, 119, 116, 1);
}
.block-color-brown {
	color: rgba(159, 107, 83, 1);
	fill: rgba(159, 107, 83, 1);
}
.block-color-orange {
	color: rgba(217, 115, 13, 1);
	fill: rgba(217, 115, 13, 1);
}
.block-color-yellow {
	color: rgba(203, 145, 47, 1);
	fill: rgba(203, 145, 47, 1);
}
.block-color-teal {
	color: rgba(68, 131, 97, 1);
	fill: rgba(68, 131, 97, 1);
}
.block-color-blue {
	color: rgba(51, 126, 169, 1);
	fill: rgba(51, 126, 169, 1);
}
.block-color-purple {
	color: rgba(144, 101, 176, 1);
	fill: rgba(144, 101, 176, 1);
}
.block-color-pink {
	color: rgba(193, 76, 138, 1);
	fill: rgba(193, 76, 138, 1);
}
.block-color-red {
	color: rgba(212, 76, 71, 1);
	fill: rgba(212, 76, 71, 1);
}
.block-color-gray_background {
	background: rgba(241, 241, 239, 1);
}
.block-color-brown_background {
	background: rgba(244, 238, 238, 1);
}
.block-color-orange_background {
	background: rgba(251, 236, 221, 1);
}
.block-color-yellow_background {
	background: rgba(251, 243, 219, 1);
}
.block-color-teal_background {
	background: rgba(237, 243, 236, 1);
}
.block-color-blue_background {
	background: rgba(231, 243, 248, 1);
}
.block-color-purple_background {
	background: rgba(244, 240, 247, 0.8);
}
.block-color-pink_background {
	background: rgba(249, 238, 243, 0.8);
}
.block-color-red_background {
	background: rgba(253, 235, 236, 1);
}
.select-value-color-uiBlue { background-color: rgba(35, 131, 226, .07); }
.select-value-color-pink { background-color: rgba(245, 224, 233, 1); }
.select-value-color-purple { background-color: rgba(232, 222, 238, 1); }
.select-value-color-green { background-color: rgba(219, 237, 219, 1); }
.select-value-color-gray { background-color: rgba(227, 226, 224, 1); }
.select-value-color-translucentGray { background-color: rgba(255, 255, 255, 0.0375); }
.select-value-color-orange { background-color: rgba(250, 222, 201, 1); }
.select-value-color-brown { background-color: rgba(238, 224, 218, 1); }
.select-value-color-red { background-color: rgba(255, 226, 221, 1); }
.select-value-color-yellow { background-color: rgba(253, 236, 200, 1); }
.select-value-color-blue { background-color: rgba(211, 229, 239, 1); }
.select-value-color-pageGlass { background-color: undefined; }
.select-value-color-washGlass { background-color: undefined; }

.checkbox {
	display: inline-flex;
	vertical-align: text-bottom;
	width: 16;
	height: 16;
	background-size: 16px;
	margin-left: 2px;
	margin-right: 5px;
}

.checkbox-on {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20width%3D%2216%22%20height%3D%2216%22%20fill%3D%22%2358A9D7%22%2F%3E%0A%3Cpath%20d%3D%22M6.71429%2012.2852L14%204.9995L12.7143%203.71436L6.71429%209.71378L3.28571%206.2831L2%207.57092L6.71429%2012.2852Z%22%20fill%3D%22white%22%2F%3E%0A%3C%2Fsvg%3E");
}

.checkbox-off {
	background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg%20width%3D%2216%22%20height%3D%2216%22%20viewBox%3D%220%200%2016%2016%22%20fill%3D%22none%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%3E%0A%3Crect%20x%3D%220.75%22%20y%3D%220.75%22%20width%3D%2214.5%22%20height%3D%2214.5%22%20fill%3D%22white%22%20stroke%3D%22%2336352F%22%20stroke-width%3D%221.5%22%2F%3E%0A%3C%2Fsvg%3E");
}
	
</style></head><body><article id="99ebd66f-69ef-4307-82fa-4d74512a2c5b" class="page sans"><header><img class="page-cover-image" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/Evhzp8NXUAI1WQI.jpg" style="object-position:center 50%"/><div class="page-header-icon page-header-icon-with-cover"><img class="icon" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/37622c170030495.Y3JvcCwxMTUwLDkwMCwyNDIsMA.jpg"/></div><h1 class="page-title">CPP</h1><p class="page-description"></p></header><div class="page-body"><hr id="2528830c-e91c-4517-832d-2413fe404b17"/><p id="701a674d-3ef0-4b2a-bef1-9b7fe53c8d15" class="block-color-pink_background"><mark class="highlight-pink"><strong>Table of contents</strong></mark></p><nav id="0b6580d8-5efe-4cb7-88dd-ee93416a795c" class="block-color-pink table_of_contents"><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#5b68f5e9-c52d-43c5-a33a-a4265e5e00fc">Basics </a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#f9e96cbf-967f-4841-91f6-39395d88c7fe">good practice：有关头文件和include</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#b3c160cc-273f-4e33-bcec-9f4a6748f656">C++中的隐式类型转换、类构造函数的隐式转换、<strong>列表初始化 + 构造函数的隐式转换</strong></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#5ba3d9ec-dfaa-442f-9179-9bce3ecd79df">C++结构体、C结构体、C++类之间的区别</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#655c8485-cee0-48d1-9d23-887bbb2b3494">迭代器中，前缀递增++x与后缀递增x++的效率区别</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2791865f-9019-4201-9856-8584457acf1d">‘\n’与std::endl</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#7cf53478-969a-444d-aa15-d8224164d290">浅拷贝</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#05e89bd4-c060-4a16-a429-6b0bcb4b508a">闭包</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#b5f0a2cc-1dc3-4fcd-9bc7-84ed3ef61e60">列表初始化（花括号初始化）与传统初始化</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#fc688705-39fa-4a88-a4aa-652f73eb8f2c">结构化绑定：更方便地拆包</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#508502c4-395a-4c23-9bf9-97e22729d4c8">关键字：左值引用&amp;、右值引用&amp;&amp;、using、typename、::、static、inline、noexcept、void、<strong>decltype、this指针</strong></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#f6121460-8118-44eb-8447-d97ccad6c148">迭代器的value_types</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#c4a44104-b34d-4ad8-a9c0-18c95acdb354">函数指针：<strong>std::function&lt;返回类型(参数类型)&gt;</strong></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#df4cdb1b-86f4-45c4-83a8-dd0827f2b6f1">谓词函数</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2c7dafcc-9f3b-4857-9cae-19298a0b4cff">C++17：if语句中允许加入初始化语句</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#d828a842-7413-4b24-b3b7-045e55f9ca74">左值l-value、右值r-value（临时变量）</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#21aacca8-f44a-493a-bc63-16c0750f2a82">const关键字</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#a353f27f-0018-4e53-ae2d-6208dd7dbfa6">const的基本用法、</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#3b443e0d-17d6-474d-8db8-3bd6e91138b1">常量引用const  + &amp; ：使用常量引用修饰函数参数和返回值</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#3c87c0cf-469e-4de4-849e-1ed1574c9233">const只有修饰引用(常量引用)和指针(指向常量的指针)才有意义</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#297a58de-0d34-4370-a6a7-f53127e0c910">注意点：当一起使用auto、const、&amp;时</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#5e404930-0288-4555-91d1-d66a843e5dde">const接口(const修饰的类成员函数)：const接口中的this常量指针、宽松const接口、严格const接口</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#28860efa-7129-4358-a65e-f54e76f94da7">const总结</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#74c333e5-56fa-4b7a-9313-7a3fe7d7273c">自定义类</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#5f29b02a-2951-4b26-9a32-b1c0fb5647de">basics</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#e6a4b9da-5d96-44d1-a3a9-64df7871f0a2">有关(模版)类声明和(模版)类定义的代码组织</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#5ec30e56-0251-4e05-ade2-995cc1193aa5">自定义类时的一个坑点：初始化次序</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#4e46f31d-2503-423a-b16d-b623374bda53">类的静态成员</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#a4dd4546-781f-4e66-8505-78db2c4d8182">在类中可重载的运算符</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#d50d75fe-39c8-4d84-b00f-b043a28fc156">成员函数的各种修饰符：explicit、= default、= delete、 =0</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#27a16453-a22f-4e50-976f-39154bfdbe5b">类的初始化列表：减少overhead</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#bb68256c-f80d-49c5-94ba-84d01d6a3272">在初始化列表中使用委托构造函数（Delegating Constructor）</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#9dc9b247-f82a-4ba5-a346-acae27b16d66">在类中通过结构体定义一个变量</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#0d2661a8-ef4b-4915-ad83-8001c3d73f30">类中的特殊成员函数及其高效实现</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#9c578917-a628-4b1f-a578-d65e7db2a77b"><strong>初始化器列表构造函数：用于</strong>自定义类的花括号初始化</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#d2b0d455-3dd8-41a4-a271-1ab9c118e08a">case：一个简单的自定义类</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#0e168ba7-3533-4512-a594-ff4fe615cc5e">类进阶：类中特殊的成员函数（高效实现）</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2c7eafa6-9f32-46d7-81d4-7288ede362b0">实现构造函数的一个trick：使用默认值</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#66c0774b-9dfe-4572-ab54-9f4722411c88">拷贝构造函数</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#8c67d29b-57b2-4c1f-aad4-106226062623">赋值运算符重载</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#b38b3a27-4b92-48fe-86ec-488259fdbb15">移动拷贝构造函数、移动赋值运算符</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#72e137f4-ba28-49fb-8f37-b92c5be5d94d">由编译器<strong>自动生成：默认构造函数、默认拷贝构造函数、默认拷贝赋值运算符等</strong></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#92ebcecb-e1ca-414a-a936-0f34d8556d29">Rule of zero、Rule of five</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2f61ed80-a561-4937-8756-6dc2e519ef24">一个非常值得学习的case：CS106L HashMap(HashMap + HashMapIterator)</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#3c22d164-c4a6-4f80-946c-cc28738b75d5">类进阶：友元、运算符重载</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#dd243657-3fdd-4348-9db8-937dd4b104d6">类进阶：虚函数 、动态绑定(实现多态)</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#cebf9ae0-16ae-4e18-86ae-f90319ccf300">模版类</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#c7ab2a26-fe9b-4636-b50e-b5b46b786e99">模版类的声明的定义要写到一起</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#0a3426cf-d1a2-488c-95ab-1808efa036d7">模版类的声明和定义的具体写法</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#3527c4dd-5b4f-4226-a791-3435ccbf18db">模版中的类型可以有默认类型、实例化模版时加入const</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#c2b4d5a5-e033-4aec-ba01-62f363075fc9">非类型模版参数</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#87ceba30-68d0-4bd1-8d71-bc57efa83128">在模版类中定义一个成员模版函数（易混淆）</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#4464256d-125b-4592-ba0f-da07f6c6e78b">模版函数</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#0fd07e57-f90c-4712-8be0-3a470989cc69"><strong>Concepts 和 Constraints：使模版代码更容易维护（C++20）</strong></a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#e7ca8bae-0680-44f9-850e-264e33beba28">模版元编程TMP与constexpr  </a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#f49a47c3-cc65-4358-acfd-bb3fba6fd39f">Lambda表达式  </a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#514fa35e-30e6-4b52-8fbf-1173f0fb033b">Functor （函数对象） </a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#b31af386-fc14-4f99-bed0-478ee12f8520">algorithm包</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#6a073728-12b4-4946-aca4-92f13541fe92">ranges库(C++ 20)：STL 2.0，函数式编程</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2a86cba9-4c49-4ea0-8713-34bec9d541f3">基本概念：Range与view</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#cfbe9edf-a38c-478a-8d67-e543c8dcb6f0">一些用例</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#797952b6-9882-4dab-870a-9be4c8763c91">std::views支持的操作</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#8db35b94-d289-4580-be18-e80da79d4937">std::ranges</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#4e1f4490-3879-4b92-ba39-897238f03cfa">std::optional模版类：提供类型安全</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#23db45b0-7239-400c-b663-e37c179ace35">Undefined behavior</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#f0cd0451-ae6b-4ea2-8b76-02625e3ffd83">std::optional与nullopt</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#3a72c194-ac4f-43ba-99e1-53822f430b63">std::optional&lt;ValueType&gt;模版类提供的类方法</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#98ecaa62-5882-4dd1-9a03-f2c4b93bcb20">std::optional&lt;Myclass&gt;与自定义类的构造函数之间的关系</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#f84e827e-0932-42af-bf02-a29e38757ea4">使用std::optional的pros and cons</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#d7e60c07-2b20-4e63-9837-5940bd6793e1">RAII：一种在很多编程语言中具有的实践或者理念</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#36240169-e440-43e6-ab93-5d621de00810">智能指针：内存管理的RAII实践</a></div><div class="table_of_contents-item table_of_contents-indent-0"><a class="table_of_contents-link" href="#4f898396-ad25-4292-8c89-5a879df5bf77">一些可能会用到的std函数、类、模版</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#e460899b-5560-495b-807e-3280bf476623">std::conditional_t：在编译时根据条件在两种类型中进行选择</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#628b5806-cef5-4102-af49-4bc0d610c65a"><strong>static_cast：静态类型转换</strong></a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#dab1c036-a5f9-4f16-95e7-37ec0dc7fa06">const_cast：实现const类型转换</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#973b3732-ca74-469e-8c7e-d15acb4c514b">std::distance：计算两个iterator的距离</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#2444638e-c77c-4b29-9526-fde88d3cc674">std::move：把一个左值转换为右值</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#cedb7245-edbd-4acf-8995-6308cadfd492">std::is_permutation：比较两个序列是否相等（顺序可以不同）</a></div><div class="table_of_contents-item table_of_contents-indent-1"><a class="table_of_contents-link" href="#e4400047-128f-4752-b6b8-03de0f335fff"><strong>std::ostringstream：适用于复杂的字符串处理和格式化的场景</strong></a></div></nav><hr id="501d4668-b3a7-4e1f-af95-19baa28ca295"/><ul id="90c0c9a5-5420-4a6e-859d-158faa6e4159" class="bulleted-list"><li style="list-style-type:disc">2023 CS106L（课件更新更好）<figure id="495f2bff-dad6-46b8-a600-6178ec1b3f6d"><a href="https://web.stanford.edu/class/archive/cs/cs106l/cs106l.1234/index.html" class="bookmark source"><div class="bookmark-info"><div class="bookmark-text"><div class="bookmark-title">CS 106L: Standard C++ Programming</div><div class="bookmark-description">🌽 CS 106L is a companion class to CS106B/CS106X that explores the modern C++ language in depth. We&#x27;ll cover some of the most exciting features of C++, including modern patterns that give it beauty and power.</div></div><div class="bookmark-href"><img src="https://web.stanford.edu/favicon.ico" class="icon bookmark-icon"/>https://web.stanford.edu/class/archive/cs/cs106l/cs106l.1234/index.html</div></div></a></figure></li></ul><ul id="7820b585-3323-464f-8e73-e45b0595cb64" class="bulleted-list"><li style="list-style-type:disc">2022 CS106L（代码更全）<figure id="80007112-d5a5-44b7-9a74-dc75a16e2ef7"><a href="https://web.stanford.edu/class/archive/cs/cs106l/cs106l.1224/" class="bookmark source"><div class="bookmark-info"><div class="bookmark-text"><div class="bookmark-title">CS 106L: Standard C++ Programming</div><div class="bookmark-description">🌽 CS 106L is a companion class to CS106B/CS106X that explores the modern C++ language in depth. We&#x27;ll cover some of the most exciting features of C++, including modern patterns that give it beauty and power.</div></div><div class="bookmark-href"><img src="https://web.stanford.edu/favicon.ico" class="icon bookmark-icon"/>https://web.stanford.edu/class/archive/cs/cs106l/cs106l.1224/</div></div></a></figure></li></ul><blockquote id="d43f4c16-b69d-402e-9951-417a4245d26d" class="block-color-gray_background">目前进度：15 RAII</blockquote><hr id="a1113b91-5afd-4e87-9003-6749770d425b"/><ul id="6101abb6-8a0f-4ee1-8caa-9328a4b320b9" class="bulleted-list"><li style="list-style-type:disc"><strong>C++ Core Guidelines</strong><figure id="9609490b-dfe2-4438-8e55-099aa7f8bb5d"><a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#S-resource" class="bookmark source"><div class="bookmark-info"><div class="bookmark-text"><div class="bookmark-title"></div></div><div class="bookmark-href">https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#S-resource</div></div></a></figure><ul id="1f0675ef-7bc1-42b8-9444-5dbb17cfe5e8" class="bulleted-list"><li style="list-style-type:circle">由C++之父编写，罗列了非常多使用CPP的good practice和bad practice，涵盖了各种场景</li></ul></li></ul><ul id="5db7188f-0e9d-465d-8df4-4283054ef8c0" class="bulleted-list"><li style="list-style-type:disc"><strong>cppreference</strong>：罗列了各种常用的库，以及各个C++标准引入的库<figure id="2cb72652-780b-4cbd-adf3-9a475559803b"><a href="https://en.cppreference.com/w/" class="bookmark source"><div class="bookmark-info"><div class="bookmark-text"><div class="bookmark-title">cppreference.com</div><div class="bookmark-description">C++ reference
C++11, C++14, C++17, C++20, C++23, C++26  │  Compiler support C++11, C++14, C++17, C++20, C++23, C++26</div></div><div class="bookmark-href"><img src="https://en.cppreference.com/favicon.ico" class="icon bookmark-icon"/>https://en.cppreference.com/w/</div></div></a></figure><figure id="d18a0f16-c359-4bf0-88f0-0639432be9c3" class="image" style="text-align:center"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-02-13_14.01.29.png"><img style="width:480px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-02-13_14.01.29.png"/></a></figure></li></ul><h2 id="5b68f5e9-c52d-43c5-a33a-a4265e5e00fc" class="block-color-orange_background">Basics </h2><h3 id="f9e96cbf-967f-4841-91f6-39395d88c7fe" class="block-color-blue_background">good practice：有关头文件和include</h3><ul id="41e50d1d-70f8-4855-97d0-d39814b790e8" class="bulleted-list"><li style="list-style-type:disc">对于一些<mark class="highlight-purple"><span style="border-bottom:0.05em solid"><strong>公共头文件，使用namespace将其包裹起来，名字可以取存头文件所在目录的名字</strong></span></mark>，从而防止命名冲突</li></ul><ul id="59ba6ceb-869c-48f6-8073-80557616fd9f" class="bulleted-list"><li style="list-style-type:disc">在include公共头文件时，<mark class="highlight-purple"><strong>不要直接include头文件，而是使用包含了头文件所在目录名字的路径</strong></mark>，例如<code>#include &quot;static/Hello.h&quot;</code>，而不是<code>#include &quot;Hello.h&quot;</code>，从而防止命名冲突<ul id="5a563e23-84fe-431a-b2e9-a0b0522cc79a" class="bulleted-list"><li style="list-style-type:circle">记得把include的路径加进来（在gcc中通过-I参数，在CMake中通过<a href="https://www.notion.so/CMake-ae0cdbadb4cb4958b3b60e1534fe1d12?pvs=21"><code>add_include_directories</code></a>）</li></ul></li></ul><ul id="30531793-4b8c-45b9-a2c3-5a30ea2e7f46" class="bulleted-list"><li style="list-style-type:disc">几个概念<ul id="ec1770c5-612b-4e41-9205-9b5fd445f7e1" class="bulleted-list"><li style="list-style-type:circle">函数的声明、函数的定义（也就是函数的实现）</li></ul><ul id="1cba1306-72c1-45fd-b4db-f93106ff8d73" class="bulleted-list"><li style="list-style-type:circle">类的声明、类的定义（也就是类的实现）</li></ul></li></ul><ul id="417ca481-a3ef-41c7-9903-4c8fb1f0be62" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-red"><span style="border-bottom:0.05em solid"><strong>对于非模版类，非模版函数</strong></span></mark>：<mark class="highlight-purple"><strong>把类/函数的声明和具体实现（定义）分别写在头文件(.h)和源文件(.cpp)</strong></mark>中，这样子做有很多原因<ol type="1" id="5f504101-13f7-4f6a-ae06-d56a17f7b73d" class="numbered-list" start="1"><li><span style="border-bottom:0.05em solid"><strong>防止链接时产生重复定义</strong></span>：例如在myclass.h中声明了一个类（或函数）及其定义（实现），在main.cpp和lib.cpp中#include了myclass.h，然后我把main.cpp和lib.cpp进行分别编译，然后链接到一起。<br/>此时由于main.cpp和lib.cpp的链接文件中同时都有类的定义，从而导致链接时报错：重复的符号定义<br/>但如果把类的声明放在myclass.h中，把定义放在myclass.cpp中，然后链接main，lib，myclass，就不会有问题（因为只有myclass中有类的实现(定义)）<br/></li></ol><ol type="1" id="3d4fa2a9-7b63-4e57-88c9-c9064f8fe71b" class="block-color-default numbered-list" start="2"><li>这样类的整体结构会看的<span style="border-bottom:0.05em solid"><strong>更加清晰</strong></span>，并且源代码可以进行编译，从而可以只提供头文件，不<span style="border-bottom:0.05em solid"><strong>暴露源码</strong></span>，</li></ol></li></ul><ul id="28ddcce7-ba0a-488d-9f2d-3e0564bf3e17" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-red"><span style="border-bottom:0.05em solid"><strong>对于模版类、模版函数</strong></span></mark>：<mark class="highlight-purple"><strong>把模版类/函数的声明和实现（定义）直接写在头文件(.h)里</strong></mark>，并且<strong>在类里面写声明语句，在类外面写定义</strong>（这样类的整体结构会看的更加清晰）；<br/><br/><mark class="highlight-purple"><strong>或者把模版类\函数 的定义写在一个.tpp</strong></mark><mark class="highlight-default">（注意，</mark><mark class="highlight-red"><strong>模版类\函数 的定义放在.tpp而不是.cpp</strong></mark><mark class="highlight-default">），</mark><span style="border-bottom:0.05em solid"><strong><mark class="highlight-default">然后在.h的最后#include .tpp</mark></strong></span><mark class="highlight-default">，并把这个</mark><mark class="highlight-purple"><strong>.tpp文件放在与.h文件相同的目录下</strong></mark>。<br/>（在.h的最后#include .tpp本质上与直接写在.h里面是等价的）<br/><ul id="858e7f9e-3de4-403e-8e19-aa2d2afc6cfc" class="bulleted-list"><li style="list-style-type:circle">之所以模版类\函数 直接把声明和实现（定义）写在一起是因为：<ol type="1" id="66ebbaf5-eb7f-4d06-aac2-7ee7b5b69fd3" class="numbered-list" start="1"><li><mark class="highlight-red"><strong><span style="border-bottom:0.05em solid"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">否则会报错</a></span></strong></mark></li></ol><ol type="1" id="8e53c1e6-ef9a-48a3-8ee3-f58cf19c392e" class="numbered-list" start="2"><li>模版类和模版函数会在编译时就让编译器生成对应的具体实现（定义），所以在编译时就必须提供模版类/模版函数的实现（定义）<blockquote id="cb0d11f6-6cc8-4e21-bb2e-9e25e2f5ce28" class="block-color-gray_background">在模版类和模版函数中，把声明和定义直接写在.h中不会产生链接时重复定义的问题，<br/><br/>因为编译器会在编译阶段自动生成对应模版的具体定义（实现），<br/><span style="border-bottom:0.05em solid"><strong>在多个源文件中包含这个头文件时，每个源文件包含的模板类定义都是独立的</strong></span>。编译器在处理每个包含此头文件的源文件时，会根据需要生成模板类的实例。这些实例是根据模板参数生成的，因此即使模板类的定义在多个源文件中出现，也不会导致重复定义问题。</blockquote></li></ol></li></ul></li></ul><h3 id="b3c160cc-273f-4e33-bcec-9f4a6748f656" class="block-color-blue_background">C++中的隐式类型转换、类构造函数的隐式转换、<strong>列表初始化 + 构造函数的隐式转换</strong></h3><ul id="a6b8f94f-1935-46a7-b978-236713c3de70" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>隐式类型转换</strong></span>：在C++中，假如变量的声明与实际的赋值类型不一致时，就会导致隐式类型转换，例如：<ol type="1" id="66e09685-eb79-4494-9d61-0569d5a925c2" class="numbered-list" start="1"><li>定义了一个int变量，但赋值时给的是float，此时C++会默认把float转int后再赋值给这个变量</li></ol><ol type="1" id="3fe5c8af-4252-4e9f-8c0f-e52bfadb60a9" class="numbered-list" start="2"><li>函数声明了一个int类型参数，但是实参是一个float，发生的事情与1)一样</li></ol><ol type="1" id="08cd47ec-2976-49a5-be64-58a365ac2626" class="numbered-list" start="3"><li>函数声明一个int类型返回值，但是返回了一个float，发生的事情与1)一样</li></ol><ol type="1" id="5f74aab2-0042-422e-84bc-20439736ba32" class="numbered-list" start="4"><li>一个表达式中包含多种不同的基本数据类型时（如<code><strong>int</strong></code>、<code><strong>float</strong></code>、<code><strong>double</strong></code>等），较小的类型通常会被自动转换（提升）到较大的类型，以便表达式有一个共同的类型。<blockquote id="1dc3b2c1-f3c1-48fa-be67-6aedcefc4ecc" class="block-color-gray_background">这种情况本质上就是2) 与 3)，在调用类的运算符成员函数时，实参类型不匹配，从而发生2)的隐式转换</blockquote></li></ol></li></ul><ul id="64acc6fa-89a6-4d40-9096-b3c5e88fc546" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-purple"><span style="border-bottom:0.05em solid"><strong>类构造函数的隐式转换</strong></span></mark>：当一个类的构造函数只需要一个参数（或所有参数除了一个都有默认值）时，C++允许这个构造函数被用于隐式类型转换。这种转换允许直接从构造函数的参数类型转换到该类类型，而不需要显式调用构造函数。例如：<ol type="1" id="a0a4b81a-8e7f-4bd5-aaf6-fbed5f3d1520" class="numbered-list" start="1"><li>声明类并进行赋值时，函数参数进行传参数时，发生构造函数的隐式转换<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17ded5eb-f9a8-47ae-8e06-7eb274cd1e54" class="code"><code class="language-C++">#include &lt;iostream&gt;

class B {
public:
    B(int x = 0, bool b = true) {  // 可以使用explicit关键字来修饰这个构造函数
        std::cout &lt;&lt; &quot;B object created with values: x=&quot; &lt;&lt; x &lt;&lt; &quot;, b=&quot; &lt;&lt; std::boolalpha &lt;&lt; b &lt;&lt; std::endl;
    }
};

void functionTakingB(B bObject) {
    std::cout &lt;&lt; &quot;functionTakingB called&quot; &lt;&lt; std::endl;
}
int main() {
    B tmp = 42; // 如果B的构造函数不是explicit的，这将会隐式地创建一个B对象
    
    functionTakingB(42); // 如果B的构造函数不是explicit的，这将会隐式地创建一个B对象
    functionTakingB(B(42)); // 正确：显式地使用构造函数
    return 0;
}</code></pre></li></ol><ol type="1" id="4862b78c-09c5-41d4-84de-d66b745f3ab0" class="numbered-list" start="2"><li><span style="border-bottom:0.05em solid"><strong>列表初始化 + 构造函数的隐式转换（很常用）</strong></span>：函数传参时，函数返回时<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="37f96b4b-242b-4f39-95b6-c90a63d9e36e" class="code"><code class="language-C++">class MyClass {
public:
    // 可以使用explicit关键字来修饰这个构造函数，来禁用构造函数的隐式调用
    MyClass(int a, double b, char c, std::string d) : m_a(a), m_b(b) {}

private:
    int m_a;
    double m_b;
};

// 函数返回时：
// 使用列表初始化的方法来进行构造函数的隐式转换
MyClass createMyClass() {
    return {1, 2.3};
}

// 函数传参时：
// 使用列表初始化的方法来进行构造函数的隐式转换
void processMyClass(MyClass obj) {
    // 处理obj的逻辑
}
int main() {
    processMyClass({1, 2.3});
    return 0;
}
```</code></pre></li></ol></li></ul><h3 id="5ba3d9ec-dfaa-442f-9179-9bce3ecd79df" class="block-color-blue_background">C++结构体、C结构体、C++类之间的区别</h3><ul id="772ef35b-7b27-45e4-a749-71ff4eb03214" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-purple"><strong>默认访问控制</strong></mark>：在C++中，结构体成员的默认访问权限是<em>public</em>，而类成员的默认访问权限是<em>private</em>。这意味着，除非另有指定，结构体的成员在外部是可直接访问的。<ul id="54154317-cb44-4b8b-b6c6-88a11904ef0b" class="bulleted-list"><li style="list-style-type:circle">相比之下，C中的结构体不涉及访问控制的概念，其成员默认都是公开的。</li></ul></li></ul><ul id="6445cdd9-b132-4c15-991b-19171392bdb1" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-purple"><strong>成员函数和构造函数</strong></mark>：C++的结构体<strong>可以包含成员函数、构造函数、析构函数、</strong><span style="border-bottom:0.05em solid"><strong>类型别名</strong></span><strong>等</strong>，允许执行更复杂的初始化和清理操作，以及封装相关的操作。这使得C++的结构体能够用作更接近类的方式。<ul id="67093e2d-1b2d-49af-b4c6-2cfd76ee0918" class="bulleted-list"><li style="list-style-type:circle">相比之下，C语言的结构体不能包含函数。</li></ul></li></ul><ul id="6e121a65-c0e1-44d2-86f9-7db831942a20" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-purple"><strong>继承和多态</strong></mark>：C++结构体支持继承和多态，意味着<strong>一个结构体可以继承另一个结构体或类</strong>，并且可以使用虚函数来实现多态。这是C++面向对象编程的一部分<ul id="e57cffc3-ab9c-4f73-b893-29c7bb7d104c" class="bulleted-list"><li style="list-style-type:circle">相比之下，C语言结构体不支持这些概念。</li></ul></li></ul><ul id="8749487b-ea80-4399-9b28-1a63def74017" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-purple"><strong>模板</strong></mark>：C++<strong>允许结构体成为模板</strong>，这意味着可以定义能够处理多种数据类型的通用结构体。<ul id="c6b2d688-8c7e-41f3-8e72-631abb90a56f" class="bulleted-list"><li style="list-style-type:circle">C语言结构体不支持模板。</li></ul></li></ul><ul id="994ab595-193f-4d96-867e-e79d25114de4" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-purple"><strong>声明更加简洁</strong></mark>：声明C结构体时必须在前面加一个struct，而C++结构体不需要。</li></ul><ul id="d04c8614-9d38-4533-b902-8a026147ed6e" class="bulleted-list"><li style="list-style-type:disc">case:<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="de2135fc-11dd-4f3f-8670-3aaf2ecf4ec3" class="code"><code class="language-C++">struct Person {
    using name_type = std::string;
    using age_type  = size_t;

    name_type name;
    age_type age;

    // 构造函数，通过利用默认值的设置，来同时构造多种情况的构造函数，使代码更紧凑
    Person(const name_type&amp; name = &quot;&quot;, age_type age = 0) : name(name), age(age) {}

    // 成员函数
    void introduce() const {
        std::cout &lt;&lt; &quot;Name: &quot; &lt;&lt; name &lt;&lt; &quot;\nAge: &quot; &lt;&lt; age &lt;&lt; std::endl;
    }
};

int main() {
    Person person{&quot;John Doe&quot;, 30};
    person.introduce();
    return 0;
}</code></pre></li></ul><ul id="33bbc926-741e-4065-b36c-7ff874ce85aa" class="bulleted-list"><li style="list-style-type:disc">还可以在类中定义一个结构体类型：<a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">case</a></li></ul><h3 id="655c8485-cee0-48d1-9d23-887bbb2b3494" class="block-color-blue_background">迭代器中，前缀递增++x与后缀递增x++的效率区别</h3><ul id="c67d2f20-48b6-40a9-b71c-1c6fb367021e" class="bulleted-list"><li style="list-style-type:disc">x++的实现需要比++x的实现多一个<a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">拷贝构造函数</a>的时间：因为对于一个前向迭代器，往前迭代后就会丢失上一次迭代前的状态。因此对于x++，在<span style="border-bottom:0.05em solid"><strong>实现后缀递增运算符时，必须先拷贝递增前的状态</strong></span>，然后再递增迭代器后，再返回这个拷贝。<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="b7e85158-0f7a-4320-9e01-ef8f4f41d597" class="code"><code class="language-C++">iterator Myclass::operator++(int) {  
    // C++通过operator++()与operator++(int)来区别前缀递增运算符与后缀递增运算符
    auto copy = *this; // calls the copy constructor to create copy
    ++(*this);  // 调用前缀递增运算符
    return copy;
}</code></pre></li></ul><ul id="557eae0d-31bb-41ad-968b-4c383a4cd1cf" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>所以在迭代一个迭代器时，尽量用++x来进行迭代</strong></span></li></ul><h3 id="2791865f-9019-4201-9856-8584457acf1d" class="block-color-blue_background">‘\n’与std::endl</h3><ul id="c196b80c-f1cd-4353-abea-98239f87e0f4" class="bulleted-list"><li style="list-style-type:disc">尽量用’\n’ 来替代<code>std::endl</code>。因为把std::endl送入标准输出时，会立马刷新缓存，将之前的内容进行打印（而每次打印都会进行系统调用，从而导致IO性能下降）</li></ul><h3 id="7cf53478-969a-444d-aa15-d8224164d290" class="block-color-blue_background">浅拷贝</h3><ul id="cf402889-c9f2-436b-8fb5-936b7aead1be" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>浅拷贝</strong></span>本质上就是做了一个别名，指向的是同一块内存<ul id="0dfd26ea-604d-4f11-b7de-191a95292746" class="bulleted-list"><li style="list-style-type:circle">另外，可以把浅拷贝理解成一种member-wise的copy，它不会去拷贝对应的内存；相反，深拷贝就是一种迭代式的copy，它会连同指向的内存一起拷贝。</li></ul></li></ul><h3 id="05e89bd4-c060-4a16-a429-6b0bcb4b508a" class="block-color-blue_background">闭包</h3><ul id="d6330b42-1ff6-4975-8484-32d6370cc413" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>闭包</strong></span>：闭包在编程中是一个重要的概念，通常指的是<strong>函数和其相关引用环境的组合</strong>。<br/>即：闭包不仅仅是一个函数，它还<br/><span style="border-bottom:0.05em solid"><em>包括该函数创建时所在的作用域中的任何局部变量的引用</em></span>。这意味着即使函数的执行上下文已经离开了变量的作用域，闭包仍然可以访问和修改这些外部变量。<blockquote id="bf5ea81c-677a-4a80-937b-a772ddf79c1e" class="block-color-gray_background">在C++中，通过<a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">lambda表达式</a>的参数捕获列表可以实现闭包</blockquote></li></ul><h3 id="b5f0a2cc-1dc3-4fcd-9bc7-84ed3ef61e60" class="block-color-blue_background">列表初始化（花括号初始化）与传统初始化</h3><ul id="e36dad2c-b420-437f-b22f-d5bb5138c818" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>列表初始化</strong></span>（<span style="border-bottom:0.05em solid"><strong>花括号初始化</strong></span>）<code>x{..}</code>与传统的括号初始化<code>x(..)</code>的区别<ul id="3ffaa6a4-d332-4722-b907-468a8245c573" class="bulleted-list"><li style="list-style-type:circle"><strong>列表初始化 </strong><code><strong>{}</strong></code>：严格进行类型匹配，防止窄化转换（如double转int），适用于所有类型，提供统一的初始化语法。（C++11引入的特性，<strong>good practice</strong>）</li></ul><ul id="27504b06-4409-4815-a27d-ed215c6cff65" class="bulleted-list"><li style="list-style-type:circle"><strong>构造函数初始化 </strong><code><strong>()</strong></code>：更传统，允许窄化转换</li></ul><blockquote id="9dd8c027-323b-4c6a-8d17-906c7d7661c1" class="block-color-gray_background"><mark class="highlight-purple"><strong>花括号初始化和普通的初始化在流程上的区别</strong></mark>：使用花括号初始化时，编译器会优先从<a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">初始化器列表构造函数</a>开始匹配，再从一般的重载构造函数开始匹配；而普通的的初始化直接从一般的重载构造函数开始匹配<br/><br/><br/><span style="border-bottom:0.05em solid"><strong>所以花括号初始化的适用范围还比普通的初始化要大</strong></span>（多了初始化器列表构造函数可以匹配）</blockquote></li></ul><ul id="bb40d521-9b73-43c4-9104-bb2cd3ffde43" class="bulleted-list"><li style="list-style-type:disc">trick1：<a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">列表初始化+构造函数的隐式调用</a></li></ul><ul id="7f2aac09-7f6f-4085-aee9-3b92859bbfd6" class="bulleted-list"><li style="list-style-type:disc">trick2：pair中的双重列表初始化<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="dedfc73b-c2c5-4819-ae17-ed1f41c67934" class="code"><code class="language-C++">std::pair&lt;int, std::vector&lt;std::string&gt;&gt; foo{1, {&quot;Apple&quot;, &quot;Banana&quot;, &quot;Cherry&quot;}};
std::pair&lt;int, std::vector&lt;std::string&gt;&gt; bar{{}, {&quot;Apple&quot;, &quot;Banana&quot;, &quot;Cherry&quot;}};
std::pair&lt;int, std::vector&lt;std::string&gt;&gt; bar{-100, {}};</code></pre><ul id="c473ca18-faae-4121-84e1-ed1a0ca8ec8b" class="bulleted-list"><li style="list-style-type:circle">传入一个空的{}，表示使用默认的无参构造函数</li></ul></li></ul><h3 id="fc688705-39fa-4a88-a4aa-652f73eb8f2c" class="block-color-blue_background">结构化绑定：更方便地拆包</h3><ul id="1ab16569-9e73-4872-bac3-cfa2c01e607e" class="bulleted-list"><li style="list-style-type:disc">使用<span style="border-bottom:0.05em solid"><strong>结构化绑定</strong></span>（类似于python中的拆包）来给变量赋值。<blockquote id="870b75b8-0bd7-4158-a0ae-16098bc835c7" class="block-color-gray_background">结构化绑定是 C++17 引入的一种特性，它允许您从一个元组、结构体或数组中方便地解包（unpack）数据到单独的变量中。这使得代码更加清晰和简洁。</blockquote><ul id="bdb54fac-0959-4e35-afe8-baa89fd0f975" class="bulleted-list"><li style="list-style-type:circle">一个对<code>map</code>使用结构化绑定（拆包）的例子（⚠️：<span style="border-bottom:0.05em solid"><strong><code>map</code></strong></span><span style="border-bottom:0.05em solid"><strong>中的每个元素就是一个</strong></span><span style="border-bottom:0.05em solid"><strong><code>pair</code></strong></span>）<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="c61b3c39-6227-4f26-bdce-e097514bba54" class="code"><code class="language-C++">#include &lt;map&gt;
#include &lt;string&gt;
#include &lt;iostream&gt;

int main() {
    std::map&lt;int, std::string&gt; myMap = {
				//使用{}来进行pair&lt;int, std::string&gt;的初始化
        {1, &quot;one&quot;}, 
        {2, &quot;two&quot;},
        {3, &quot;three&quot;}
    };

    // 使用结构化绑定遍历 map
    for (const auto&amp; [key, value] : myMap) {
        std::cout &lt;&lt; &quot;Key: &quot; &lt;&lt; key &lt;&lt; &quot;, Value: &quot; &lt;&lt; value &lt;&lt; std::endl;
    }
    
    auto&amp; [k, v] = *(myMap.begin());
    return 0;
}</code></pre></li></ul></li></ul><h3 id="508502c4-395a-4c23-9bf9-97e22729d4c8" class="block-color-blue_background">关键字：左值引用&amp;、右值引用&amp;&amp;、using、typename、::、static、inline、noexcept、void、<strong>decltype、this指针</strong></h3><ul id="7ec8ad8b-257c-4294-af43-1fc607b977bf" class="bulleted-list"><li style="list-style-type:disc"><em><strong><code>&amp;</code></strong></em><strong>关键字</strong>：在声明一个变量，或者在函数中定义一个参数时，对于用了<span style="border-bottom:0.05em solid"><strong>引用</strong></span><strong><code>&amp;</code></strong>修饰的变量，表示在赋值时进行的是浅拷贝，因此仅仅是做了一个别名，指向的还是同一块内存（如果没有用&amp;修饰，则默认表示进行<strong>按值传递</strong>）<ul id="78af742a-7e6b-4679-af08-6f511d91f534" class="bulleted-list"><li style="list-style-type:circle">如果函数return的值是一个引用，而接受返回值的变量不是一个引用，那么相当于把返回的引用做了一个深拷贝然后赋值给另一个变量</li></ul><ul id="9568b7df-341a-429c-9b91-5a4b3a76edbb" class="bulleted-list"><li style="list-style-type:circle"><strong>可以给函数的返回值后面加一个引用符</strong><code><strong>&amp;</strong></code>，表示返回的值也是一个引用。（否则进行的是<strong>按值返回</strong>）</li></ul></li></ul><ul id="0b60fa31-2715-4b69-a26e-cfbced21bf87" class="bulleted-list"><li style="list-style-type:disc"><strong><em><code>&amp;&amp;</code></em></strong><strong>关键字</strong>：<a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">ref</a></li></ul><ul id="76506fdf-7a66-4760-86b6-1a65cfea2c6a" class="bulleted-list"><li style="list-style-type:disc"><em><strong><code>using</code></strong></em><strong>关键字</strong>：C++11引入的特性<ul id="eeba988e-4714-4e1b-9444-03e771b3178e" class="bulleted-list"><li style="list-style-type:circle">可以用<code>using</code>关键字来<span style="border-bottom:0.05em solid"><strong>自定义一些类型</strong></span>（类似于<code>typedef</code>）。<br/>作为<br/><code>typedef</code>的替代，提供了创建类型别名的更现代、更通用的方式。与<code>typedef</code>相比，<code>using</code>语法更加清晰。<ul id="6274af73-d118-44e8-8fdf-25b9ac332f69" class="bulleted-list"><li style="list-style-type:square">例如：<code>using head = int*;</code>（然后就可以<code>head ptr = new int;</code>）</li></ul><ul id="5665bbea-867a-45e9-a3f2-567e20c35420" class="bulleted-list"><li style="list-style-type:square">using还可以对模版类型重命名</li></ul></li></ul><ul id="f4ea261a-6124-40eb-9408-502688020e3f" class="bulleted-list"><li style="list-style-type:circle"><code>using</code><strong> </strong>也可以用来<span style="border-bottom:0.05em solid"><strong>引入命名空间中的特定成员</strong></span>，<span style="border-bottom:0.05em solid"><strong>或者整个命名空间</strong></span>，从而避免在每次引用时都需要使用完整的命名空间限定符。<ul id="a5fe6183-f215-4372-a004-b64ad29e17a3" class="bulleted-list"><li style="list-style-type:square">例如<code>using std::string, std::cout; </code>（现在可以直接使用string和cout，而不需要前面加上std::的前缀）</li></ul></li></ul></li></ul><ul id="aeeff2f1-4f3c-4703-a9d6-73bde686763d" class="bulleted-list"><li style="list-style-type:disc"><em><strong><code>typename</code></strong></em><strong>关键字</strong>：用于指明后面的名称是一个类型<ul id="32fb018d-6b73-418f-bf9e-ed31e46896c4" class="bulleted-list"><li style="list-style-type:circle">case1：模版编程中指定一个变量是一个类型名<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="8714f719-2cb3-4432-adbb-aa6c9d6e793d" class="code"><code class="language-C++">
template&lt;typename U&gt;  // 用于显式地告诉编译器：名字U是一个像类型名称（比如int这样的类型名称）
void myFunction(U param) {
    // ...
}</code></pre></li></ul><ul id="e00c491a-93ac-4e4d-b817-dc927a7497bf" class="bulleted-list"><li style="list-style-type:circle"><a href="https://www.notion.so/C-6e15a78480a542c49efdb2d2c4035a01?pvs=21">case2</a>：引用一个模版类里的自定义类型</li></ul><ul id="f1851894-cc29-44a2-a7cb-adb8f8e9c6d3" class="bulleted-list"><li style="list-style-type:circle"><a href="https://www.notion.so/C-6e15a78480a542c49efdb2d2c4035a01?pvs=21">case3</a>：从迭代器类型中提取出它所指向的元素类型。</li></ul></li></ul><ul id="3ca6ebaa-a786-47e2-9fbc-4c779b48d797" class="bulleted-list"><li style="list-style-type:disc"><strong>作用域解析运算符</strong><em><code>::</code></em>，这个运算符用于以下几种情况<ul id="e01c1732-e7bb-4923-bdde-c220f112d9f0" class="bulleted-list"><li style="list-style-type:circle"><strong>指定命名空间</strong>：用于访问特定命名空间中的类、函数或变量。例如，<code><strong>std::cout</strong></code> 表示访问标准 (<code><strong>std</strong></code>) 命名空间中的 <code><strong>cout</strong></code> 对象</li></ul><ul id="bb2bc5b6-50cb-490b-9e2f-fd8d4e5596f9" class="bulleted-list"><li style="list-style-type:circle"><strong>访问类内定义的类型别名</strong>：如std::vector&lt;int&gt;::iterator（访问std命名空间中vector类内定义的iterator类型名）</li></ul><ul id="cd48d610-659e-4d4b-876f-378312d8505b" class="bulleted-list"><li style="list-style-type:circle"><strong>访问类的静态成员</strong>：当需要在类外部访问类的静态成员（属性或方法）时使用。例如，<code><strong>ClassName::staticMethod()</strong></code></li></ul><ul id="e915aa1f-2363-4c13-ad7f-70e5a01e59cb" class="bulleted-list"><li style="list-style-type:circle">访问<strong>定义类外的成员函数</strong>：在类定义外部定义成员函数时，使用 <code><strong>::</strong></code> 来指定这个函数属于哪个类。例如：<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="15324888-108c-47b4-be92-32284c259bac" class="code"><code class="language-C++">class MyClass {
public:
    void myMethod();
};

void MyClass::myMethod() {
    // 在类的外面进行方法定义
}</code></pre></li></ul><ul id="3911fbd9-2634-44ca-adfb-dfb0c13cbca3" class="bulleted-list"><li style="list-style-type:circle">当<code><strong>::</strong></code><strong>前面没有任何名字时</strong>，它表示访问全局命名空间中的名称（符号），这种用法可以用于很多种场景，例如：<ul id="1851ca69-80ff-4d34-b3bc-6b81733d361e" class="bulleted-list"><li style="list-style-type:square"><strong>访问全局变量</strong>：如果全局变量的名称被局部变量遮蔽，可以使用 <code><strong>::</strong></code> 来访问全局变量。例如，<code><strong>::globalVar</strong></code>。</li></ul><ul id="edde90a6-9a9d-4643-8342-969542dd2ed0" class="bulleted-list"><li style="list-style-type:square">用::来访问外部的一个函数</li></ul></li></ul><ul id="91588c59-adc2-4e82-938f-18e624390477" class="bulleted-list"><li style="list-style-type:circle"><strong>在继承中指定父类的成员</strong>：如果派生类需要访问被遮蔽（或重写）的基类成员，可以使用 <code><strong>::</strong></code>。</li></ul></li></ul><ul id="3e136ea4-c1e8-404c-a7bc-4445e650dfa2" class="bulleted-list"><li style="list-style-type:disc"><em><strong><code>static</code></strong></em>关键字：在 C++ 中，<code><strong>static</strong></code> 关键字是一个多功能的修饰符，可以用于多种不同的上下文中，具有不同的含义。以下是 <code><strong>static</strong></code> 关键字的主要用途：<ul id="5683a2f7-98b1-46c3-9510-cfdf4ccddd77" class="bulleted-list"><li style="list-style-type:circle">定义<span style="border-bottom:0.05em solid"><strong>静态局部变量</strong></span>：在<strong>函数体内部</strong>，<code><strong>static</strong></code> 可用于声明静态局部变量。这种变量与普通局部变量不同，它在第一次初始化后会保持其值，<strong>即使在函数调用结束后也不会被销毁</strong>。在下一次该函数被调用时，静态局部变量将<strong>保持上一次调用结束时的值</strong>。<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="af77dca8-ee2a-4915-9150-874629f6af90" class="code"><code class="language-C++">#include &lt;iostream&gt;

void function() {
    static int count = 0; // 静态局部变量
    count++;
    std::cout &lt;&lt; count &lt;&lt; std::endl;
}


int main() {
	function();  // 输出1
	function();  // 输出2
	function();  // 输出3
}</code></pre></li></ul><ul id="888dd530-5f24-4382-a7be-d232d4b48bed" class="bulleted-list"><li style="list-style-type:circle">定义<span style="border-bottom:0.05em solid"><strong>静态类成员</strong></span>：在类定义中，<code><strong>static</strong></code> 可用于声明静态成员变量或静态成员函数。静态成员属于类本身，而不是类的任何特定对象。这意味着所有对象实例共享同一个静态成员，并且即使没有创建类的实例，静态成员也存在。<ul id="74dafedd-dc63-4786-baad-a7a00bc1c7a6" class="bulleted-list"><li style="list-style-type:square">例如对于<mark class="highlight-purple"><span style="border-bottom:0.05em solid"><strong>始终不会变的成员变量，就可以考虑用static修饰</strong></span></mark></li></ul></li></ul><ul id="4e3780cc-7edd-4052-af1a-128c64293fce" class="bulleted-list"><li style="list-style-type:circle"><span style="border-bottom:0.05em solid"><strong>文件作用域静态全局变量或函数</strong></span><strong><strong>：</strong></strong>在全局或命名空间作用域中，<code><strong>static</strong></code> 用于<strong>限制变量或函数的可见性仅在定义它们的文件内</strong>。这意味着这些变量或函数在其他文件中是不可见的，即使在链接时也不会与其他文件中的同名符号冲突。<ul id="370e56de-4a72-4ed3-b422-fde5d17054c8" class="bulleted-list"><li style="list-style-type:square">注意：是在全局或命名空间作用域中进行static修饰</li></ul></li></ul></li></ul><ul id="075cda81-2433-41e7-b4ad-6d66509e6874" class="bulleted-list"><li style="list-style-type:disc"><em><strong><code>inline</code></strong></em>关键字：用于建议编译器将函数的代码在每个调用点内联展开，而不是执行常规的函数调用。<strong><em>inline</em></strong>主要用于小型函数，目的是减少函数调用的开销，提高程序的运行效率。<br/>尽管<br/><em><strong>inline</strong></em>是一个建议，但最终是否内联取决于编译器的决定。现代编译器通常会自动决定是否内联函数，无论是否使用了<em><strong>inline</strong></em>关键字。<br/>然而，在某些情况下，明确标记函数为<br/><strong><em>inline</em></strong>可以帮助编译器做出更优的决策。<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="4e2e03c9-95f8-4afe-9e9c-64d6b559530f" class="code"><code class="language-C++">inline int max(int a, int b) {
    return (a &gt; b) ? a : b;
}

int main() {
    int result = max(3, 5); // 这里max函数可能会被内联展开
}</code></pre></li></ul><ul id="59eb955d-6fd5-45e1-a238-3d7e12a3d3c3" class="bulleted-list"><li style="list-style-type:disc"><em><strong><code>noexcept</code></strong></em>关键字：常用于类的成员函数中，用于<strong>明确指出一个函数不会抛出异常</strong>，提高代码的可阅读性，同时编译器也会根据这个关键字对程序进行适当优化。但<span style="border-bottom:0.05em solid"><strong>更主要的目的是明确地告诉user，这个函数不会抛出异常<br/><br/></strong></span>⚠️：<em><code>noexcept</code></em>并不禁止在函数内部使用<em><code>try-catch</code></em>，它<span style="border-bottom:0.05em solid"><strong>仅仅保证函数对外部承诺不会抛出异常。如果内部捕获并处理了所有可能的异常，那么这个承诺就得到了满足。<br/><br/></strong></span>⚠️：如果一个<em><code>noexcept</code></em>标记的函数发生了在内部没有被捕获到的异常，<strong>即使用户在这个函数的外部使用了</strong><strong><em><code>try</code></em></strong><strong><em>，</em></strong><strong>程序也会立刻终止</strong>。这也是为什么编译器可以对其作出优化。<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="fa02f239-ab13-41d8-870c-386de9f6b5d4" class="code"><code class="language-C++">void myFunction() noexcept {
    // 函数定义...
}

void myFunction() noexcept(someCondition) {
    // 函数定义...
}</code></pre><ul id="532fee6f-7e8c-4edb-aa60-1a89667aac45" class="bulleted-list"><li style="list-style-type:circle">用法1，使用 <code><strong>noexcept</strong></code> 关键字而不跟任何条件：意味着该函数保证不抛出任何异常。如果这个函数违反了这个承诺并抛出了异常，程序将调用 <code><strong>std::terminate()</strong></code>，通常会导致程序终止。（不会触发任何catch块）</li></ul><ul id="c763d7f7-3738-42b3-9c29-100b14bab419" class="bulleted-list"><li style="list-style-type:circle">用法2，<code><strong>noexcept</strong></code> 后面跟一个布尔表达式：如果表达式为真，则函数承诺不抛出异常；如果为假，则函数可能抛出异常。</li></ul></li></ul><ul id="dd0db529-3378-47fb-9e7a-e48cab20615d" class="bulleted-list"><li style="list-style-type:disc"><strong><em><code>void</code></em></strong>关键字：在C++中，<code><strong>void</strong></code>关键字有以下主要用途：<ol type="1" id="c8182d8d-cfad-41a4-8408-8d4532d14eb8" class="numbered-list" start="1"><li><strong>作为函数返回类型</strong>：当<code><strong>void</strong></code>用作函数的返回类型时，它指定该函数不返回任何值。这是最常见的用法之一，用于那些执行操作但不需要返回值的函数。</li></ol><ol type="1" id="864b8d04-42e9-4f79-b1d8-d062d5af08e7" class="numbered-list" start="2"><li><strong>用于函数参数列表</strong>：当<code><strong>void</strong></code>用于函数的参数列表中，它表明该函数不接受任何参数。<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="c5bb0f2b-4c12-4ad8-9be9-324030101d45" class="code"><code class="language-C++">void doSomething(void) { // 明确表示没有参数，但在C++中通常省略void
    // 函数体
}</code></pre></li></ol><ol type="1" id="2d4e6838-2875-4e81-8f5e-0c306db0c1cb" class="numbered-list" start="3"><li><strong>在指针声明中</strong>：在指针声明中使用<code><strong>void</strong></code>表明该指针是一个通用指针。<code><strong>void</strong></code>指针可以指向任何类型的数据，<span style="border-bottom:0.05em solid"><strong>但在使用之前需要转换为具体的类型指针。</strong></span><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="41dea471-64be-41a8-bdfc-d7e2553d72d3" class="code"><code class="language-C++">void* ptr;
int x = 10;
ptr = &amp;x; // void指针可以指向int类型

// 但是，void指针不能直接解引用，除非它被转换为其他类型的指针。
// void指针可以转换为任何其他类型的数据指针。</code></pre></li></ol><ol type="1" id="9f6d6868-85de-439f-b449-1b725d9aafeb" class="numbered-list" start="4"><li><strong>指向函数的指针</strong>：虽然<code><strong>void</strong></code>指针可以指向任何类型的数据，但它不能直接用来指向类成员函数。在C++中，指向函数的指针需要特定的语法和考虑。</li></ol><ol type="1" id="2e27d2a9-9161-4437-94f1-fce7aca78219" class="numbered-list" start="5"><li>用于避免编译器因为函数参数未被使用而发出的未使用变量警告。将变量名放在<code>(void)</code>表达式中是一种常见的C++（也用于C）技巧，用来明确告诉编译器这个变量故意未被使用。通过这种方式，你可以避免编译器警告干扰，同时保持代码的清晰和整洁。此外，它也是一种向代码阅读者传达“这个变量暂时未被使用但将来可能会用到”的方式。<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="c6d2fa2f-a41f-4394-ab06-1f15f273ec62" class="code"><code class="language-C++">void foo(const string&amp; arg1) {
    (void) arg1;
    throw std::invalid_argument(&quot;Not implemented yet.\n&quot;);
}</code></pre></li></ol></li></ul><ul id="e228477c-357e-45b5-b9ad-999bfaec51c2" class="bulleted-list"><li style="list-style-type:disc"><em><code><strong>decltype</strong></code></em>关键字：用于获取变量、函数或表达式的<span style="border-bottom:0.05em solid"><strong>类型</strong></span>。它在编译时计算表达式的类型，而不评估表达式的值。<span style="border-bottom:0.05em solid"><strong>当需要根据表达式的类型来声明变量或者实例化模版时非常有用</strong></span>。以下是<code><strong>decltype</strong></code>的一些主要用途和示例：<ul id="93ad21cb-f173-4bb2-a48e-a085120eee15" class="bulleted-list"><li style="list-style-type:circle"><strong><strong>获取变量的类型</strong></strong><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="5976aa29-d75b-4cb2-bd05-ff4084de6698" class="code"><code class="language-C++">auto a = 10;
decltype(a) b = 20; // b也是int类型

std::vector&lt;int&gt; v;
decltype(v.begin()) it = v.begin(); // 使用decltype自动确定迭代器类型</code></pre></li></ul><ul id="4cac3817-9ff4-4c31-955b-c8b77fe37693" class="bulleted-list"><li style="list-style-type:circle"><strong><strong>用于模板和泛型编程</strong></strong><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="82dd392d-1d87-4fda-a0bf-6e6f827777cd" class="code"><code class="language-C++">template&lt;typename T&gt;
auto add(T x, T y) -&gt; decltype(x + y) {
    return x + y;
}</code></pre></li></ul><ul id="fdbad332-b5c4-4aee-9a7f-65479ec9785a" class="bulleted-list"><li style="list-style-type:circle"><strong>结合lambda表达式</strong>使用：有些模版需要传入一个函数类型，而通过decltype可以得到一个函数的唯一类型，从而用于模版的实例化。<blockquote id="5a91cf63-256f-4ebe-9c64-9e492446c1cd" class="block-color-gray_background"><strong>在C++中，每个lambda表达式都有其独特的类型，尽管我们不能直接命名它</strong>。</blockquote><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="23fc0be8-9b35-48ab-882e-ce935f2c97e8" class="code"><code class="language-C++">// Using lambda to compare elements.
auto cmp = [](int left, int right) { return (left ^ 1) &lt; (right ^ 1); };
std::priority_queue&lt;int, std::vector&lt;int&gt;, decltype(cmp)&gt; q5(cmp);</code></pre></li></ul></li></ul><div><ul id="d91ccd91-32e1-49b7-a741-24a561d7c636" class="bulleted-list"><li style="list-style-type:disc"><em><strong><code>this</code></strong></em><em><strong>指针</strong></em>：在定义C++类的成员方法时，<span style="border-bottom:0.05em solid"><strong>默认会传入一个名叫</strong></span><code><strong>this</strong></code><strong>的</strong><mark class="highlight-purple"><span style="border-bottom:0.05em solid"><strong>指针</strong></span></mark>（并不需要显示指出），用于<strong>指向当前的对象</strong>（就像python中的<code>self</code>一样，只不过python中是显式定义的）。通过this指针，可以方针当前对象的成员变量和成员函数</li></ul></div><h3 id="f6121460-8118-44eb-8447-d97ccad6c148" class="block-color-blue_background">迭代器的value_types</h3><ul id="20b2eafd-fcbb-4194-92e0-8dfbb592e227" class="bulleted-list"><li style="list-style-type:disc"><code>std::iterator_traits&lt;it_type&gt;::value_types</code>：提供了一种方法可以<strong>从一个迭代器类型中提取出它所指向的元素类型</strong>，返回的是一个类型名称（因此通常会用<code>typename</code>对返回的类型名进行修饰，然后用<code>using</code>给它取一个类型别名）<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="b532f7ca-cacb-4bb1-89d1-978aae8fdff6" class="code"><code class="language-C++">//例如：
using ElementType = typename std::iterator_traits&lt;int*&gt;::value_type;
// value_type是模版结构体iterator_traits的一个类型别名（其实是一个typedef定义的类型）</code></pre><ul id="8fb5d09f-3f7d-4643-a072-fc5b626e2976" class="bulleted-list"><li style="list-style-type:circle">常用于当某个模版类型是一个iterator，而又想知道这个iterator所指向的元素的类型时<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="3bd0d7ca-ac6c-4546-b76a-beb6294d54c2" class="code"><code class="language-C++">template&lt;typename it_type, typename val_type&gt;
class MyClass {
public:
    using ElementType = typename std::iterator_traits&lt;it_type&gt;::value_type;

    // 使用 ElementType 作为元素类型
    // ...
};</code></pre></li></ul><blockquote id="c3aae093-8943-429c-821e-fb02e95fbb16" class="block-color-gray_background">每一个容器类（如<code>vector</code>等）里面都定义了一个名叫<strong><code>value_type</code></strong>的类型别名，这个类型别名指示了这个容器中的元素的数据类型；<br/>每一个可迭代容器类里面也都定义了一个名叫<br/><strong><code>iterator</code></strong>的类型别名，指示了这个容器用的迭代器的数据类型。</blockquote></li></ul><h3 id="c4a44104-b34d-4ad8-a9c0-18c95acdb354" class="block-color-blue_background">函数指针：<strong>std::function&lt;返回类型(参数类型)&gt;</strong></h3><ul id="f64a6f7d-bd28-4a4b-8acf-4128af89ddb7" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>函数指针</strong></span>：C++11中引入了<strong><code>std::function&lt;返回类型(参数类型)&gt;</code></strong>类型来定义一个函数指针（需要<strong><code>#include &lt;functional&gt;</code></strong>）<ul id="c08a1b18-e25b-4bf6-b717-2cec0f189adf" class="bulleted-list"><li style="list-style-type:circle">case1<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="da983f3c-1262-4943-b602-834c379df3b8" class="code"><code class="language-C++">#include &lt;iostream&gt;
#include &lt;functional&gt;

int add(int a, int b) {
    return a + b;
}

double multiply(double a, double b) {
    return a * b;
}

void performOperation(int a, int b, const std::function&lt;int(int, int)&gt;&amp; operation) {
    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; operation(a, b) &lt;&lt; std::endl;
}

int main() {
    // 使用 std::function 存储指向函数的指针
    std::function&lt;int(int, int)&gt; func1 = add;

    std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; func1(10, 20) &lt;&lt; std::endl;
		performOperation(5, 7, add);
		
		
    return 0;
}</code></pre></li></ul></li></ul><h3 id="df4cdb1b-86f4-45c4-83a8-dd0827f2b6f1" class="block-color-blue_background">谓词函数</h3><ul id="d85bee61-eb9d-4788-93de-8fddf3890e2f" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>谓词函数</strong></span>（Predicate function）：这种返回一个布尔值（<code><strong>true</strong></code> 或 <code><strong>false</strong></code>），用于表示某个条件是否被满足。谓词函数通常用作算法的参数，尤其是在标准模板库（STL）的算法中，如排序、搜索、检查等操作。<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="9b9880e8-f333-47b4-bdb0-5e46c5068949" class="code"><code class="language-C++">// 作为函数指针
bool isEven(int x) {
    return x % 2 == 0;
}

// 作为lambda表达式
auto isPositive = [](int x) { return x &gt; 0; };</code></pre></li></ul><h3 id="2c7dafcc-9f3b-4857-9cae-19298a0b4cff" class="block-color-blue_background">C++17：if语句中允许加入初始化语句</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="f68e8e39-0272-48cd-a519-43a8c8cfa85c" class="code"><code class="language-C++">std::vector&lt;int&gt; v = {1, 2, 3, 4, 5};
if (auto it = std::ranges::find(v, 3); it != v.end()) {
    std::cout &lt;&lt; &quot;Found: &quot; &lt;&lt; *it &lt;&lt; &quot;\n&quot;;
}</code></pre><h2 id="d828a842-7413-4b24-b3b7-045e55f9ca74" class="block-color-orange_background">左值l-value、右值r-value（临时变量）</h2><ul id="6ce67e0d-8757-4ec0-a049-56199556635d" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-purple"><span style="border-bottom:0.05em solid"><strong>左值l-value与右值r-value</strong></span></mark><figure id="ce7cd776-3c70-4f88-955c-36da1561e70b" class="image" style="text-align:left"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-01-19_22.53.44.png"><img style="width:432px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-01-19_22.53.44.png"/></a><figcaption>L-values live until the end of the scope<br/>R-values live until <br/><span style="border-bottom:0.05em solid"><strong>the end of the line<br/><br/></strong></span>左值是指那些具有持久状态的对象或者可以取地址的表达式<br/>右值是指那些不具有持久状态的临时对象或者不可以取地址的表达式，例如字面量、临时对象、返回非引用类型的函数调用结果等。<br/></figcaption></figure><ul id="4715ea18-46b6-4e0b-9a26-737948edf949" class="bulleted-list"><li style="list-style-type:circle">左值能放在等式<span style="border-bottom:0.05em solid"><strong>左边和右边</strong></span>；右值只能放在等式<span style="border-bottom:0.05em solid"><strong>右边</strong></span><figure id="73357b99-9bee-4a3d-ad58-c74643b45d3d" class="image"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-01-19_22.57.15.png"><img style="width:480px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-01-19_22.57.15.png"/></a></figure></li></ul><ul id="2370679c-870a-4405-8238-c059852a116d" class="bulleted-list"><li style="list-style-type:circle">所以，在函数声明中，<span style="border-bottom:0.05em solid"><strong>被&amp;修饰的参数/返回值也被称为</strong></span><mark class="highlight-purple"><span style="border-bottom:0.05em solid"><strong>左值引用</strong></span></mark>，因为实参/返回值必须是左值<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="1df6a946-cf1f-4ddb-a6be-1614a71b3b4d" class="code"><code class="language-C++">void foo(int&amp; x) {
    // ...
}

int a = 10;
foo(a); // 正确：a是左值
// foo(5); // 错误：5是右值，不能传递给左值引用</code></pre></li></ul><ul id="fb3b50e5-6a92-4dc1-8e32-c76640c9c8c9" class="bulleted-list"><li style="list-style-type:circle">同理，<span style="border-bottom:0.05em solid"><strong>被&amp;&amp;修饰的参数也被称为</strong></span><span style="border-bottom:0.05em solid"><mark class="highlight-purple"><strong>右值引用</strong></mark></span>，因为它们传入的实参/返回值必须是右值<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="43fcfe00-b441-446e-b4b7-877eca79101d" class="code"><code class="language-C++">void bar(int&amp;&amp; x) {
    // ...
}

bar(5); // 正确：5是右值，可以传递给右值引用
// int b = 10;
// bar(b); // 错误：b是左值，不能传递给右值引用</code></pre></li></ul></li></ul><ul id="33aa8d36-c6bb-4307-80bf-7e97dbc6e48a" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>临时变量（右值，R-value）</strong></span>：在C++中，临时对象通常是指那些没有明确名称的对象。这些对象是在表达式求值的过程中创建的，并且它们的生命周期通常很短，一般在表达式结束时就销毁。与之对应的是<span style="border-bottom:0.05em solid"><strong>左值</strong></span>（<strong>L-value</strong>），它表示一个持久的、有明确存储位置的对象。</li></ul><ul id="b40a15cd-363b-4997-b450-08bef49c7d99" class="bulleted-list"><li style="list-style-type:disc">右值的一些例子：<ul id="576b3221-0397-4245-8aca-488a10b3821d" class="bulleted-list"><li style="list-style-type:circle"><span style="border-bottom:0.05em solid"><strong>字面值和临时对象</strong></span>：例如，<code><strong>5</strong></code>、<code><strong>3.14</strong></code>或<code><strong>std::string(&quot;hello&quot;)</strong></code>都是右值。这些都是临时值，不能被赋值。</li></ul><ul id="8ea554a3-deb0-4e5f-937b-c1c448a9de02" class="bulleted-list"><li style="list-style-type:circle"><span style="border-bottom:0.05em solid"><strong>返回非引用类型的函数调用</strong></span>：如果一个函数返回一个非引用类型（比如一个普通对象），那么这个函数调用的结果是一个右值。例如，<code><strong>std::string()</strong></code>返回一个临时的<code><strong>std::string</strong></code>对象。</li></ul><ul id="93cc041d-e422-4060-b028-cce8a4dd581b" class="bulleted-list"><li style="list-style-type:circle"><strong>不能取地址的表达式</strong>：如果无法对表达式取地址，则该表达式可能是右值。例如，不能对字面值或临时对象取地址。</li></ul><ul id="7c10905d-8b0a-479a-a8d4-8b3699b9b971" class="bulleted-list"><li style="list-style-type:circle"><strong>赋值和标识符</strong>：通常，左值（lvalue）可以出现在赋值表达式的左侧，而右值不能。任何具有标识符的表达式（例如变量名）通常是左值。</li></ul></li></ul><ul id="bceaa53e-966c-4d12-a4eb-2f0c3654869a" class="bulleted-list"><li style="list-style-type:disc">在C++中，通过<strong><code>&amp;&amp;</code></strong>关键字可以修饰一个右值，例如<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="8c6f9be9-f7d9-49a5-8f99-726fcb116e1a" class="code"><code class="language-C++">void myFunction(int&amp;&amp; num) {
    // ...
}</code></pre><ul id="bba40345-67db-4632-96a9-dd46fcd392b0" class="bulleted-list"><li style="list-style-type:circle">在这个例子中，<code><strong>int&amp;&amp; num</strong></code>是一个右值引用参数。它只能绑定到右值上。这意味着你不能将一个左值传递给<code><strong>myFunction</strong></code>，但可以传递一个临时值或返回值。</li></ul></li></ul><ul id="ccae6394-9b0a-43c7-8ce5-462409e40150" class="bulleted-list"><li style="list-style-type:disc"><strong>当要把一个右值复制给另一个对象时，copy by value是一种非常慢的做法</strong>（尤其是当这个右值非常大的时候）。<br/>由于右值是一个临时的值，在之后就不再会被使用，<br/><strong>当被复制的对象是一个右值时，更好的做法是直接接管右值对象对应的指针</strong>（即：将新对象的指针设置为这个右值，然后将右值的指针置null，而不是拷贝它的值），这样可以避免额外的复制带来的开销。</li></ul><ul id="9bc323dc-c7af-4eeb-a918-c1f5a91ffadf" class="bulleted-list"><li style="list-style-type:disc">在C++11中引入了<span style="border-bottom:0.05em solid"><strong>移动语义</strong></span>，当<code>=</code>右侧是一个右值时，就会触发<span style="border-bottom:0.05em solid"><strong>移动语义</strong></span>，调用左值对应的<a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">移动拷贝构造函数（或移动赋值运算符）</a><blockquote id="b9642366-a4b0-44d8-b4c8-d8af181fe747" class="block-color-gray_background">拷贝构造函数或赋值运算符，相较于它们的移动语义版本（即右值传入），多了申请内存，copy by value两个操作，当这个资源很大时，这两个操作时间开销都非常大。</blockquote></li></ul><ul id="6945a936-88cd-4060-9e88-f595242fe66b" class="bulleted-list"><li style="list-style-type:disc"><code><strong>std::move</strong></code>：<code><strong>std::move</strong></code>可以将一个左值转换为右值<ul id="8e52cad3-5e9a-478a-aa8a-14085947391b" class="bulleted-list"><li style="list-style-type:circle">当你调用 <code><strong>std::move</strong></code> 时，你实际上是告诉编译器：“即使这个对象是一个左值，我也知道<strong>它接下来不会再被使用</strong>，所以你<strong>可以把它当作右值来处理</strong>。“ 这<strong>允许编译器使用移动语义</strong>，而不是<strong>复制语义</strong>，来操作该对象。</li></ul><ul id="81e32d6f-2558-4e3f-b7f9-ca8d64ada5b2" class="bulleted-list"><li style="list-style-type:circle">You should use this <em><span style="border-bottom:0.05em solid"><strong>when you’re assigning some l-value that is no longer needed</strong></span></em> where it is previously stored</li></ul><ul id="deb87f1e-3e59-4c37-b2ba-e0488e87fa37" class="bulleted-list"><li style="list-style-type:circle">avoid using std::move() in application code. <strong><em><span style="border-bottom:0.05em solid">Use it in class definitions, like constructors and operators.</span></em></strong><figure id="acb670d8-9370-40de-be83-76d3a1d4ae64" class="image" style="text-align:center"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-01-20_13.06.21.png"><img style="width:480px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-01-20_13.06.21.png"/></a></figure></li></ul></li></ul><ul id="2948c5bd-8019-48f8-a574-34ba4d29367a" class="bulleted-list"><li style="list-style-type:disc"><code><strong>decltype</strong></code><strong>和</strong><code><strong>std::is_rvalue_reference</strong></code>：在C++11及以后的版本中，可以用<code><strong>decltype</strong></code>来获取表达式的类型，并结合<code><strong>std::is_rvalue_reference</strong></code>来判断是否为右值引用。</li></ul><ul id="85eb72db-106e-458c-878b-67304e43939b" class="bulleted-list"><li style="list-style-type:disc"><strong>一个case</strong>：<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="4ff12439-b280-463e-869e-85862d3d06dd" class="code"><code class="language-C++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;utility&gt; // for std::move

int main() {
    std::vector&lt;int&gt; vec1 = {1, 2, 3, 4, 5}; 
		// 初始向量{1, 2, 3, 4, 5}是右值，vec1是左值


    std::vector&lt;int&gt; vec2 = std::move(vec1);
		// 通过move将vec1转化为右值，从而触发vec2的移动语义，进而调用vec2的移动拷贝构造函数
		// 通常这个移动拷贝构造函数就是将vec2的指针复制为vec1，将vec1的指针置为nullptr
    // （因为vec1是一个右值，之后不会被用到，所以要把vec1的指针置null）
    // 因此不会发生实际的复制，只是转移了资源的“所有权”

    std::cout &lt;&lt; &quot;vec1 size: &quot; &lt;&lt; vec1.size() &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;vec2 size: &quot; &lt;&lt; vec2.size() &lt;&lt; std::endl;
    return 0;
}</code></pre><ul id="00e5eced-b861-4f56-a269-a71dc7010bfc" class="bulleted-list"><li style="list-style-type:circle">如果不通过<code>move</code>将<code>vec1</code>转化为一个右值，那么<code>std::vector&lt;int&gt; vec2=vec1</code>会触发<code>vec2</code>的<a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">拷贝构造函数</a>，先为<code>vec2</code>分配内存，再将<code>vec1</code>的内容从它的内存中复制到<code>vec2</code>的内存里（但实际上<code>vec1</code>在之后不再被使用，是一个右值，所以更好的做法应该是直接把<code>vec2</code>的指针置为<code>vec1</code>的指针，然后<code>vec1</code>置为null）。<br/>在这种方式下发生了<br/><strong>1次内存分配</strong>，<strong>1次复制操作</strong>。<p id="11ffd029-9f27-4fcb-a987-fd4620f2c2da" class="">所以如果通过<code>move</code>将<code>vec1</code>转化为一个右值（显式地告诉编译器这是一个右值），那么<code>std::vector&lt;int&gt; vec2=vec1</code>就是一个移动语义，从而触发<code>vec2</code>的<a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">移动拷贝构造函数</a>。移动拷贝构造函数只会将<code>vec2</code>的指针指向<code>vec1</code>，然后将<code>vec1</code>的指针置<code>null</code>（因为<code>vec1</code>在之后不再被使用到）。在这种方式下发生了<strong>0次内存分配</strong>，<strong>0次复制操作</strong>。</p></li></ul></li></ul><ul id="f5ece721-01cb-4dbe-8ca5-bce452d71acb" class="bulleted-list"><li style="list-style-type:disc">理解右值通常对于深入理解C++的内存管理和优化非常重要，尤其是在涉及移动语义和右值引用的上下文中。</li></ul><h2 id="21aacca8-f44a-493a-bc63-16c0750f2a82" class="block-color-orange_background">const关键字</h2><h3 id="a353f27f-0018-4e53-ae2d-6208dd7dbfa6" class="block-color-blue_background">const的基本用法、</h3><ul id="c87fc039-e3db-4a18-acc0-5a980acfb957" class="bulleted-list"><li style="list-style-type:disc"><code>const</code>修饰一个变量时表示这个变量不允许被改变</li></ul><ul id="3ce30579-2175-4b0a-b514-8778f68799a1" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-red"><strong><code>const</code></strong></mark><mark class="highlight-red"><strong>修饰指针时</strong></mark>：<ul id="0abd22c0-c132-40bd-b335-77d019c54e42" class="bulleted-list"><li style="list-style-type:circle"><code>const int* ptr</code>：ptr<strong>指向的内容不可修改</strong>，但是ptr<strong>本身可以修改</strong><ul id="da0c709b-25cc-4138-a58d-934d3e712df3" class="bulleted-list"><li style="list-style-type:square">即ptr是一个<mark class="highlight-purple"><strong>指向常量的指针</strong></mark>（指向一个const int）</li></ul></li></ul><ul id="b4e8f9c7-c18b-4c3f-9034-cd48a42b0c7e" class="bulleted-list"><li style="list-style-type:circle"><code>int* const ptr</code>：ptr本身不可以修改，指向的内容可以修改<ul id="a7e2f5fa-c5ab-4b28-abb2-e5cc69dc8d73" class="bulleted-list"><li style="list-style-type:square">此时ptr就是一个指向变量的常量指针</li></ul></li></ul><ul id="ef85a483-cea0-4594-b56f-446c11da8310" class="bulleted-list"><li style="list-style-type:circle"><code>const int* const ptr</code>：都不可以修改<ul id="c9df972d-405e-4fde-946d-84a43dfa46da" class="bulleted-list"><li style="list-style-type:square">此时ptr是一个指向常量的常量指针</li></ul></li></ul></li></ul><ul id="7387c266-39f7-4c56-991e-feb743a21e8e" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-default">通常</mark><span style="border-bottom:0.05em solid"><strong><mark class="highlight-red">const都是搭配引用&amp;来一起使用</mark></strong></span><mark class="highlight-default">，构成</mark><span style="border-bottom:0.05em solid"><mark class="highlight-red"><strong>常量引用</strong></mark></span></li></ul><ul id="5ce99ce1-5339-473f-8b6a-05c2a8f734b4" class="bulleted-list"><li style="list-style-type:disc">非const变量可以隐式地转化为const变量，<strong>但是const变量不能被转化为非const变量</strong></li></ul><h3 id="3b443e0d-17d6-474d-8db8-3bd6e91138b1" class="block-color-blue_background">常量引用const  + &amp; ：使用常量引用修饰函数参数和返回值</h3><ul id="ecb0dce3-16ff-44de-9512-207a5d9be49c" class="bulleted-list"><li style="list-style-type:disc"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">引用&amp;的用法</a></li></ul><ul id="4491705a-5bc7-41a7-b38e-32a8fd401f39" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-purple"><span style="border-bottom:0.05em solid"><strong>常量引用修饰函数参数</strong></span></mark>：在函数中使用<code>const</code>加上<code>&amp;</code>（const+&amp;也叫做<mark class="highlight-red"><span style="border-bottom:0.05em solid"><strong>常量引用</strong></span></mark>）来修饰一个参数时，<span style="border-bottom:0.05em solid"><strong>表示传参时不会进行copy，同时也保证了被调用函数不会对这个引用进行修改<br/><br/></strong></span>（这是一个<strong>good practice</strong>）<ul id="29a5704a-ce45-41dc-ace0-a529b972ee44" class="bulleted-list"><li style="list-style-type:circle">因此使用常量引用修饰函数参数时，允许传入的参数直接是一个常量（比如“xxxx”）</li></ul><ul id="9753f5bc-ad30-4c21-9743-a0d73bef89d4" class="bulleted-list"><li style="list-style-type:circle">常量引用在C++中<strong>用的非常多</strong>（因为性能比较好）</li></ul></li></ul><ul id="87c2290a-7bbf-417f-a937-9f84df775c4a" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-purple"><span style="border-bottom:0.05em solid"><strong>常量引用修饰函数返回值</strong></span></mark>：当函数的返回值是非引用时（也就是会返回一个新的变量），此时加const修饰就没有什么意义（因为返回的是一个临时副本，这个副本在函数返回后就成为了调用者的财产。调用者可以自由地决定如何使用这个副本，包括修改它。因此，在这种情况下，<code><strong>const</strong></code> 并不会对调用者产生任何实际的约束）<ul id="2bcbc3e6-55cd-4790-81ed-b4c11a855471" class="bulleted-list"><li style="list-style-type:circle">因此使用常量引用来修饰函数返回值后，<span style="border-bottom:0.05em solid"><strong>即不会发生返回值的copy，同时也要求调用者不会对这个引用进行修改</strong></span></li></ul><ul id="ac2d8856-28e6-46d9-9b50-c557afb51af8" class="bulleted-list"><li style="list-style-type:circle">使用常量引用修饰函数返回值后，不需要在函数的return后面再用const进行修饰</li></ul></li></ul><h3 id="3c87c0cf-469e-4de4-849e-1ed1574c9233" class="block-color-blue_background">const只有修饰引用(常量引用)和指针(指向常量的指针)才有意义</h3><ul id="d8229ce4-7dc5-48b9-bfb0-c6eb6ed071dd" class="bulleted-list"><li style="list-style-type:disc">假如参数或者返回值是<strong>按值传递的</strong>，此时用const修饰也没有意义，因为返回的是一个临时副本，这个副本在函数返回后就成为了调用者的财产。调用者可以自由地决定如何使用这个副本，包括修改它。因此，在这种情况下，<code><strong>const</strong></code> 并不会对调用者产生任何实际的约束</li></ul><h3 id="297a58de-0d34-4370-a6a7-f53127e0c910" class="block-color-blue_background">注意点：当一起使用auto、const、&amp;时</h3><ul id="fa07703d-b933-4ef5-b062-725a4f7401fc" class="bulleted-list"><li style="list-style-type:disc"><code><span style="border-bottom:0.05em solid"><strong>auto</strong></span></code><span style="border-bottom:0.05em solid"><strong>与</strong></span><code><span style="border-bottom:0.05em solid"><strong>const</strong></span></code><span style="border-bottom:0.05em solid"><strong>与</strong></span><code><span style="border-bottom:0.05em solid"><strong>&amp;</strong></span></code>：当使用<strong><code>auto</code></strong>类型时要注意<code>const</code>与<code>&amp;</code>的场景，比如<ul id="bf3f5427-ec67-4713-97e0-65e75145cc1c" class="bulleted-list"><li style="list-style-type:circle"><span style="border-bottom:0.05em solid"><strong>丢弃</strong></span><strong><code>const</code></strong><span style="border-bottom:0.05em solid"><strong>和</strong></span><strong><code>&amp;</code></strong>：当使用 <code>auto</code> 时，如果赋给 <code>auto</code> 变量的表达式是一个 <code>const</code> 类型或一个引用类型（例如<code>const int&amp;</code>），<code>auto</code> 会默认忽略<code>const</code><strong> </strong>和 <code>&amp;</code> 部分，<span style="border-bottom:0.05em solid">只推断出基础类型</span>（在这个例子中为<code>int</code>）。<span style="border-bottom:0.05em solid"><strong>这意味着</strong></span><span style="border-bottom:0.05em solid"><strong><code>auto</code></strong></span><span style="border-bottom:0.05em solid"><strong>变量不会保持原始变量的</strong></span><span style="border-bottom:0.05em solid"><code><strong>const</strong></code></span><span style="border-bottom:0.05em solid"><strong>属性或引用性质。</strong></span></li></ul><ul id="89c4759a-a990-4de9-a80e-bfa0fe2fdef0" class="bulleted-list"><li style="list-style-type:circle"><strong><span style="border-bottom:0.05em solid">明确指定&amp;或const</span></strong>：因此，如果希望<code>auto</code>变量保持原始变量的<code>const</code>属性或作为引用，<span style="border-bottom:0.05em solid"><strong>需要显式指定</strong></span>。例如，如果想要<code>auto</code>变量保持<code>const</code>属性，应该使用<code>const auto</code>，对于引用则应使用<code>auto&amp;</code>。</li></ul></li></ul><h3 id="5e404930-0288-4555-91d1-d66a843e5dde" class="block-color-blue_background">const接口(const修饰的类成员函数)：const接口中的this常量指针、宽松const接口、严格const接口</h3><ul id="03461cbc-4db7-4e70-a503-bf6b3def11f8" class="bulleted-list"><li style="list-style-type:disc">当<mark class="highlight-red"><strong>用</strong></mark><mark class="highlight-red"><strong><code>const</code></strong></mark><mark class="highlight-red"><strong>修饰一个类成员函数</strong></mark>时，表示这个成员方法不会修改对象的状态，此时<strong>这个类成员函数就被称为是一个const接口</strong></li></ul><ul id="d0c71c2e-a047-421e-933e-b89650c1f9ab" class="bulleted-list"><li style="list-style-type:disc">当成员函数没有用const修饰时，调用这个成员函数时，传入成员函数的<em><code>this</code></em>指针的类型是一个<strong>指向非常量的常量指针</strong>（<code><em><strong>类型名* const this</strong></em></code>）；当用const修饰后，传入的this指针的类型是一个<strong>指向常量的常量指针</strong>（<code><em><strong>const 类型名* const this</strong></em></code>）<blockquote id="d2a8ca14-b609-47b7-bfb8-2c8b606ec75b" class="block-color-gray_background">因此一个const对象不能调用非const成员函数，因为调用时，const对象本身是一个<code><em><strong>const 类型名* const this</strong></em></code>，而调用非const成员函数时，传入的this类型要求是<code><em><strong>类型名* const this</strong></em></code>，所以就会发生const到非const的转换，从而编译器会发生如下报错：<br/><br/>passing ‘const HashMap&lt;int, int&gt;’ as ‘this’ argument <br/><span style="border-bottom:0.05em solid"><strong>discards qualifiers<br/><br/></strong></span>（因为此时this参数的声明是一个指向非const变量的指针，想要把const对象传进去就必须要丢弃const限定符）</blockquote></li></ul><ul id="77b84546-2e32-4802-a42b-360f7daefca5" class="bulleted-list"><li style="list-style-type:disc"><strong><mark class="highlight-default">⚠️一个坑点⚠️</mark></strong><mark class="highlight-default">：</mark><strong><mark class="highlight-red">在</mark></strong><strong><mark class="highlight-red"><em><code>const</code></em></mark></strong><strong><mark class="highlight-red">成员函数中，</mark></strong><strong><mark class="highlight-red"><em><code>this</code></em></mark></strong><mark class="highlight-red"><strong>指针是一个指向常量的常量指针</strong></mark><mark class="highlight-red">(</mark><code><mark class="highlight-red"><strong>const 类型名* const this</strong></mark></code><mark class="highlight-red">)</mark><strong><br/>因此<br/></strong><mark class="highlight-default"><strong>当在一个被标记为</strong></mark><mark class="highlight-default"><strong><em><code>const</code></em></strong></mark><mark class="highlight-default"><strong>的成员函数中获取一个非</strong></mark><mark class="highlight-default"><strong><em><code>const</code></em></strong></mark><mark class="highlight-default"><strong>成员变量时</strong></mark><mark class="highlight-purple">，</mark><strong><mark class="highlight-purple">这个成员变量会被视为</mark></strong><em><strong><mark class="highlight-purple"><code>const</code></mark></strong></em><strong><mark class="highlight-purple">，</mark></strong><span style="border-bottom:0.05em solid"><strong><mark class="highlight-purple">即使它原本没有被声明为</mark></strong></span><span style="border-bottom:0.05em solid"><em><strong><mark class="highlight-purple"><code>const</code></mark></strong></em></span><blockquote id="8629746a-2251-4874-8e81-4bfe3b72a9d6" class="block-color-gray_background"><strong>因为在成员函数中获取成员变量时，本质上是通过</strong><em><code><strong>this</strong></code></em><strong>指针获取的</strong>(编译器自动在前面加了一个this→，就像python中必须显示地使用self.x来获取一样)，但由于<em><code>this</code></em>指针是一个指向常量的指针，<strong>因此通过</strong><strong><em><code>this</code></em></strong><strong>指针获取成员变量时，取出来的成员变量都具有</strong><strong><em><code>const</code></em></strong><strong>属性</strong>（不管原先它有没有用const进行修饰）</blockquote><ul id="94917b00-ff7f-40cd-8cdc-9e7cb22f562a" class="bulleted-list"><li style="list-style-type:circle">这个细节可能会导致<mark class="highlight-purple"><span style="border-bottom:0.05em solid"><strong>一个经常出现的bug</strong></span></mark>：在一个const接口中，取出了一个原本是非const的成员变量，然后把这个成员变量传给了一个接收非const类型参数的函数，<em>从而发生了const类型到非const类型的隐式转换</em>，触发编译错误<blockquote id="aafb26c8-ef43-42f6-b1a2-749770c964c7" class="block-color-gray_background">解决方法：通过<a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html"><strong><em><code>const_cast</code></em></strong></a>把这个非const的成员函数重新从const转成非const</blockquote></li></ul></li></ul><ul id="42e0d5c6-89ef-445a-a9ba-9f0ad4cc3e98" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-red"><em><span style="border-bottom:0.05em solid"><strong>const inference</strong></span></em></mark>（const接口）: <strong>被const修饰的对象只能调用const函数</strong>（即那些不会修改对象状态的成员函数，也即那些被const修饰的成员函数），例如以下场景<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="a263129b-bbe8-4776-bcb1-d43d142eff99" class="code"><code class="language-C++">class Student {
private:
	// An example of type aliasing
	using String = std::string;
	String name;
	String state;
	int age;

public:
	Student(String name, String state, int age);
	// Added a ‘setter’ function
	void setName(String name);
	String getName();
	String getState();
	int getAge();
	String stringify(const Student&amp; s)
}

/* 
当stringify的定义如下时：
std::string stringify(const Student&amp; s){
	return s.getName() + &quot; is &quot; + std::to_string(s.getAge()) +
	&quot; years old.&quot; ;
}
编译器会报错。
原因：
	s被修饰为const，但编译器不知道s的类方法getName()和getAge()是否会改变s的状态，所以产生编译错误。
修改方法：
	将类定义中的类方法getName()和getState()用const进行修饰，或者给它们另写一个const版本表示这个类方法不会改变对象的状态，即：

String getName() -&gt; String getName() const
int getAge() -&gt; int getAge() const
*/
</code></pre><ul id="3a272a42-f2c7-4129-b11c-6430e325e2f1" class="bulleted-list"><li style="list-style-type:circle">例如某个参数用const进行修饰并传递给了函数，那么在这个函数中就只能调用const修饰的成员函数，否则编译器会报错</li></ul><ul id="11a76ab9-932e-4471-b6d1-c86bae264a72" class="bulleted-list"><li style="list-style-type:circle"><span style="border-bottom:0.05em solid"><strong>因此经常需要给某个非const的类成员函数重新写一个const版本的</strong></span>，这样在调用时编译器会自己<strong>根据是否是const对象，来选择调用const还是非const版本的类成员方法</strong></li></ul></li></ul><ul id="52ec5119-704a-416b-9896-86d7e0ce4dbe" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-red"><strong>实现const接口的一个易错点</strong></mark>：注意区分<mark class="highlight-purple"><strong>严格的const接口</strong></mark>与<mark class="highlight-purple"><strong>宽松的const接口</strong></mark><ul id="6599b515-5da6-4416-90c3-2de092a20860" class="bulleted-list"><li style="list-style-type:circle">当实现一个const接口时，有时候这个const接口本身并不会修改对象状态（例如begin和end），但是这个const接口的返回值可能会使得用户对这个对象进行<strong>间接修改</strong>（例如begin返回一个iterator）。</li></ul><ul id="69ae3b81-ba49-4fcd-a572-822b6e9a544d" class="bulleted-list"><li style="list-style-type:circle"><mark class="highlight-red"><span style="border-bottom:0.05em solid"><strong>宽松的const接口</strong></span></mark>：如果允许间接修改，那就是一个宽松的const接口<ul id="eca1de16-417f-4014-8a53-d3a810711340" class="bulleted-list"><li style="list-style-type:square">宽松的const接口想要强调的是：成员函数本身不会修改对象状态，但返回值可以。</li></ul></li></ul><ul id="9580f5a6-1cf7-420f-b6e7-815370c798d1" class="bulleted-list"><li style="list-style-type:circle"><mark class="highlight-red"><span style="border-bottom:0.05em solid"><strong>严格的const接口</strong></span></mark>：如果不允许间接修改，那就是一个严格的const接口</li></ul><ul id="e920b953-08a8-45af-a3b6-6b60ef2725a4" class="bulleted-list"><li style="list-style-type:circle"><mark class="highlight-purple"><strong>所以实现const接口时，一定要注意想要设计的是一个严格的还是宽松的</strong></mark><mark class="highlight-purple"><span style="border-bottom:0.05em solid"><strong>const接口</strong></span></mark><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="b2c0d8bb-070f-4d0d-b141-3ebb1ad48335" class="code"><code class="language-C++">/* 第一种情况：设计一个宽松的const接口
 * 显示地强调make_iterator本身是const的，但是会返回一个可以修改对象状态的返回值 
 */
iterator make_iterator(node* curr) const;


/* 第二种情况：设计一个严格的const接口 */
iterator make_iterator(node* curr); // 注意，这里不能在最后加const，因为编译器
                                    // 无法根据返回值的类型进行重载 
const_iterator make_iterator(node* curr) const;</code></pre></li></ul><p id="17cef411-bfb5-4c80-bf90-a6c456a7be6c" class="">
</p><blockquote id="007b00b0-df8c-4626-9ad1-d10b063569f1" class="block-color-gray_background">这个原则对于其它类型的函数也是同理</blockquote><blockquote id="ca0be83d-721a-47cf-851b-a1a891c355c6" class="block-color-gray_background">因此，还有一种情况就是：<span style="border-bottom:0.05em solid"><strong>一个非const接口返回一个const返回值</strong></span>，即函数本身会修改对象状态，但是返回值不允许修改<figure id="5f53c98e-d46b-49a9-be09-e156337eb961" class="image"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-02-18_16.11.10.png"><img style="width:432px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-02-18_16.11.10.png"/></a><figcaption>这里的erase返回删去pos后，下一个的位置<br/>注意：定义了一个const_iterator erase后，就不能再定义一个iterator erase，因为<br/><strong>无法仅根据返回值来创建不同的重载函数</strong></figcaption></figure></blockquote></li></ul><h3 id="28860efa-7129-4358-a65e-f54e76f94da7" class="block-color-blue_background">const总结</h3><ul id="935ad841-5252-4b28-a93b-43e866282c54" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>总结</strong></span>：使用<code>const</code>的一些注意点<figure id="0b322dbf-4c67-4a2d-9ead-f23c4ce78f2c" class="image" style="text-align:center"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2023-11-29_21.33.16.png"><img style="width:528px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2023-11-29_21.33.16.png"/></a></figure><ul id="c8eaec6c-e8da-4531-aaf3-3df66efa4050" class="bulleted-list"><li style="list-style-type:circle">good practice：在自定义类中，如果要自定义一个容器，则给容器中的<code>iterator</code>类型，以及<code>begin()</code>和<code>end()</code>成员函数定义const版本和非const版本（所有的std容器都是这么做的，它们都有const版本的<code>iterator</code>、<code>begin()</code>、<code>end()</code>）</li></ul></li></ul><h2 id="74c333e5-56fa-4b7a-9313-7a3fe7d7273c" class="block-color-orange_background">自定义类</h2><h3 id="5f29b02a-2951-4b26-9a32-b1c0fb5647de" class="block-color-blue_background">basics</h3><ul id="341e9b73-815a-47c8-a07f-d1ab812bcd58" class="bulleted-list"><li style="list-style-type:disc">在自定义类中，如果要自定义一个容器，则最好给容器中的<code>iterator</code>类型，以及<code>begin()</code>和<code>end()</code>成员函数定义const版本和非const版本，以便提供一个<strong><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">const 接口</a></strong><blockquote id="2842e9de-d2b0-43b4-b3bd-1782c9f91b88" class="block-color-gray_background">所有的std容器都是这么做的，它们都有const版本的<code>iterator</code>、<code>begin()</code>、<code>end()</code></blockquote><ul id="47318163-951d-46a2-bf2d-311e656b75b0" class="bulleted-list"><li style="list-style-type:circle"><strong><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">实现const接口时的一个易错点</a></strong></li></ul></li></ul><ul id="aaf87908-8378-46c8-9ccc-1249ba711fbf" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>并不是在类中定义的函数就一定是类的成员函数</strong></span>：当用<strong><code>friend</code></strong>修饰词对类中某个函数进行修饰时，表示这个函数只是一个作用域在这个类中的普通函数（而不是这个类的成员函数）<blockquote id="2b7c81bc-0f7e-48ab-a5aa-62ace140e825" class="block-color-gray_background">这样做的具体作用可以<a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html"><strong>见这里</strong></a></blockquote></li></ul><ul id="4a2e3a18-b51c-4a1a-aca0-d1261c5af1ec" class="bulleted-list"><li style="list-style-type:disc">当自定义一个类Myclass后，<code>Myclass foo;</code>或<code>Myclass foo{};</code>会调用Myclass的无参构造函数来初始化foo<ul id="a46ea1c7-4698-47a8-a61a-ae27328ea9e8" class="bulleted-list"><li style="list-style-type:circle"><span style="border-bottom:0.05em solid"><strong>特殊情况</strong></span>：当<strong>使用了</strong><strong><code>std::optional</code></strong><strong>时</strong>，这样<code>std::optional&lt;Myclass&gt; foo</code>或<code>std::optional&lt;Myclass&gt; foo{}</code>都会调用std::optional模版类的构造函数，此时foo会被初始化为<code><em><strong>nullopt</strong></em></code>（而不是调用Myclass的无参构造函数）<ul id="b0b2cc1a-896f-456c-abe4-1b84920072f1" class="bulleted-list"><li style="list-style-type:square">所以此时如果想调用Myclass的无参构造函数，就必须用<code>std::optional&lt;Myclass&gt; foo = Myclass()</code></li></ul><ul id="dd35b289-21b2-4988-a0a9-241b894f3206" class="bulleted-list"><li style="list-style-type:square">更多信息可以参考<a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">这里</a></li></ul></li></ul></li></ul><ul id="db77cd41-e0db-4619-b097-1ebf597f3aee" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-red"><strong>自定义类的good pracitce</strong></mark>：<ul id="e6bcf955-94cc-4c1b-9c9e-fa5231ed8f3f" class="bulleted-list"><li style="list-style-type:circle"><strong>给类中使用到的各种类型通过using进行别名</strong>（例如别名pointer, reference, value_type, node_type等），并把这些别名分别放到public或private域中。<ul id="6152c963-729e-4fcc-9990-f7ce9c15d65e" class="bulleted-list"><li style="list-style-type:square">不仅是为了有更好的可读性，更重要的是可以减少硬编码的代码，从而实现代码解耦，防止要改变某个类型时，造成大量代码的重构</li></ul></li></ul><ul id="52af5b9d-75f6-4d10-bd4f-dd3c6db6f0a3" class="bulleted-list"><li style="list-style-type:circle"><strong>尽量把成员变量放到private域中进行定义</strong>，通过<strong>在public域中定义getter</strong>来让用户获取成员变量</li></ul><ul id="b5a85ae9-b787-433c-9c7a-b71b5e2a5e31" class="bulleted-list"><li style="list-style-type:circle"><strong>在private域中定义一些辅助实现的辅助函数</strong></li></ul></li></ul><h3 id="e6a4b9da-5d96-44d1-a3a9-64df7871f0a2" class="block-color-blue_background">有关(模版)类声明和(模版)类定义的代码组织</h3><ul id="2f0bc3b0-8a87-473f-9f29-ad6ef8055c09" class="bulleted-list"><li style="list-style-type:disc">当一个实例out of scope时或者被主动delete时，编译器会自动调用实例中的析构函数</li></ul><div><ul id="d91ccd91-32e1-49b7-a741-24a561d7c636" class="bulleted-list"><li style="list-style-type:disc"><em><strong><code>this</code></strong></em><em><strong>指针</strong></em>：在定义C++类的成员方法时，<span style="border-bottom:0.05em solid"><strong>默认会传入一个名叫</strong></span><code><strong>this</strong></code><strong>的</strong><mark class="highlight-purple"><span style="border-bottom:0.05em solid"><strong>指针</strong></span></mark>（并不需要显示指出），用于<strong>指向当前的对象</strong>（就像python中的<code>self</code>一样，只不过python中是显式定义的）。通过this指针，可以方针当前对象的成员变量和成员函数</li></ul></div><ul id="7e18fe24-acf7-4fa1-839b-50135559fe5f" class="bulleted-list"><li style="list-style-type:disc">自定义一个类时，<strong>如果这个类是一个容器</strong>，并让这个类支持迭代操作（比如<code>for (auto item: my_obj)</code>），则必须在类中定义<strong><code>begin()</code></strong>和<strong><code>end()</code></strong>方法，并且它们返回一个迭代器类型<ul id="c9e5a4c3-8b50-4618-a2ee-3b095364e9a4" class="bulleted-list"><li style="list-style-type:circle">迭代时会调用迭代器的<code>++</code>运算符来取下一个元素</li></ul><ul id="c52e6856-a299-4a36-8fa1-7d77b42ccd76" class="bulleted-list"><li style="list-style-type:circle">如果需要自定义迭代器，还需要定义运算符<code>++</code>,<code>==</code>,<code>!=</code></li></ul></li></ul><div id="660ca0c7-f60d-4b65-94c5-6cae71b5d7cc" class="column-list"><div id="94ba3a4f-d366-478c-911b-cb4bf90c57f3" style="width:50.000000000000014%" class="column"><ul id="8d4bdc90-4a54-408e-be00-394b69f27687" class="bulleted-list"><li style="list-style-type:disc">类的声明：MyClass.h <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="54a84fa7-59b5-4f39-933b-999ea2194874" class="code"><code class="language-C++">
class MyClass {
public:
    MyClass();  // 构造函数
    ~MyClass(); // 析构函数

    void memberFunction();  // 成员函数

private:
    int dataMember;  // 数据成员
};
</code></pre></li></ul></div><div id="02842531-5169-4ff3-acf1-7d1c3faae5f0" style="width:50%" class="column"><ul id="0ef929dd-3cd2-4065-a086-2f824b5891f0" class="bulleted-list"><li style="list-style-type:disc">类的定义（实现）：MyClass.cpp<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="ccbb09b8-06bd-4744-bc66-87b9cc11c902" class="code"><code class="language-C++">#include &quot;MyClass.h&quot;

MyClass::MyClass() {
    // 构造函数的定义 ...
}

MyClass::~MyClass() {
    // 析构函数的定义 ...
}

void MyClass::memberFunction() {
    // 成员函数的定义 ...
}</code></pre></li></ul></div></div><ul id="48d8b99b-c69f-48a6-917f-9e9df5bfe623" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-red"><em><span style="border-bottom:0.05em solid"><strong>good practice</strong></span></em></mark>：<ul id="3edc12f0-de20-4efc-ab04-7302d15ff8b2" class="bulleted-list"><li style="list-style-type:circle"><mark class="highlight-red"><span style="border-bottom:0.05em solid"><strong>对于非模版类，非模版函数</strong></span></mark>：<mark class="highlight-purple"><strong>把类/函数的声明和定义（实现）分别写在头文件(.h)和源文件(.cpp)</strong></mark>中<blockquote id="7ab5ab14-f864-403a-9e2a-57e060d6f420" class="block-color-gray_background">这样类的整体结构会看的更加清晰，并且源代码可以进行编译，从而可以只提供头文件，不暴露源码，</blockquote></li></ul><ul id="07673db3-8d08-41d0-849a-a09718e59123" class="bulleted-list"><li style="list-style-type:circle"><mark class="highlight-red"><span style="border-bottom:0.05em solid"><strong>对于模版类、模版函数</strong></span></mark>：<mark class="highlight-purple"><strong>把模版类/函数的声明和定义（实现）直接写在头文件(.h)里</strong></mark>，并且<strong>在类里面写声明，在类外面写定义</strong>（这样类的整体结构会看的更加清晰）<br/><br/><mark class="highlight-purple"><strong>或者把模版类\函数 的定义写在一个.tpp</strong></mark><mark class="highlight-default">（注意，</mark><mark class="highlight-red"><strong>模版类\函数 的定义放在.tpp而不是.cpp</strong></mark><mark class="highlight-default">），</mark><span style="border-bottom:0.05em solid"><strong><mark class="highlight-default">然后在.h的最后#include .tpp</mark></strong></span><mark class="highlight-default">，并把这个</mark><mark class="highlight-purple"><strong>.tpp文件放在与.h文件相同的目录下</strong></mark>。<br/>（在.h的最后#include .tpp本质上与直接写在.h里面是等价的）<br/><ul id="075f3b8e-1935-4fe9-ad13-20361bd1b92c" class="bulleted-list"><li style="list-style-type:square"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">否则就会报错</a></li></ul></li></ul></li></ul><h3 id="5ec30e56-0251-4e05-ade2-995cc1193aa5" class="block-color-blue_background">自定义类时的一个坑点：初始化次序</h3><ul id="d1e0883f-dfda-4adc-af20-ba3b7abaf328" class="bulleted-list"><li style="list-style-type:disc">定义类时的一个<span style="border-bottom:0.05em solid"><strong>坑点</strong></span>：在声明类成员变量时，<mark class="highlight-red"><strong>如果b的初始值依赖于a的初始值，</strong></mark><mark class="highlight-red"><span style="border-bottom:0.05em solid"><strong>那么就必须先声明a，再声明b。</strong></span></mark>这样在实例化时才会先给a赋初值，再给b赋初值；否则，就会先给b赋初值，此时a由于还没赋值，所以是系统的默认值（往往是一个随机数），从而导致b赋初值时产生bug<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="478077ba-9228-4e12-9d01-88b033abe384" class="code"><code class="language-C++">private:
    using head = ValueType*;
    using iterator = ValueType*;
    using size_type = std::size_t;

    const size_type InitialAllocatedSize = 2;
    const size_type IncrementFactor = 2;

    head elems;
    size_type LogicalSize;
    size_type AllocatedSize; 
		/* AllocatedSize的值在进行实例化时可能会依赖于InitialAllocatedSize，
			 所以InitialAllocatedSize的声明必须写在AllocatedSize前面
		*/</code></pre></li></ul><h3 id="4e46f31d-2503-423a-b16d-b623374bda53" class="block-color-blue_background">类的静态成员</h3><ul id="2c9a383f-bc94-419b-8174-981a43419136" class="bulleted-list"><li style="list-style-type:disc">类的静态成员：静态成员变量<strong>不能在类内部初始化</strong><blockquote id="aca35e21-be79-496f-aa74-fe3c60ee443d" class="block-color-gray_background">因为静态成员变量，与普通成员变量不同，不是与类的每个实例相关联的，而是与类本身相关联。这意味着静态成员变量在所有类实例之间共享，并且只有一份内存副本。为了实现这一点，静态成员需要在类定义之外单独定义和分配存储空间。</blockquote><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="466fdf68-205a-41c6-a1d8-ec44bc82c66b" class="code"><code class="language-C++">// MyClass.h
class MyClass {
public:
    static int staticMember; // 声明
};

// MyClass.cpp
int MyClass::staticMember = 0; // 定义和初始化</code></pre></li></ul><h3 id="a4dd4546-781f-4e66-8505-78db2c4d8182" class="block-color-blue_background">在类中可重载的运算符</h3><figure id="df7f8e0e-f0fb-4258-8d26-596ea821eebd" class="image" style="text-align:center"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2023-12-11_21.50.44.png"><img style="width:384px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2023-12-11_21.50.44.png"/></a></figure><ul id="97123422-a64b-4e2d-9689-23c83cc8fcf2" class="bulleted-list"><li style="list-style-type:disc">当使用任何运算符时<mark class="highlight-red"><strong>本质上都是在调用这个运算符对应的成员函数</strong></mark><mark class="highlight-default">（或者是在外部定义的友元函数或者全局函数，可以参考这里），</mark><strong><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html"><mark class="highlight-default">因为C++为运算符实现了专门的语法糖</mark></a></strong>。例如：<ul id="a4c045ec-01b2-49f9-996c-1cca771f1320" class="bulleted-list"><li style="list-style-type:circle">x1 + x2：<ul id="f753a0ed-5bc1-40cf-9390-df6ccb2f0bfe" class="bulleted-list"><li style="list-style-type:square">x1.operator+(x2)（有对应的外部函数重载）</li></ul><ul id="6f571321-67e3-4762-b6b1-2091efcf92ff" class="bulleted-list"><li style="list-style-type:square">operator+(x1, x2)（没有对应的外部函数重载）</li></ul></li></ul><ul id="414ed2fe-6851-4b12-8acb-201d4bddec21" class="bulleted-list"><li style="list-style-type:circle">++x1：<ul id="d9c1c8d2-9691-4490-859b-980fe342e750" class="bulleted-list"><li style="list-style-type:square">x1.operator++()（有对应的外部函数重载）</li></ul><ul id="d3dd9044-4d57-45c9-856e-3d21fdff28a7" class="bulleted-list"><li style="list-style-type:square">operator++(x1)（没有对应的外部函数重载）</li></ul></li></ul><ul id="16652bfd-1d63-4883-bd9c-bbf77e8bac8f" class="bulleted-list"><li style="list-style-type:circle">x1++：<ul id="801da318-811d-4ca8-a319-441518456fee" class="bulleted-list"><li style="list-style-type:square">operator++(x1, int)（有对应的外部函数重载）</li></ul><ul id="5ff94ae2-8cf2-4155-8956-764dc060e700" class="bulleted-list"><li style="list-style-type:square">x1.operator++(int)（没有对应的外部函数重载）</li></ul><blockquote id="76437edd-3fda-4fb8-810f-22845e6b20a3" class="block-color-gray_background">通过在括号中加入int来帮助编译器进行区分从而进行重载</blockquote></li></ul><ul id="d2509ae8-f289-4d3c-8a92-b5093dba9b4e" class="bulleted-list"><li style="list-style-type:circle"><mark class="highlight-purple"><strong>有一个特例，即→运算符</strong></mark>，例如x1→value，调用的是(x1.operator→())→value，即对于→运算符，<span style="border-bottom:0.05em solid"><strong>返回的必须是一个指针</strong></span></li></ul></li></ul><h3 id="d50d75fe-39c8-4d84-b00f-b043a28fc156" class="block-color-blue_background">成员函数的各种修饰符：explicit、= default、= delete、 =0</h3><ul id="a7bac144-fa91-481b-9040-ca89cf5c18c5" class="bulleted-list"><li style="list-style-type:disc"><strong><em><code>explicit</code></em></strong>关键字：用于<strong>防止类</strong><span style="border-bottom:0.05em solid"><strong>构造函数</strong></span><strong>的隐式自动转换</strong>。默认情况下，<span style="border-bottom:0.05em solid"><strong>如果构造函数只接受一个参数</strong></span>，C++允许不经声明直接将该类型的对象转换为构造函数参数类型的对象。例如：<ul id="c5e4748b-f2c9-44ad-9688-c515e353a449" class="bulleted-list"><li style="list-style-type:circle"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">case1</a></li></ul><ul id="e741c202-c604-46e2-b162-0bb5bd40fcf2" class="bulleted-list"><li style="list-style-type:circle"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">case2</a></li></ul></li></ul><ul id="e5ab00c0-c9e5-43bd-a0cf-f6a29b898078" class="bulleted-list"><li style="list-style-type:disc">在成员函数后面加上<strong><code>= default</code></strong>时，会让编译器自动生成默认的特殊成员函数<blockquote id="4561da60-3227-4c8e-a0dd-e6ad3b1839c4" class="block-color-gray_background">更多的信息见<a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">这里</a></blockquote><ul id="cb3f7c72-dc63-4c42-964e-2c123b2c06c6" class="bulleted-list"><li style="list-style-type:circle">当要显式地使用<a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">Rule of zero</a>时，这个关键字就很常用</li></ul></li></ul><ul id="33db5553-797b-4a75-bb0f-67ed07a99c0f" class="bulleted-list"><li style="list-style-type:disc">在成员函数后面加上<strong><code>= delete</code></strong>时，表示指出这些函数不应该被使用，例如以下场景可能会用到这个需求：<ul id="a0aaa9ce-8766-423d-97db-b04792280a54" class="bulleted-list"><li style="list-style-type:circle">防止对象拷贝（触发拷贝构造函数）</li></ul><ul id="4532dbf8-fb0c-4999-aa72-fce2f6d5a84a" class="bulleted-list"><li style="list-style-type:circle">禁用不合适的重载</li></ul><ul id="e044a516-2412-40ee-ad6a-f17958fb7f74" class="bulleted-list"><li style="list-style-type:circle">替代私有未定义函数<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="e30beea8-1f6c-42a7-aed9-262cc18b6e93" class="code"><code class="language-C++">// C++11之前的方式
class OldStyleNonCopyable {
private:
    OldStyleNonCopyable(const OldStyleNonCopyable&amp;);
    OldStyleNonCopyable&amp; operator=(const OldStyleNonCopyable&amp;);
};

// C++11及以后
class ModernNonCopyable {
public:
    ModernNonCopyable(const ModernNonCopyable&amp;) = delete;
    ModernNonCopyable&amp; operator=(const ModernNonCopyable&amp;) = delete;
};</code></pre><ul id="b051c107-1f27-4cf6-8db9-2bb3e4a59070" class="bulleted-list"><li style="list-style-type:square">在声明函数时，可以不指出参数名。但如果即声明又要定义，则必须指出参数名。</li></ul></li></ul></li></ul><ul id="6850831a-f491-41e5-bcb8-60a73d5a8a11" class="bulleted-list"><li style="list-style-type:disc">在成员函数后面加上= 0时，表示这是一个<a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html"><strong>纯虚函数</strong></a></li></ul><h3 id="27a16453-a22f-4e50-976f-39154bfdbe5b" class="block-color-blue_background">类的初始化列表：减少overhead</h3><ul id="1ad0d384-9916-4254-b4b8-3bd41c292daf" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>初始化列表</strong></span>：<mark class="highlight-purple"><span style="border-bottom:0.05em solid"><strong>一种</strong></span></mark><mark class="highlight-red"><span style="border-bottom:0.05em solid"><strong>专用于类构造函数</strong></span></mark><mark class="highlight-purple"><span style="border-bottom:0.05em solid"><strong>的语法</strong></span></mark></li></ul><ul id="0e926bb6-2458-47fc-938b-f3b3a9435cb6" class="bulleted-list"><li style="list-style-type:disc">对于类中每一个成员变量，假如在类中定义时有一部分成员变量已经给了初值，那么<strong>在进入到这个类的构造函数之前（包括在进入到构造函数的初始化列表之前），这部分成员变量就已经被赋予了初值</strong>。<br/>对于那些在类中定义，但是<br/><span style="border-bottom:0.05em solid"><strong>没有赋予初值的成员变量</strong></span>，在进入构造函数之前，它会<mark class="highlight-red"><span style="border-bottom:0.05em solid"><strong>先执行代码块前面的初始化列表</strong></span></mark>，例如：<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="3c37eebe-9c26-4b82-a6a7-336fcf30ed00" class="code"><code class="language-C++">#include &quot;StrVector.h&quot;

StrVector::StrVector():  /* 注意：初始化列表之前有一个冒号: */
		// 构造函数的初始化列表
    LogicalSize{0},
    AllocatedSize{InitialAllocatedSize}
{
    elems = new std::string[AllocatedSize];
}</code></pre><p id="768d21ce-cda2-4359-b3a1-e66c45c9d30d" class=""><mark class="highlight-default"><strong>假如这些</strong></mark><mark class="highlight-red"><span style="border-bottom:0.05em solid"><strong>没有初值的成员变量</strong></span></mark><mark class="highlight-red"><strong>仍然没有在初始化列表中进行初始化</strong></mark><mark class="highlight-default"><strong>，那么</strong></mark><mark class="highlight-red"><strong>编译器就会调用这些成员变量默认的构造函数作为初值</strong></mark><mark class="highlight-default"><strong>，然后</strong></mark><mark class="highlight-red"><strong>再进入构造函数的代码主体</strong></mark><mark class="highlight-default"><strong>；</strong></mark><div class="indented"><blockquote id="df06d473-3c43-4e80-85bb-131edff1ea7b" class="block-color-gray_background"><mark class="highlight-default">如果初始化列表为空，就表示不做任何初始化操作</mark></blockquote></div></p><p id="1eff2ceb-ef1c-4ed5-9700-9ce98c2cfe35" class="">因此，<span style="border-bottom:0.05em solid"><strong>尽量把没有初值的成员变量的初始化写在初始化列表里</strong></span>，<mark class="highlight-red"><strong>否则会</strong></mark><span style="border-bottom:0.05em solid"><mark class="highlight-red"><strong>额外调用一次构造函数和一次移动赋值运算符</strong></mark></span>，例如将上述代码改为：</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="92382aa8-dfec-40b8-be89-ba0c10b991bb" class="code"><code class="language-C++">#include &quot;StrVector.h&quot;

StrVector::StrVector():
		// 构造函数的初始化列表
    LogicalSize{0}, 
    AllocatedSize{InitialAllocatedSize}, 
    elems{new std::string[AllocatedSize]} 
{
    ;
}</code></pre></li></ul><ul id="3adf3576-8377-417b-a60f-3ec401f714ac" class="bulleted-list"><li style="list-style-type:disc">尤其是对于某些自定义的类，<strong>当这个类的构造函数有很大的开销时</strong>，将初始化语句写在初始化列表里会<mark class="highlight-purple"><span style="border-bottom:0.05em solid"><strong>显著提升性能</strong></span></mark>（因为可以减少一次构造函数的开销）例如以下代码：<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="5c7e8f14-b77a-41e7-917b-5dbe67fb77b8" class="code"><code class="language-C++">#include &lt;iostream&gt;

// 假设 ExpensiveToCopy 是一个资源密集型的类
class ExpensiveToCopy {
public:
    ExpensiveToCopy() {
        std::cout &lt;&lt; &quot;Expensive construction&quot; &lt;&lt; std::endl;
        // 假设这里有昂贵的资源分配
    }

    ExpensiveToCopy(const ExpensiveToCopy&amp;) {
        std::cout &lt;&lt; &quot;Expensive copy construction&quot; &lt;&lt; std::endl;
        // 假设拷贝复制也很昂贵
    }

    ExpensiveToCopy(ExpensiveToCopy&amp;&amp;) noexcept {
        std::cout &lt;&lt; &quot;Cheap move construction&quot; &lt;&lt; std::endl;
        // 移动构造通常较便宜
    }

    ExpensiveToCopy&amp; operator=(const ExpensiveToCopy&amp;) {
        std::cout &lt;&lt; &quot;Expensive copy assignment&quot; &lt;&lt; std::endl;
        // 定义复制赋值运算符
        return *this;
    }

    ExpensiveToCopy&amp; operator=(const ExpensiveToCopy&amp;&amp;) {
        std::cout &lt;&lt; &quot;Cheap copy assignment&quot; &lt;&lt; std::endl;
        // 定义复制赋值运算符
        return *this;
    }
};

// Container 包含 ExpensiveToCopy 对象
class Container {
public:
    // 使用成员初始化列表
    Container() : expensiveMember() {
        // 成员已经在初始化列表中被构造
				// 注意：expensiveMember()是一个列表初始化语句中专用的语法(也可以用花括号：expensiveMember{})
				//+     它会调用expensiveMember对应类（ExpensiveToCopy）的
				//+     构造函数来初始化expensiveMember
    }

    // 不使用成员初始化列表
    Container(bool dummy) {
        // 注意，这里的ExpensiveToCopy()是一个右值，所以触发移动语义
        expensiveMember = ExpensiveToCopy();
    }

private:
    ExpensiveToCopy expensiveMember;
};

int main() {
    std::cout &lt;&lt; &quot;Creating Container with initialization list:&quot; &lt;&lt; std::endl;
    Container withInitList;

    std::cout &lt;&lt; &quot;\nCreating Container without initialization list:&quot; &lt;&lt; std::endl;
    Container withoutInitList(true);

    return 0;
}

/* 
&gt;&gt;&gt; Creating Container with initialization list:
&gt;&gt;&gt; Expensive construction

&gt;&gt;&gt; Creating Container without initialization list:
&gt;&gt;&gt; Expensive construction
&gt;&gt;&gt; Expensive construction
&gt;&gt;&gt; Cheap copy assignment

可以看到，如果不写在初始化列表中进行初始化，会额外调用一次构造函数和一次移动赋值运算符
*/</code></pre></li></ul><h3 id="bb68256c-f80d-49c5-94ba-84d01d6a3272" class="block-color-blue_background">在初始化列表中使用委托构造函数（Delegating Constructor）</h3><ul id="a0c07ca4-e522-4a22-9b45-e7eec774eb7e" class="bulleted-list"><li style="list-style-type:disc">在C++中，委托构造函数（Delegating Constructor）是一种<span style="border-bottom:0.05em solid"><strong>在一个构造函数中调用同一个类的另一个构造函数的方式</strong></span>。这个特性在C++11中被引入，允许构造函数之间的代码重用，避免重复编写初始化代码，从而使代码更加简洁和易于维护</li></ul><ul id="621f51cc-94e4-4079-b321-700a42b6bcc8" class="bulleted-list"><li style="list-style-type:disc">委托构造函数<mark class="highlight-purple"><span style="border-bottom:0.05em solid"><strong>通过在初始化列表中调用另一个构造函数</strong></span></mark>来实现。<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="e6d01b8d-efcd-453e-bab3-9bea533e0c20" class="code"><code class="language-C++">class MyClass {
public:
    // 委托构造函数
    MyClass(int x) : value(x) {
        // 其他初始化逻辑
    }

    // 委托给MyClass(int x)
    MyClass() : MyClass(0) {}

private:
    int value;
};</code></pre><ul id="365a1693-49ac-4c19-a660-8a120a40703c" class="bulleted-list"><li style="list-style-type:circle">⚠️：<strong>委托关系不能形成闭环</strong>，即不能出现A委托给B，B委托给C，C再委托给A这样的情况。</li></ul></li></ul><h3 id="9dc9b247-f82a-4ba5-a346-acae27b16d66" class="block-color-blue_background">在类中通过结构体定义一个变量</h3><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="410cb2db-68db-4d63-ac9a-37247bf53ea4" class="code"><code class="language-C++">class HashMap {
public:
...

private:
    struct node {  // 定义一个node类型
        value_type value;
        node* next;

        node(const value_type&amp; value = value_type(), node* next = nullptr) :
            value(value), next(next) {}
    };

    using node_pair = std::pair&lt;typename HashMap::node*, typename HashMap::node*&gt;;
...

}</code></pre><h3 id="0d2661a8-ef4b-4915-ad83-8001c3d73f30" class="block-color-blue_background">类中的特殊成员函数及其高效实现</h3><p id="e9b5a691-db4d-4047-907a-6f1f0fdd8f72" class=""> </p><h3 id="9c578917-a628-4b1f-a578-d65e7db2a77b" class="block-color-blue_background"><strong>初始化器列表构造函数：用于</strong>自定义类的花括号初始化</h3><ul id="4a239e8a-de14-43f5-8f86-c9812829d917" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>对于自定义类，如果想要实现</strong></span><span style="border-bottom:0.05em solid"><strong><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">花括号初始化（列表初始化）</a></strong></span><span style="border-bottom:0.05em solid"><strong>，可以通过以下方式</strong></span>：<ul id="c65a1afc-2a70-41ec-b6c3-028d4d28e91d" class="bulleted-list"><li style="list-style-type:circle"><strong>初始化器列表构造函数</strong><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="61396b5a-4870-40ce-9c0b-5c2b366b26bb" class="code"><code class="language-C++">#include &lt;initializer_list&gt;

class MyClass {
public:
    MyClass(std::initializer_list&lt;int&gt; initList) {  
        // 专门用于列表初始化的列表构造函数重载
        // 使用 initList 初始化 MyClass
        // std::initializer_list可以理解为就是一个vector
        // 只不过为了专门定义一个列表初始化的构造函数重载，就需要专门定义一个数据结构std::initializer_list
    }
};</code></pre><p id="f6e8e8f0-31fd-46c7-915d-93e4c54f2122" class=""><code>std::vector</code>就实现了初始化器列表构造函数，因此<code>vector&lt;int&gt; vec(3)</code>和<code>vector&lt;int&gt; vec{3}</code>调用的是不同的重载构造函数方法。</p></li></ul><ul id="3c74b372-5c29-418a-ab48-1805291b59ce" class="bulleted-list"><li style="list-style-type:circle"><strong>实现对应类型的构造函数</strong><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="9c869e96-e42c-4480-a72c-757dd6baee00" class="code"><code class="language-C++">class MyClass {
public:
    MyClass(int a, int b) {
        // 使用 a 和 b 初始化 MyClass
    }
};

MyClass obj {10, 20};</code></pre><p id="6d99127e-841f-4fd2-aecf-132eccf297b4" class="">编译器会尝试寻找最匹配的构造函数（<span style="border-bottom:0.05em solid"><strong>优先从初始化器列表构造函数找</strong></span>，然后再从普通的重载构造函数开始找）。如果没有找到合适的构造函数，编译器可能会选择一个接受初始化器列表的构造函数。</p><blockquote id="b51d5c18-092f-48ed-9402-bce1244f8824" class="block-color-gray_background">所以也就知道了到<strong>花括号初始化和普通的初始化在流程上的区别</strong>：使用花括号初始化时，编译器会优先从初始化器列表构造函数开始匹配，再从一般的重载构造函数开始匹配；而普通的的初始化直接从一般的重载构造函数开始匹配<br/><br/><br/><span style="border-bottom:0.05em solid"><strong>所以花括号初始化的适用范围还比普通的初始化要大</strong></span>（多了初始化器列表构造函数可以匹配）</blockquote></li></ul></li></ul><h3 id="d2b0d455-3dd8-41a4-a271-1ab9c118e08a" class="block-color-blue_background">case：一个简单的自定义类</h3><p id="2d97eed9-4460-420a-b686-06b1307fc169" class="">类声明：StrVector.h</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="4281bb81-7f1a-49d7-b9fb-07826d2bcf35" class="code"><code class="language-C++">/*  StrVector.h */
#ifndef STRVECTOR_H
#define STRVECTOR_H 1

#include &lt;iostream&gt;
#include &lt;string&gt;

class StrVector {
public:
    using iterator = std::string*;
    using head = std::string*;
    using size_type = std::size_t;

    StrVector();
    StrVector(size_type n, const std::string&amp; val);
    ~StrVector();  // 析构函数

    bool empty()      const;
    size_type size()  const;  // 由于LogicalSize是private变量，所以必须定义一个取值函数
    iterator  begin() const;
    iterator  end()   const;

    std::string&amp; operator[](size_type idx);

    iterator insert(iterator pos, const std::string&amp; val);
    void push_back(const std::string&amp; val);

private:
    head elems;
    const size_type InitialAllocatedSize = 2;
    const size_type IncrementFactor = 2;
    size_type LogicalSize;
    size_type AllocatedSize;

    void grow();
};

#endif</code></pre><p id="be030878-658c-4275-bf04-692cb044d1bc" class="">类定义：StrVector.cpp</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="ae3a0774-88d3-4ee2-a907-73ab8bda843d" class="code"><code class="language-C++">#include &quot;StrVector.h&quot;

StrVector::StrVector():
    // 构造函数的初始化列表
    LogicalSize{0}, 
    AllocatedSize{InitialAllocatedSize}
{
    elems = new std::string[AllocatedSize];
}

StrVector::StrVector(StrVector::size_type n, const std::string&amp; val):
    LogicalSize{n}, AllocatedSize{IncrementFactor * n}
{
    elems = new std::string[AllocatedSize];
    std::fill(begin(), end(), val);
}

StrVector::~StrVector() {
    delete[] elems;
}

bool StrVector::empty() const {
    return size() == 0;
}

StrVector::size_type StrVector::size() const{
    return LogicalSize;
}

// ...</code></pre><ul id="0f66f61d-77cf-422e-b895-e00e98056f1d" class="bulleted-list"><li style="list-style-type:disc">当用<code>const</code>修饰一个类成员函数时，表示这个成员方法不会修改对象的状态</li></ul><ul id="3ffbdf66-6232-4e69-896f-e2d3ef776cd3" class="bulleted-list"><li style="list-style-type:disc"><code>StrVector(); StrVector(size_type n, const std::string&amp; val);</code>都是构造函数（构造函数在定义时可以有专门的<strong>初始化列表语句</strong>）</li></ul><ul id="a136993a-f90c-4523-9207-78f1c099155c" class="bulleted-list"><li style="list-style-type:disc"><code>~StrVector()</code>是析构函数当使用delete释放对象时会调用这个函数</li></ul><h2 id="0e168ba7-3533-4512-a594-ff4fe615cc5e" class="block-color-orange_background">类进阶：类中特殊的成员函数（高效实现）</h2><figure id="e4573398-ea96-47c4-81fc-4cf0f7715c20" class="image"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2023-12-14_20.47.42.png"><img style="width:528px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2023-12-14_20.47.42.png"/></a></figure><ul id="707cc8ac-af52-4cf2-9af0-17d3a6ca1f1f" class="bulleted-list"><li style="list-style-type:disc">在C++的类中一共有6类特殊的成员函数（SPF，Special Member Function）<ul id="3f55d8cd-94c1-4777-89f2-c0dee4f9d333" class="bulleted-list"><li style="list-style-type:circle">构造函数</li></ul><ul id="4fef2e3c-0188-4e65-80c3-a162bc436da3" class="bulleted-list"><li style="list-style-type:circle">析构函数</li></ul><ul id="79951716-908c-40f2-8274-6dd7d3e9f614" class="bulleted-list"><li style="list-style-type:circle">拷贝构造函数</li></ul><ul id="824476da-b19a-4d1e-814c-c4137af72efc" class="bulleted-list"><li style="list-style-type:circle">赋值运算符</li></ul><ul id="e8de126a-c8ec-4b00-a1a6-edf9092a4dbe" class="bulleted-list"><li style="list-style-type:circle">移动拷贝构造函数</li></ul><ul id="3cead3fb-0319-431d-aa83-53b6cb2af99e" class="bulleted-list"><li style="list-style-type:circle">移动赋值运算符</li></ul></li></ul><ul id="e9f09e4e-e489-44c7-a5e5-5f4410881443" class="bulleted-list"><li style="list-style-type:disc"><code>vector&lt;int&gt; vec</code>和<code>vector&lt;int&gt; vec{}</code> 调用的都是无参数的构造函数</li></ul><ul id="dd683ce6-ed03-45b2-bb9c-2f575a831bfc" class="bulleted-list"><li style="list-style-type:disc"><code>vector&lt;int&gt; vec{vec1 + vec2}</code>调用的是拷贝构造函数</li></ul><h3 id="2c7eafa6-9f32-46d7-81d4-7288ede362b0" class="block-color-blue_background">实现构造函数的一个trick：使用默认值</h3><ul id="3af769d6-0e73-4600-92a4-9477a930db56" class="bulleted-list"><li style="list-style-type:disc">通过在构造函数中使用默认值可以实现多种情况下的构造函数，从而使代码更加紧凑<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="5b5c0507-3007-490f-bb83-d1bfcf4844ff" class="code"><code class="language-C++">class MyClass {
public:
    int data;
    MyClass* next;

    // 构造函数使用默认参数，相当于实现了4种类型的构造函数
    MyClass(int data = 0, MyClass* next = nullptr) : data(data), next(next) {}
};</code></pre></li></ul><h3 id="66c0774b-9dfe-4572-ab54-9f4722411c88" class="block-color-blue_background">拷贝构造函数</h3><ul id="c214063a-a010-4efe-9bcf-8060a22bad40" class="bulleted-list"><li style="list-style-type:disc">当以下情况发生时，会调用<span style="border-bottom:0.05em solid"><strong>拷贝构造函数</strong></span><ul id="440aeb09-c3ef-4616-aa7f-f1b362e0ddb0" class="bulleted-list"><li style="list-style-type:circle">通过使用另一个同类型的对象来初始化一个新对象。<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="04ce7603-623d-4344-8da0-bca82be96d21" class="code"><code class="language-C++">vector&lt;int&gt; foo = {1, 2, 3};
vector&lt;int&gt; bar{foo};</code></pre></li></ul><ul id="f0e83118-8623-4567-a169-586d0cadf27a" class="bulleted-list"><li style="list-style-type:circle">对象被作为函数参数<strong>按值传递</strong>。</li></ul><ul id="9f99dd73-44a9-4075-a241-979a448e0f8a" class="bulleted-list"><li style="list-style-type:circle">函数返回对象时，<strong>按值返回</strong>。</li></ul><ul id="429c16b1-860c-42d5-acc4-2b7e09018559" class="bulleted-list"><li style="list-style-type:circle">使用初始化列表初始化数组中的对象。<blockquote id="81b19d60-1e26-460a-a174-6cffae02dedd" class="block-color-gray_background">例如<code>Myclass obj[3] = {Myclass(..), Myclass(…), Myclass(…)}</code>时</blockquote></li></ul></li></ul><ul id="bc1f2c44-1026-470c-b75c-9d8af96c13b0" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>std容器</strong></span><span style="border-bottom:0.05em solid">（如vector，list，map）中的构造函数通常都实现为</span><span style="border-bottom:0.05em solid"><strong>深拷贝</strong></span></li></ul><ul id="88e74596-f222-40ed-86b1-30f2787df457" class="bulleted-list"><li style="list-style-type:disc">语法：与构造函数一样定义一个类同名函数，参数传入一个相同的类实例（并且通常都会用<code>const</code>+<code>&amp;</code>进行修饰）</li></ul><ul id="ccdc9f2d-eae9-42d1-b063-8eb3b269df0e" class="bulleted-list"><li style="list-style-type:disc"><strong><mark class="highlight-red">一个拷贝构造函数的case</mark></strong>：<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="313b0acb-554f-4087-be6c-dc65a3a94c81" class="code"><code class="language-C++">class ComplexClass {
    char *data;

public:
    // 构造函数
    ComplexClass(const char *str) {
        data = new char[strlen(str) + 1];
        strcpy(data, str);
    }

    // 拷贝构造函数(深拷贝)
    ComplexClass(const ComplexClass &amp;other) {
        data = new char[strlen(other.data) + 1];
        strcpy(data, other.data);
    }
};</code></pre></li></ul><ul id="b16f9592-4f2a-4e91-af49-c198493f5973" class="bulleted-list"><li style="list-style-type:disc">拷贝构造函数在<strong>对象被创建时</strong>调用，例如<code><strong>MyClass obj1 = obj2;</strong></code>，或在函数参数和返回值中传递对象时（值传递）<ul id="be4e2fec-a788-49fc-a58b-dc9ff63501f2" class="bulleted-list"><li style="list-style-type:circle"><span style="border-bottom:0.05em solid"><strong>注意与赋值运算符的区别</strong></span>，赋值运算符在对象已经存在时用于更新其内容。</li></ul></li></ul><h3 id="8c67d29b-57b2-4c1f-aad4-106226062623" class="block-color-blue_background">赋值运算符重载</h3><ul id="c39ffcce-3a5e-45e3-9eab-350fe1501827" class="bulleted-list"><li style="list-style-type:disc">通过在类中重载<strong><code>operator=</code></strong>来实现</li></ul><ul id="8b9db175-dcb5-44a0-9a4a-d92c71b720b6" class="bulleted-list"><li style="list-style-type:disc">通常会返回一个同样的类实例，从而实现<strong>链式赋值</strong></li></ul><ul id="cb3e33bd-8ac5-4e0e-a54e-a321b77a942f" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>std标准容器</strong></span><span style="border-bottom:0.05em solid">（如vector，list，map）通常都会把</span><span style="border-bottom:0.05em solid"><strong><code>operator=</code></strong></span><span style="border-bottom:0.05em solid">实现为</span><span style="border-bottom:0.05em solid"><strong>深拷贝</strong></span></li></ul><ul id="e44f3618-013f-4937-8bd0-e1198f55432d" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-red"><strong>一个实现深拷贝operator=的case</strong></mark>：<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="3becdb6c-20d5-487e-83a3-0960f9008ab9" class="code"><code class="language-C++">#include &lt;iostream&gt;
#include &lt;vector&gt;

class ComplexClass {
public:
    std::vector&lt;int&gt; data;

    // 构造函数
    ComplexClass(const std::vector&lt;int&gt;&amp; vec) : data(vec) {}

    // 拷贝赋值运算符(深拷贝)
    ComplexClass&amp; operator=(const ComplexClass&amp; other) {
        if (this != &amp;other) {  // 防止自赋值（self-assign）
            data = other.data; // 直接赋值，std::vector自身管理深拷贝
        }
        return *this;  /** 返回一个同样的类实例，实现链式赋值 
        * this是一个指向对象本身的指针，因此*this表示对象本身
        * 而ComplexClass&amp;表示返回的是一个引用（不按值传递） 
        */
    }
};</code></pre></li></ul><h3 id="b38b3a27-4b92-48fe-86ec-488259fdbb15" class="block-color-blue_background">移动拷贝构造函数、移动赋值运算符</h3><ul id="80246079-e9a1-4a85-8b30-f71e66965eb1" class="bulleted-list"><li style="list-style-type:disc">一个例子<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="e5b6ac52-b860-43f4-bb5a-0c92e5eacb49" class="code"><code class="language-C++">class MyClass {
public:
    // 移动拷贝构造函数
    MyClass(MyClass&amp;&amp; other):
        _ptr{other._ptr},
        _array{std::move(other._array)}/** 接管other的资源，
         * 并自动使用std::vector提供的移动语义
         * 在初始化列表中初始化，减少不必要的overhead
         * 注意：虽然other是一个右值，但是取出other的成员变量_array时
         * other._array仍然会被视为一个左值
         */
         ...
   {
        // 将other置于无害的状态（假如有指针的话）
        other._ptr = nullptr;
    }

		// 移动赋值函数
		MyClass&amp; operator=(MyClass&amp;&amp; other) {  /*  &amp;&amp;用来修饰一个右值 */
		    if (this != &amp;other) {
		        // 接管资源
		        _array = std::move(other._array);  // 直接使用vector提供的提供语义的赋值
            _ptr  = other._ptr;
		        // 将源对象资源置为无效状态
		        other._ptr = nullptr;
		    }
		    return *this; // 与赋值运算符同理，最后return一个*this，用于实现链式赋值
		}

private:
    std::vector&lt;SomeType&gt; _array;
    SomeType* _ptr;
};</code></pre><ul id="152dee05-f1f4-4a97-8c91-c81a446af5d8" class="bulleted-list"><li style="list-style-type:circle">可以看到，拷贝构造函数比移动拷贝构造函数多了申请内存，copy by value两个操作，当这个资源很大时，这两个操作时间开销都非常大</li></ul><ul id="133687eb-eee4-4578-ba1d-709b4cbfce32" class="bulleted-list"><li style="list-style-type:circle">移动拷贝构造函数针对的是<a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">右值</a>对象</li></ul><ul id="40a37f24-eb2d-4b52-bea4-12ca8666fed8" class="bulleted-list"><li style="list-style-type:circle">移动拷贝构造允许对象的资源（如动态分配的内存）从一个对象转移到另一个对象，这样可以提高性能（在传统的复制构造函数中，对象的所有数据都会被复制，这会涉及大量的资源分配和拷贝操作，尤其是在处理大型数据结构）</li></ul><ul id="c773bfd6-afdd-4674-bc0e-0fb9e51381d7" class="bulleted-list"><li style="list-style-type:circle">移动拷贝构造函数的工作原理是接管（&quot;窃取&quot;）源对象的资源（通过接管指针），然后将源对象置于一个有效但未定义的状态。这种方法不仅<span style="border-bottom:0.05em solid"><strong>避免了不必要的拷贝</strong></span>，还能节约内存和处理时间</li></ul></li></ul><ul id="7e71ca93-7475-4790-8384-ddebf7827fd3" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>移动赋值运算符</strong></span>：移动赋值运算符用于<strong>根据右值重新赋值某个已存在的对象</strong><blockquote id="5bc48055-fe63-4281-8a7a-e4fb9048c285" class="block-color-gray_background">注意与移动拷贝构造函数的区别，移动拷贝构造函数用于<strong>根据右值初始化新对象</strong></blockquote></li></ul><h3 id="72e137f4-ba28-49fb-8f37-b92c5be5d94d" class="block-color-blue_background">由编译器<strong>自动生成：默认构造函数、默认拷贝构造函数、默认拷贝赋值运算符等</strong></h3><ul id="8f5cdbbf-3900-4649-9a84-8a9b2dbd5989" class="bulleted-list"><li style="list-style-type:disc"><strong>默认构造函数</strong>：如果你没有定义任何构造函数，编译器会为你的类生成一个默认构造函数（无参数的构造函数）。<ul id="1ea55f04-050b-4c1a-ab8d-243485fd3140" class="bulleted-list"><li style="list-style-type:circle">如果这个类没有基类，则默认的构造函数不会做任何事情；如果有，则调用基类的构造函数</li></ul></li></ul><ul id="91eda4e5-5587-4628-baf5-bb6e6c4acd89" class="bulleted-list"><li style="list-style-type:disc"><strong>默认拷贝构造函数</strong>：如果你没有定义拷贝构造函数，编译器会为你的类生成一个默认的拷贝构造函数。<ul id="77dd9ee0-8518-4c7e-a56c-0192734dbed0" class="bulleted-list"><li style="list-style-type:circle">默认实现的是<mark class="highlight-red"><strong>浅拷贝版本</strong></mark>（std容器实现的都是深拷贝版本），即：<ul id="c5632908-5057-4be9-81a7-7bcec5c5b53d" class="bulleted-list"><li style="list-style-type:square"><strong>对于基本数据类型</strong>（如int、double等），这意味着简单地复制值。</li></ul><ul id="c9718f6a-ac29-48ae-ae51-00cd6634e41d" class="bulleted-list"><li style="list-style-type:square"><strong>对于类类型的成员</strong>，<mark class="highlight-purple"><span style="border-bottom:0.05em solid"><strong>如果成员有自己的拷贝构造函数</strong></span></mark><strong>，那么会调用这个成员的拷贝构造函数来进行复制</strong>。但是，<mark class="highlight-purple"><span style="border-bottom:0.05em solid"><strong>如果成员是指针类型</strong></span></mark>，只有指针值（内存地址）被复制，<mark class="highlight-purple"><strong>指向的内存内容不会被复制</strong></mark>。这就是所谓的&quot;浅拷贝&quot;。</li></ul></li></ul><ul id="8984ed65-5186-409c-b1d2-72c247854e3d" class="bulleted-list"><li style="list-style-type:circle"><strong>因此，</strong><mark class="highlight-purple"><strong>如果自定义类中</strong></mark><mark class="highlight-purple"><span style="border-bottom:0.05em solid"><strong>有指针类型</strong></span></mark><mark class="highlight-purple"><strong>，并且想要实现一个深拷贝版本</strong></mark><strong>，就</strong><span style="border-bottom:0.05em solid"><strong>必须自定义拷贝构造函数</strong></span>（因为默认的拷贝构造函数不会copy指针对应的内存，而指针类型本身的拷贝构造函数也不会拷贝对应的内存）</li></ul></li></ul><ul id="fedb250c-b877-4397-ad1d-3bca43fb1e8a" class="bulleted-list"><li style="list-style-type:disc"><strong>默认拷贝赋值运算符</strong>：如果你没有定义拷贝赋值运算符，编译器会为你的类生成一个默认的拷贝赋值运算符。<ul id="8e1ad937-8609-4f07-9fa1-432062ce4522" class="bulleted-list"><li style="list-style-type:circle">默认实现的是<mark class="highlight-red"><strong>浅拷贝版本</strong></mark>（std容器实现的都是深拷贝版本），含义与<a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">之前</a>相同</li></ul><ul id="7c21da04-1ba3-4638-91da-750644dcb58c" class="bulleted-list"><li style="list-style-type:circle">同理，如果自定义类中有指针类型时，<strong><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">也要注意这点</a></strong></li></ul></li></ul><ul id="34bf017d-e706-4925-8335-89b2e3a8b755" class="bulleted-list"><li style="list-style-type:disc"><strong>默认析构函数</strong>：如果你<em><span style="border-bottom:0.05em solid">没有定义析构函数</span></em>，编译器会为你的类生成一个默认的析构函数。</li></ul><ul id="574929c1-540e-45f0-8358-390ede980407" class="bulleted-list"><li style="list-style-type:disc"><strong>默认移动构造函数</strong>：如果你没有定义移动构造函数（且<span style="border-bottom:0.05em solid"><em>没有定义拷贝构造函数</em></span>、<span style="border-bottom:0.05em solid"><em>拷贝赋值运算符</em></span>、<span style="border-bottom:0.05em solid"><em>析构函数</em></span>），编译器会为你的类生成一个默认的移动构造函数。</li></ul><ul id="3617222c-a041-4243-8a4c-7e70b2db67cc" class="bulleted-list"><li style="list-style-type:disc"><strong>默认移动赋值运算符</strong>：如果你没有定义移动赋值运算符（且<span style="border-bottom:0.05em solid"><em>没有定义拷贝构造函数</em></span>、<span style="border-bottom:0.05em solid"><em>拷贝赋值运算符</em></span>、<span style="border-bottom:0.05em solid"><em>析构函数</em></span>），编译器会为你的类生成一个默认的移动赋值运算符。</li></ul><p id="525a31bd-d974-4a70-9543-d8d14dff8855" class="">⚠️：如果定义了移动构造函数或移动赋值运算符，编译器不会自动生成默认的拷贝构造函数或拷贝赋值运算符。同样，如果定义了拷贝构造函数或拷贝赋值运算符，编译器不会自动生成默认的移动构造函数或移动赋值运算符。在这些情况下，你需要根据需要显式地定义这些函数。</p><h3 id="92ebcecb-e1ca-414a-a936-0f34d8556d29" class="block-color-blue_background">Rule of zero、Rule of five</h3><ul id="5822838d-3821-4ef1-8fba-943c57e92a88" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-red"><span style="border-bottom:0.05em solid"><em><strong>Rule of zero</strong></em></span></mark>，<span style="border-bottom:0.05em solid"><strong>尽量用默认构造</strong></span>：如果默认的构造函数、拷贝构造函数、拷贝赋值运算符能用，就不要自己定义<ul id="e4151973-96b6-4b38-8385-b1e03f373128" class="bulleted-list"><li style="list-style-type:circle">通常会通过= default关键字，<span style="border-bottom:0.05em solid"><strong>显式地使用默认的拷贝构造函数和拷贝赋值运算符</strong></span>（移动语义版和非移动语义版的），例如<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="e2e5ce6d-ee2b-4197-b6cb-f0b87a3fb6ce" class="code"><code class="language-C++">/*
 * Special member functions: we explicitly state that we want the default compiler-generated functions.
 * Here we are following the rule of zero. You should think about why that is correct.
 */
HashMapIterator(const HashMapIterator&lt;Map, IsConst&gt;&amp; rhs) = default;
HashMapIterator&lt;Map, IsConst&gt;&amp; operator=(const HashMapIterator&lt;Map, IsConst&gt;&amp; rhs) = default;

HashMapIterator(HashMapIterator&lt;Map, IsConst&gt;&amp;&amp; rhs) = default;
HashMapIterator&lt;Map, IsConst&gt;&amp; operator=(HashMapIterator&lt;Map, IsConst&gt;&amp;&amp; rhs) = default;</code></pre></li></ul></li></ul><ul id="b3cc3056-039e-4f7d-ad31-73e9586cf4de" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-red"><span style="border-bottom:0.05em solid"><em><strong>Rule of five</strong></em></span></mark>：<span style="border-bottom:0.05em solid"><strong>如果自定义了析构函数 or 拷贝构造函数 or 拷贝赋值运算符</strong></span>，就需要同时去构造移动拷贝构造函数和移动拷贝赋值运算符</li></ul><h3 id="2f61ed80-a561-4937-8756-6dc2e519ef24" class="block-color-blue_background">一个非常值得学习的case：CS106L HashMap(HashMap + HashMapIterator)</h3><figure id="6856f1d1-3669-4cca-951e-2bdfa8ad42ea"><div class="source"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/HashMap_Starter.zip">HashMap_Starter.zip</a></div></figure><p id="e97f0b4f-84af-4500-bc71-317c392cf4c0" class="">实现了一个与std兼容的unordered_map（兼容std中的各种算法），基于散列实现，一个vector表示一组散列桶，桶中的每个node通过链表进行连接</p><ul id="cefa612d-41eb-4cdc-ae39-762fe5a02326" class="bulleted-list"><li style="list-style-type:disc"><em><code><strong>hashmap_iterator.h</strong></code></em>：实现了hashmap的iterator，以下是<strong>几个值得学习的highlight</strong><ul id="2a492a68-51c5-4309-9f7b-d18ad739c42b" class="bulleted-list"><li style="list-style-type:circle"><mark class="highlight-purple"><strong>专门定义了一个给HashMap用的HashMapIterator类</strong></mark>，并<strong>通过</strong><em><code><strong>friend</strong></code></em><strong>关键字的</strong><strong><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">这个技巧</a></strong>，使得HashMap和HashMapIterator之间可以互相访问，从而将HashMapIterator与HashMap的代码剥离开来，<strong>使得HashMap的实现逻辑更加清晰，代码更容易维护</strong>。<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="545f1da5-1218-49df-acf0-30a85c7caf6c" class="code"><code class="language-C++">/* 通过模版参数来引用Map类型，使之可以friend
 * 注意：这里不能通过include Map的头文件，直接在HashMapIterator中friend Map类
 * 因为在Map类中也需要include HashMapIterator的头文件，这样就会导致相互include
 * 从而造成重复定义的编译错误。
 */
template &lt;typename Map, bool IsConst = true&gt; 
class HashMapIterator {

public:
    ...
    /*
     * Friend declarations so the HashMap class this iterator is for can access the attributes of its iterators.
     * Also, to make conversions between iterator and const_iterator easy, we declare the corresponding
     * iterator and const_iterators as friends.
     */
    friend Map;
    friend HashMapIterator&lt;Map, true&gt;;
    friend HashMapIterator&lt;Map, false&gt;;</code></pre></li></ul><ul id="f741d332-250e-45b3-9d66-f2acde283545" class="bulleted-list"><li style="list-style-type:circle"><strong><mark class="highlight-purple">通过模版，定义HashMapIterator的const与非const版本</mark></strong><mark class="highlight-default">（充分利用了模版编程的能力）</mark>，也就是说<strong>通过模版直接定义了const和非const两个类</strong>（而不像通常的做法那样<strong>，</strong>直接定义一个HashMapIterator类，然后分别实现所有方法的const和非const接口）<br/><br/><strong>利用模版直接实现const和非const两种类，可以</strong><span style="border-bottom:0.05em solid"><strong>使得代码看起来更加优雅，极大减少编码量</strong></span><blockquote id="f7e374ba-2c44-4917-8131-3e4a3325c50f" class="block-color-gray_background">例如，要实现一个operator++()运算符，正常情况下，要实现const和非const版本。<br/><br/>但如果通过模版来实现const和非const两种类，只需要实现对应的operator++即可（不需要写两个版本）：<br/><p id="09ca3cab-6cfa-4cc1-90d9-fbe4c1aead93" class=""><code>HashMapIterator&lt;Map, IsConst&gt;&amp; operator++(); </code></p></blockquote><ul id="ce5dda49-76f1-4909-9dc7-2999e6153aba" class="bulleted-list"><li style="list-style-type:square">通过<a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">非类型模版参数</a>给模版传递参数，从而构造const和非const的HashMapIterator类<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17f629e0-ff29-40e3-af76-92298dd99ed8" class="code"><code class="language-C++">template &lt;typename Map, bool IsConst = true&gt;
class HashMapIterator {
    ...
}</code></pre></li></ul><ul id="6ac707e8-a541-4a0c-b12c-832401602a4d" class="bulleted-list"><li style="list-style-type:square">在实现的过程中，<strong>通过</strong><code><em><strong><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">std::conditional_t</a></strong></em></code><strong>，根据模版中的</strong><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html"><strong>非类型模版参数</strong></a><strong>IsConst确定了类的数据类型</strong>（const还是非const），奠定了模版编程的基础<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="420c2e81-099f-4cbe-adc1-78c71663cc7f" class="code"><code class="language-C++">template &lt;typename Map, bool IsConst = true&gt;
class HashMapIterator {

public:
    using value_type = std::conditional_t&lt;IsConst, const typename Map::value_type, typename Map::value_type&gt;;
    // 注意：value_type的定义必须在编译时确定，因此不能使用运行时的if语句来决定value_type的类型
    // std::conditional_t是一个编译时条件类型选择工具，
    // 它根据模板参数IsConst的值在编译时选择const修饰的类型或非const类型作为value_type，
    // 从而实现在编译时根据条件选择类型。

    using pointer = value_type*;
    // 当IsConst=True时，pointer就是 const value_type*，
    // 即一个不能修改内容的指针（只读指针）
    using reference = value_type&amp;;
...</code></pre></li></ul></li></ul><ul id="3781b8c8-0f74-4b6f-8748-087cd1e50bfc" class="bulleted-list"><li style="list-style-type:circle">通过<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="b1eb47cf-3640-47e4-b644-64fc0d91ed72" class="code"><code class="language-C++">friend HashMapIterator&lt;Map, true&gt;; 
friend HashMapIterator&lt;Map, false&gt;;</code></pre><p id="23017e9f-11bc-4125-a888-d1bcbf32d0da" class="">使得const HashMapIterator和非const HashMapIterator之间可以相互访问</p></li></ul><ul id="0dd41207-1c9d-4327-acb7-34fdc0aa1876" class="bulleted-list"><li style="list-style-type:circle">通过<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="78439c29-113d-45df-a5c6-c44b7a58525a" class="code"><code class="language-C++">operator HashMapIterator&lt;Map, true&gt;() const {
    return HashMapIterator&lt;Map, true&gt;(_buckets_array, _node, _bucket);
}</code></pre><p id="58d77d62-8490-4845-9505-7fbe31e9db7b" class="">允许非const HashMapierator被转化为const版。<mark class="highlight-purple"><strong>使得后面实现const接口时可以复用非const接口的代码</strong></mark></p></li></ul><ul id="66c9512f-0dc5-4224-b2fb-1b08103e2fb2" class="bulleted-list"><li style="list-style-type:circle">通过<strong>友元函数+模版函数</strong>，实现了const版本和非const版本HashMapIterator之间的==和!=运算符（再次减少了代码量，优雅实现）<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="611baf63-5550-4e4c-9d80-71ce4727cd88" class="code"><code class="language-C++">// 这里只给出声明
// 注意：这里额外用了一个模版，提供了两个额外的模版类型，
// (使用的不是定义模版类时的模版类型Map和IsConst，而是Map_和IsConst_)
template &lt;typename Map_, bool IsConst_&gt;
friend bool operator==(const HashMapIterator&lt;Map_, IsConst_&gt;&amp; lhs, const HashMapIterator&lt;Map_, IsConst_&gt;&amp; rhs);

template &lt;typename Map_, bool IsConst_&gt;
friend bool operator!=(const HashMapIterator&lt;Map_, IsConst_&gt;&amp; lhs, const HashMapIterator&lt;Map_, IsConst_&gt;&amp; rhs);</code></pre></li></ul><ul id="c7fd4df0-f310-4685-90ff-1a9d976c9862" class="bulleted-list"><li style="list-style-type:circle">定义了一个<strong>private 构造函数</strong>，通过友元，<strong>只允许HashMap进行调用</strong><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="14313f8c-0b60-4c02-9ff2-fe396bc11445" class="code"><code class="language-C++">/*
 * Private constructor for a HashMapIterator.
 * Friend classes can access the private members of class it is friends with, 
 * so HashMap is able to call HashMapIterator&#x27;s private constructor 
 * (e.g, in begin()). We want the HashMapIterator constructor to be private 
 * so a client can&#x27;t randomly construct a HashMapIterator without asking for one 
 * through the HashMap&#x27;s interface.
 */
HashMapIterator(bucket_array_type* buckets_array, node* node, size_t bucket);</code></pre></li></ul></li></ul><ul id="8eddf1cf-14a9-486c-9109-b7ae5da6e157" class="bulleted-list"><li style="list-style-type:disc"><code><em><strong>hashmap.{h,cpp}</strong></em></code>：声明和部分实现了HashMap<ul id="874da1a0-72fb-48d9-bb45-2d13b9b44155" class="bulleted-list"><li style="list-style-type:circle">map的value_type中，定义了一个pair&lt;const K,M&gt;中的<strong>K必须是const的</strong><figure id="5fc307ee-d2ff-476b-bf29-a108bf35bde7" class="image"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-02-18_13.53.36.png"><img style="width:384px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-02-18_13.53.36.png"/></a></figure></li></ul><ul id="e41a2c4c-00e6-4c1b-9be0-ef01ac8fba5a" class="bulleted-list"><li style="list-style-type:circle">定义了一个debug成员函数，会打印hashmap的所有结点的key和value，并且打印当前桶的个数，以及负载系数，在<span style="border-bottom:0.05em solid"><strong>debug时很好用</strong></span>.<figure id="12bcdd68-8697-488b-ab32-8d2ee6200562" class="image"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-02-19_20.10.13.png"><img style="width:432px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-02-19_20.10.13.png"/></a><figcaption>启示：在构建一个复杂系统时，最好能给自己做一些debug用的工具，反而能大大提高效率</figcaption></figure></li></ul><ul id="04d2ab96-b77f-4e8b-a457-4403b3a2e121" class="bulleted-list"><li style="list-style-type:circle">通过模版定义了一个Range 构造函数（模版函数），使得HashMap可以接收一个value_type为pair的container来进行HashMap的构造，<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="27591a79-0047-4265-a7ee-4ce637d17ede" class="code"><code class="language-C++">
/*
 * Range constructor
 * Creates a HashMap with the elements in the range [first, last).
 *
 * Requirements: InputIt must be iterators to a container whose elements are pair&lt;K, M&gt;.
 *
 * Usage:
 *      std::vector&lt;std::pair&lt;char, int&gt;&gt; vec {{&#x27;a&#x27;, 3}, {&#x27;b&#x27;, 5}, {&#x27;c&#x27;, 7}};
 *      HashMap&lt;char, int&gt; map{vec.begin(), vec.end()};
 *
 * Complexity: O(N), where N = std::distance(first, last);
 */
template &lt;typename InputIt&gt;
HashMap(InputIt first, InputIt last, size_t bucket_count = kDefaultBuckets, const H&amp; hash = H());</code></pre></li></ul><ul id="f4a08d67-7fd4-4878-bdca-4a2f8d5bb198" class="bulleted-list"><li style="list-style-type:circle">专门在private域中定义了一个辅助函数find_node以及辅助数据结构node_pair，其中<strong>node_pair会存找到的那个node以及这个node之前的那个node</strong>，从而可以<strong>方便很多成员函数的实现</strong><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="acafb27c-c377-4f43-a186-e250521177b9" class="code"><code class="language-C++">/*
 * Finds the node N with given key, and returns a node_pair consisting of
 * the node whose&#x27;s next is N, and N. If node is not found, {nullptr, nullptr}
 * is returned. If node found is the first in the list, {nullptr, node} is returned.
 *
 * Example given list: front -&gt; [A] -&gt; [B] -&gt; [C] -&gt; /
 * where A, B, C, D are pointers, then
 *
 * find_node(A_key) = {nullptr, A}
 * find_node(B_key) = {A, B}
 * find_node(C_key) = {B, C}
 * find_node(D_key) = {nullptr, nullptr}
 *
 * Usage:
 *      auto&amp; [prev, curr] = find_node(3);
 *      if (prev == nullptr) { ... }
 *
 * Complexity: O(1) amortized average case, O(N) worst case, N = number of elements
 *
 * Notes: this function is necessary because when erasing, we need to change the
 * next pointer of the node before the one we are erasing.
 */

node_pair find_node(const K&amp; key) const;</code></pre></li></ul><ul id="74e39171-b775-48cd-a2de-7c1b7c72c549" class="bulleted-list"><li style="list-style-type:circle">专门在private域中定义了一个辅助函数<em><code>size_t first_not_empty_bucket() const;</code></em>用于找hashmap中第一个非空的桶</li></ul><ul id="f8a90cc1-8b46-4235-a455-28554e9b4ea4" class="bulleted-list"><li style="list-style-type:circle">专门在private域中定义了一个辅助函数<code><em>iterator make_iterator(node* curr) const;</em></code>，用于为一个node创建一个指向它的iterator</li></ul><ul id="5ab53bab-b1ce-4388-a3ff-ffecc9f9ab31" class="bulleted-list"><li style="list-style-type:circle">通过<a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">std::const_cast</a>来<a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">轻松实现const接口</a></li></ul><ul id="0f52f94e-15e6-4fa5-85b6-8239f9e623a2" class="bulleted-list"><li style="list-style-type:circle">通过一个range constructor作为<a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">委托构造函数</a>来实现<a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">初始化器列表构造函数</a></li></ul><ul id="511bce8b-71d5-4331-900f-2f6c5ae11b6c" class="bulleted-list"><li style="list-style-type:circle">通过insert成员函数来实现operator[]（因为insert的第一步就是要查找，所以代码可以复用）<ul id="a9d93125-ab92-47a8-8744-040d89b8c8f4" class="bulleted-list"><li style="list-style-type:square">这里用到了<a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">一个pair的初始化技巧</a></li></ul></li></ul></li></ul><h2 id="3c22d164-c4a6-4f80-946c-cc28738b75d5" class="block-color-orange_background">类进阶：友元、运算符重载</h2><ul id="e124ba21-e9d7-483c-a717-7d708bb95309" class="bulleted-list"><li style="list-style-type:disc">在C++中，通常类外的代码无法访问类内的private成员，而友元就是用来解除这样的限制的（关键字<strong><code>friend</code></strong>）<figure id="5b1507f2-d4af-4106-a9f7-cc5ec7e2013e"><a href="https://zhuanlan.zhihu.com/p/158805900" class="bookmark source"><div class="bookmark-info"><div class="bookmark-text"><div class="bookmark-title">C++的友元函数和友元类</div><div class="bookmark-description">C++使用类对数据进行隐藏和封装，类的数据成员一般定义为私有成员，而将提供类与外界通讯接口的成员函数定义为公有的。 C++类成员的三种访问权限： public：可以被该类中的函数、子类的函数、友元函数访问，也可以…</div></div><div class="bookmark-href"><img src="https://static.zhihu.com/heifetz/assets/apple-touch-icon-152.81060cab.png" class="icon bookmark-icon"/>https://zhuanlan.zhihu.com/p/158805900</div></div></a></figure><ul id="2871a802-8102-49b2-b459-183d47b167f1" class="bulleted-list"><li style="list-style-type:circle"><span style="border-bottom:0.05em solid"><strong>友元函数</strong></span>使得一个外部定义的函数可以访问某个类的private成员：有时需要定义一些函数，这些函数不是类的一部分，但又需要频繁访问类的私有（private）成员和保护（protected）成员，这时可以将这些函数定义为友元函数。<figure id="a35d2e6f-64de-4734-a691-85ab15c53577" class="image" style="text-align:center"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-01-19_14.48.02.png"><img style="width:432px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-01-19_14.48.02.png"/></a><figcaption>注意这里的用法：在类的public中<span style="border-bottom:0.05em solid"><strong>声明</strong></span>一个友元函数（所以要写出函数的原型）</figcaption></figure><blockquote id="bf751a63-c9e5-4a25-b6c5-a9b40a77278c" class="block-color-gray_background">⚠️：尽管友元函数在类的声明中出现过，但<span style="border-bottom:0.05em solid"><strong>其并不是类的成员函数</strong></span>。</blockquote></li></ul><ul id="34a4988d-926c-42c6-b566-4067ac78353a" class="bulleted-list"><li style="list-style-type:circle"><span style="border-bottom:0.05em solid"><strong>友元类</strong></span>使得一个类实例可以访问另一个类实例的private成员</li></ul></li></ul><ul id="db44b5f5-bbca-4a53-8f5b-f13fbe770b49" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>一种友元friend的常见场景</strong></span>：假如一个类需要用到另一个类，但是另一个类很复杂（比如一个容器类会用到一个迭代器类），那么此时就可以考虑把这个迭代器类拿出去实现，然后在容器类和迭代器类中分别friend 对方这个类，使得容器类和迭代器类可以互相访问，从而把迭代器类从容器类的实现中剥离开，从而使代码的逻辑结构更加清晰。<blockquote id="f0ffffcc-79d3-4021-ad1e-434b818f32a8" class="block-color-gray_background">以一个Map container和对应的MapIterator为例： </blockquote></li></ul><ul id="d3aa27c3-2351-4db0-9b13-8e8296e79c7f" class="bulleted-list"><li style="list-style-type:disc">在类中声明一个友元函数时，这个<mark class="highlight-purple"><span style="border-bottom:0.05em solid"><strong>友元函数还可以是一个模版函数</strong></span></mark><ul id="fd15acd7-969f-4569-be1e-5aa60c679eba" class="bulleted-list"><li style="list-style-type:circle"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">code example</a></li></ul></li></ul><ul id="284ab6c8-b35d-4c59-ba06-4723cc229122" class="bulleted-list"><li style="list-style-type:disc"><strong><code>friend</code></strong>关键字<mark class="highlight-purple"><span style="border-bottom:0.05em solid"><strong>本质上就是为外部的函数或外部的类提供了一种可以访问当前类private域的途径</strong></span></mark>，并且这个函数<span style="border-bottom:0.05em solid">不会作为类的成员函数</span><ul id="04f3f8bb-d91f-41db-bf33-eb5d9198f3c9" class="bulleted-list"><li style="list-style-type:circle">⚠️：虽然friend一个外部函数或friend一个外部类是在类的public域中进行声明的，<strong>但是这些外部函数和外部类并不是类的成员函数和成员变量。</strong></li></ul><ul id="074c5fb9-f897-49cb-8d2c-d71925eedd1b" class="bulleted-list"><li style="list-style-type:circle">所以，如果没有<strong><code>friend</code></strong>关键字，那么在类中声明的函数都将被视为类的成员函数</li></ul></li></ul><ul id="671a4658-da98-447d-b5ea-efb576d6b374" class="bulleted-list"><li style="list-style-type:disc">C++中为各类运算符(如<code>-</code>，<code>&lt;</code>，<code>&gt;</code>，<code>*</code>，<code>&lt;&lt;</code>，<code>&gt;&gt;</code>，<code>[]</code>)实现了<span style="border-bottom:0.05em solid"><strong>语法糖</strong></span>，以运算符<code>+</code>为例（其它运算符如<code>+=</code>，<code>-</code>，<code>&lt;</code>，<code>&gt;</code>，<code>*</code>，<code>&lt;&lt;</code>，<code>&gt;&gt;</code>，<code>[]</code>同样适用），<span style="border-bottom:0.05em solid"><strong>当代码中执行</strong></span><span style="border-bottom:0.05em solid"><strong><code>x + y</code></strong></span><span style="border-bottom:0.05em solid"><strong>时，编译器做的事情</strong></span>：（理解这个流程很重要）<ol type="1" id="e648a224-fe8d-4fac-bc6b-c77813a102a4" class="numbered-list" start="1"><li><strong>查找当前作用域中的</strong><code><strong>operator+</strong></code><strong>函数</strong>：首先，编译器会查找是否存在合适<code><strong>operator+</strong></code>函数（包括全局函数和友元函数）。它会考虑所有可见的重载版本，并根据参数类型（在这个例子中是 <code><strong>x</strong></code> 和 <code><strong>y</strong></code> 的类型）来选择最合适的版本。<br/>如果找到了，<br/><strong><code>x + y</code></strong><strong>就会被转化为</strong><strong><code>operator+(x, y)</code></strong>（语法糖）</li></ol><ol type="1" id="36a1d0d8-6250-4463-9bd8-a9ea970c8263" class="numbered-list" start="2"><li> <strong>查找</strong><code><strong>x</strong></code><strong>的成员函数</strong>：如果没有找到合适的<code><strong>operator+</strong></code>函数，编译器接着会查找对象<code><strong>x</strong></code>是否定义了成员函数<code><strong>operator+</strong></code>。这意味着编译器会检查 <code><strong>x</strong></code> 的类定义中是否有一个接受类型类似于 <code><strong>y</strong></code> 的参数的 <code><strong>operator+</strong></code>。<br/>如果找到了并且类型也配对，<br/><strong><code>x + y</code></strong><strong>就会被转化为</strong><strong><code>x.operator+(y)</code></strong>（语法糖）</li></ol><p id="5a457b40-3fe8-4862-847d-52eefdb4c67b" class="">如果前2步都失败了，则会发生编译错误</p></li></ul><ul id="705a8fe4-a204-45bc-bf29-76b545aff7d5" class="bulleted-list"><li style="list-style-type:disc">因此，当对一个对象使用运算符<strong><code>+</code></strong>时，例如<code>obj+1</code>，实际上相当于调用了obj的成员函数<code>operator+</code>（<strong>假设上下文中没有定义函数</strong><strong><code>operator+</code></strong>），此时<code>obj+1</code>会被编译器解释成<code>obj.operator+(1)</code><p id="de158076-0d93-4a6a-b745-f0ae6ee0cfdd" class="">导致的问题：<strong>必须要求运算符</strong><strong><code>+</code></strong><strong>的左侧运算符是一个类实例</strong>，例如：</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="9c737a28-5b23-43b8-9651-b2dc0788ad38" class="code"><code class="language-C++">class Complex {
public:
    int real;
    int imag;

    Complex(int r, int i) : real(r), imag(i) {}

    // 成员函数重载：处理 Complex + int
    Complex operator+(int value) {
        return Complex(real + value, imag);
    }
    // 只能做Compelx + int（相当于是Complex.operator+(int)），
    // 不能做int + Complex
};</code></pre><ul id="e524bec3-02ae-4890-9018-784cadb317b7" class="bulleted-list"><li style="list-style-type:circle"><span style="border-bottom:0.05em solid"><strong>解决方法</strong></span>：<strong>定义一个外部函数</strong><strong><code>operator+</code></strong>，从而在进行<code>x + y</code>时，在<strong><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">第一步中</a></strong>可以让编译器将其转化为<code><strong>operator+(x, y)</strong></code><blockquote id="b4c82535-c426-4588-800d-90b6c34fc4f7" class="block-color-gray_background">简单来说就是：避免让编译器把<code>x + y</code>转化为<code>x.operator+(y)</code>，而是转化为调用外部的<code>operator+(x, y)</code>这个函数，<strong>当外部函数需要访问这个类的private域时，可以通过</strong><strong><em><code>friend</code></em></strong><strong>这个外部函数来解决</strong>。</blockquote><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="8364933a-276a-4a4a-a9d9-3d8937118737" class="code"><code class="language-C++">class Complex {
public:
    int real;
    int imag;

    Complex(int r, int i) : real(r), imag(i) {}
};

Complex operator+(int value, Complex x) {
    return Complex(value + x.real, x.imag);
}

Complex operator+(Complex x, int value) {
    return Complex(value + x.real, x.imag);
}

int main() {
    Complex obj1 = Complex(100, 99999);
	  Complex obj2 = obj1 + 10;    // 编译通过
	  Complex obj3 = 100 + obj1;   // 编译通过
	  return 0;
}</code></pre><ul id="cceeb7d2-2283-4715-9ef8-aba329043900" class="bulleted-list"><li style="list-style-type:square"><code>obj1+10</code>会被编译器转化为调用<code>operator+(obj1, 10)</code></li></ul><ul id="b406fa7a-77de-4dc9-b73e-3ecd96664f3f" class="bulleted-list"><li style="list-style-type:square"><code>10+obj1</code>会被编译器转化为调用<code>operator+(10, obj1)</code></li></ul><ul id="f5625c3f-c61c-4518-a17e-f84f77e1c9ac" class="bulleted-list"><li style="list-style-type:square">直接在全局范围定义了一个函数operator+，编译器会自动根据参数类型进行重载</li></ul><ul id="2aaa4983-6f71-4292-b1e1-31860c984d92" class="bulleted-list"><li style="list-style-type:square"><strong>如果这个函数operator+需要访问这个类的private域，就需要在这个类中friend operator+</strong></li></ul></li></ul></li></ul><ul id="5a7656a0-3afd-4329-8681-1502c48bf069" class="bulleted-list"><li style="list-style-type:disc">注意点：<strong>在类中声明的友元函数不能用</strong><strong><code>const</code></strong><strong>来修饰函数</strong>（因为友元函数不是类的成员函数，所以它不存在实例的概念）</li></ul><h2 id="dd243657-3fdd-4348-9db8-937dd4b104d6" class="block-color-orange_background">类进阶：虚函数 、动态绑定(实现多态)</h2><ul id="28b4a44d-d17f-439b-bb4d-94fe4ee55196" class="bulleted-list"><li style="list-style-type:disc">虚函数用来定义类的成员函数（用<strong><code>virtual</code></strong>关键字修饰），用<code>virtual</code>来修饰一个成员函数时，<mark class="highlight-purple"><strong>表示我们希望在子类中重写这个方法</strong></mark><p id="0d1bcc36-0f96-48d9-a1c5-8ac8dec42fae" class="">在类中使用<code>virtual</code>关键字修饰的成员函数，可以实现<mark class="highlight-purple"><span style="border-bottom:0.05em solid"><strong>动态绑定</strong></span></mark></p><blockquote id="2ed4796a-0ed4-4f5b-b81a-d62b60eb0d12" class="block-color-gray_background"><span style="border-bottom:0.05em solid"><strong>动态绑定</strong></span>：当<mark class="highlight-red"><strong>通过基类的指针或引用</strong></mark>调用虚函数时，将<mark class="highlight-purple"><strong>根据对象的实际类型来决定调用哪个版本的函数</strong></mark>。这种机制被称为动态绑定或晚期绑定。<br/>⚠️：当我们定义了<br/><strong>一个基类的指针</strong>并<strong>指向一个子类</strong>时，调用这个指针对应对象的方法时，它不会调用子类的方法，而是基类的方法，虚函数就是用来解决这个问题的。<br/>⚠️：<br/><strong>在cpp中，通常通过虚函数+定义一个指向子类的基类指针，来实现</strong><mark class="highlight-purple"><span style="border-bottom:0.05em solid"><strong>多态</strong></span></mark>。</blockquote><ul id="c2f893cb-d40f-4ecb-b230-69fab4deb5f4" class="bulleted-list"><li style="list-style-type:circle">没有<code>virtual</code>关键字修饰show时：<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="4f2e31e2-679b-4724-81ee-003cf04b2bbf" class="code"><code class="language-C++">class Base {
public:
    void show() {
        std::cout &lt;&lt; &quot;In Base&quot; &lt;&lt; std::endl;
    }
};

class Derived : public Base {
public:
    void show() { 
        std::cout &lt;&lt; &quot;In Derived&quot; &lt;&lt; std::endl;
    }
};

int main(){
	// 定义一个基类的指针指向一个子类（这种写法在需要实现多态的场景中很常见）
	Base* b = new Derived();  
	b-&gt;show();  // 将输出 &quot;In Base&quot;（用的是基类的show）
}</code></pre></li></ul><ul id="8054e659-ae36-4e30-b3a2-65705b62d80c" class="bulleted-list"><li style="list-style-type:circle">有<code>virtual</code>关键字修饰show时：<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="e0bb011f-0d85-456a-a109-4dea29bbd75b" class="code"><code class="language-C++">class Base {
public:
    virtual void show() {
        std::cout &lt;&lt; &quot;In Base&quot; &lt;&lt; std::endl;
    }
};

class Derived : public Base {
public:
    void show() override{  // &#x27;override&#x27; 是可选的，但推荐用于明确表示重写
        std::cout &lt;&lt; &quot;In Derived&quot; &lt;&lt; std::endl;
    }
};

int main(){
	Base* b = new Derived();
	b-&gt;show();  // 将输出 &quot;In Derived&quot;（用的是子类的show）,实现了多态
	return 0;
}</code></pre><ul id="1a79c55e-0288-433f-bdca-0bb9fa685862" class="bulleted-list"><li style="list-style-type:square">有<code>virtual</code>关键字修饰时，在子类中重写时使用<code>override</code>来修饰重写的虚函数</li></ul></li></ul></li></ul><ul id="2cd3aaa6-7630-4e9b-817f-6d1163a37375" class="bulleted-list"><li style="list-style-type:disc">使用虚函数的一个<span style="border-bottom:0.05em solid"><strong>注意点</strong></span>：<strong>如果一个类有虚函数，通常应该将析构函数也声明为虚函数</strong>。因为在多态使用场景中，可能会通过基类的指针来删除派生类的对象。如果析构函数不是虚的，这样做将不会调用派生类的析构函数，可能导致资源泄露或其他问题。<p id="769b7e84-c0cf-4506-b1bc-41eaa81d1ba0" class="">考虑以下场景：</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="87faad82-9bd2-4be3-af48-de4e103ac50a" class="code"><code class="language-C++">class Base {
public:
    virtual void doSomething() {
        // 基类的定义
    }

    // 非虚析构函数
    ~Base() {
        std::cout &lt;&lt; &quot;Base Destructor&quot; &lt;&lt; std::endl;
    }
};

class Derived : public Base {
public:
    void doSomething() override {
        // 派生类的定义
    }

    ~Derived() {
        std::cout &lt;&lt; &quot;Derived Destructor&quot; &lt;&lt; std::endl;
    }
};

int main() {
    Base* b = new Derived();
    delete b; // 输出：Base Destructor
}</code></pre><blockquote id="582f5b08-b558-4f88-915f-423b82bcd778" class="block-color-gray_background">在这个场景中，用Base* 来修饰b并调用delete b后，由于基函数的析构函数不是<code>virtual</code>类型，所以调用析构函数时，用的是基类的析构函数（而不是子类的析构函数），从而有可能会在某些场景中导致内存泄漏<br/><br/>所以正确的做法是将基函数中的析构函数也用virtual来定义为虚函数类型:<br/><p id="24b689ea-f63d-4f26-81cc-c404ed5065ea" class="">virtual ~Base() {<br/>std::cout &lt;&lt; &quot;Base Destructor&quot; &lt;&lt; std::endl;<br/>}<br/></p></blockquote></li></ul><ul id="7e12801f-70b9-40e2-8f9d-d818e310ecdf" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-red"><span style="border-bottom:0.05em solid"><strong>纯虚函数</strong></span></mark>和<mark class="highlight-red"><span style="border-bottom:0.05em solid"><strong>抽象基类</strong></span></mark><p id="06a7a54d-9708-4ce3-9418-84c88b1721f8" class=""><strong>纯虚函数</strong>：纯虚函数是在基类中<mark class="highlight-purple"><span style="border-bottom:0.05em solid"><strong>只声明但不定义的虚函数</strong></span></mark><strong>，</strong>通过<strong>在函数声明的末尾添加</strong><strong><code>=0</code></strong><strong>来指定</strong>。纯虚函数的存在意味着<strong>派生类必须提供该函数的实现</strong>。这使得基类定义了一个接口，而具体的实现则留给了派生类。</p><p id="f32de8e2-f1c8-43e5-996f-6e7f916e3537" class=""><strong>抽象基类</strong>：抽象基类是指<strong>至少包含一个纯虚函数的类</strong>。因为它包含未实现的纯虚函数，<strong>所以不能直接实例化</strong>。</p><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="61d6eda5-e798-4cd6-b9aa-dee2e57b75a2" class="code"><code class="language-C++">class Base {
public:
    virtual void someFunction() = 0;  // 纯虚函数
};

class Derived : public Base {
public:
    void someFunction() override {
        // 实现基类中的纯虚函数
    }
};</code></pre></li></ul><h2 id="cebf9ae0-16ae-4e18-86ae-f90319ccf300" class="block-color-orange_background">模版类</h2><h3 id="c7ab2a26-fe9b-4636-b50e-b5b46b786e99" class="block-color-blue_background">模版类的声明的定义要写到一起</h3><ul id="2e2eb5c4-8693-4e15-8bd6-02efce3bb7f1" class="bulleted-list"><li style="list-style-type:disc">在C++中实现<span style="border-bottom:0.05em solid"><strong>模版类</strong></span>时，如果在.h文件中写模版类的声明，在.cpp文件中写出对应的定义，那么<mark class="highlight-red"><span style="border-bottom:0.05em solid"><strong>必须也在.h中#include对应的.cpp文件（而且要写在最后）</strong></span></mark><ul id="ae2dec6d-2191-406f-97bd-55e5a29c7a7d" class="bulleted-list"><li style="list-style-type:circle">但还是建议：<mark class="highlight-purple"><strong>对于模版类\函数，直接把声明和定义写在一个.h文件里</strong></mark><mark class="highlight-default">；<br/><br/></mark><mark class="highlight-purple"><strong>或者把定义写在一个.tpp</strong></mark><mark class="highlight-default">（注意，</mark><mark class="highlight-red"><strong>模版类\函数 的定义放在.tpp而不是.cpp</strong></mark><mark class="highlight-default">），</mark><span style="border-bottom:0.05em solid"><strong><mark class="highlight-default">然后在.h的最后#include .tpp</mark></strong></span><mark class="highlight-default">，并把这个</mark><mark class="highlight-purple"><strong>.tpp文件放在与.h文件相同的目录下</strong></mark><strong><br/>（在.h的最后#include .tpp本质上与直接写在.h里面是等价的）<br/></strong></li></ul><figure id="1446d6aa-9bb7-4a95-94e5-105b04b9f786" class="image" style="text-align:center"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2023-11-29_16.46.32.png"><img style="width:336px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2023-11-29_16.46.32.png"/></a></figure><blockquote id="bcf3e1bf-2ccd-434d-b0b1-88578e904d44" class="block-color-gray_background">模板的声明及其定义（实现）<mark class="highlight-purple"><span style="border-bottom:0.05em solid"><strong>需要在编译时对每个用到的类型可见，这样编译器才能为每个类型实例化模板</strong></span></mark>。<br/>⚠️：这一点对于模版类和模版函数都是一样的<br/><br/>例如，Myclass 类模板的声明在<br/><strong><code>myclass.h</code></strong>中，而对应的定义写在 <code><strong>myclass.cpp</strong></code> 文件中，<strong><code>main.cpp</code></strong>中#include了myclass.h，并对模版进行了实例化<strong><code>myclass&lt;int&gt;</code></strong>。<br/><br/>生成可执行文件的过程：根据main.cpp生成可链接文件f1，根据myclass.cpp生成可链接文件f2，最后把f1，f2链接起来得到可执行文件x。<br/><br/>报错：<br/><code>main.cpp</code><span style="border-bottom:0.05em solid"><strong>链接时出现未定义符号错误</strong></span>，因为编译器在编译 <code><strong>main.cpp</strong></code> 时无法访问 <code><strong>TalkyVec&lt;int&gt;</strong></code> 的定义。<br/><br/><mark class="highlight-purple"><strong><br/>所以必须要在myclass.h的最后#include&lt;myclass.cpp&gt;<br/><br/></strong></mark>这样做本质上就相当于直接将对应的定义写在了声明的后面，<mark class="highlight-red"><span style="border-bottom:0.05em solid"><strong>因此在编译链接时不需要编译链接.cpp文件</strong></span></mark>（否则会引发重复定义的报错）<figure id="1a4ae822-91fe-4450-8f81-aae607964d24" class="image"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-01-24_01.24.35.png"><img style="width:288px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-01-24_01.24.35.png"/></a></figure></blockquote></li></ul><h3 id="0a3426cf-d1a2-488c-95ab-1808efa036d7" class="block-color-blue_background">模版类的声明和定义的具体写法</h3><figure id="f44ab652-359e-41c6-bbe7-e02adc06383e" class="image" style="text-align:center"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2023-11-29_21.19.31.png"><img style="width:528px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2023-11-29_21.19.31.png"/></a></figure><div id="ac66e54b-ce1f-4621-a9e5-8bd02cd24cd1" class="column-list"><div id="8656f22e-5c8e-4925-980e-1711d581f093" style="width:43.75%" class="column"><ul id="ccf4c820-a450-4337-bb05-914ef29732d9" class="bulleted-list"><li style="list-style-type:disc">TalkyVec.h：<mark class="highlight-purple"><strong>模版类的声明</strong></mark><figure id="3c643c0a-b7f8-4365-8d14-1e0f12c14373" class="image"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-01-24_16.30.39.png"><img style="width:1156px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-01-24_16.30.39.png"/></a><figcaption>在最后记得#include “./TalkyVec.tpp”</figcaption></figure><ul id="506f9769-ac7a-4fd9-a841-28f75a0ac45e" class="bulleted-list"><li style="list-style-type:circle">声明时，<span style="border-bottom:0.05em solid"><strong>参数直接用TalkyVec来修饰</strong></span>，而不是TalkyVec&lt;ValueType&gt;</li></ul></li></ul><p id="e04a03cd-bb65-4cff-ad2b-6cc5e2c85aa8" class="">
</p></div><div id="6244a698-8db6-46db-9215-8c6a5e930f02" style="width:56.25%" class="column"><ul id="aaf693b5-4e88-47c6-9d9e-3162804465fc" class="bulleted-list"><li style="list-style-type:disc">TalkyVec.tpp：<mark class="highlight-purple"><strong>模版类的定义</strong></mark><figure id="aceebade-dd72-4e57-9100-339ffc6aee19" class="image"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-01-24_16.12.03.png"><img style="width:1570px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-01-24_16.12.03.png"/></a></figure><ul id="68c19450-187b-4d7d-bce8-267dcf14ce3f" class="bulleted-list"><li style="list-style-type:circle">模版类的定义文件<strong>放在与声明头文件相同的目录里</strong>，并且<strong>后缀名为.tpp</strong></li></ul><ul id="ebbfe4be-4969-4b5d-b118-3803dd7a00e8" class="bulleted-list"><li style="list-style-type:circle">定义时同样要先在第一行使用tempalte&lt;typename …&gt;，然后<span style="border-bottom:0.05em solid"><strong>通过TalkyVec&lt;ValueType&gt;::来定义模版化后的类方法</strong></span></li></ul><ul id="ffdbb2e2-2db3-4ef0-aaf3-880abc797f40" class="bulleted-list"><li style="list-style-type:circle">如果要用模版类声明的数据类型，记得加上修饰符<strong><code>typename</code></strong><strong><br/><br/></strong>例如这里通过typename TalkyVec&lt;ValueType&gt;::size_type 定义了模版类中size方法的返回类型</li></ul><ul id="921b4f35-cb66-4511-95be-1b7788b21106" class="bulleted-list"><li style="list-style-type:circle"><strong>假如在类函数定义中，参数类型需要引用模版类声明的数据类型，那么就不需要通过<br/>TalkyVec&lt;ValueType&gt;::来进行访问<br/></strong>，因为编译器已经在访问模版类的函数名时，就知道了模版类的作用域，所以也就知道这个数据类型时在这个模版类中进行了定义</li></ul></li></ul></div></div><h3 id="3527c4dd-5b4f-4226-a791-3435ccbf18db" class="block-color-blue_background">模版中的类型可以有默认类型、实例化模版时加入const</h3><ul id="d95dc2c0-db02-4c40-a5e2-ebfa282bf301" class="bulleted-list"><li style="list-style-type:disc">可以<span style="border-bottom:0.05em solid"><strong>给模版定一个默认的类型</strong></span>，<span style="border-bottom:0.05em solid"><strong>也可以规定模版的类型</strong></span>，例如<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="0a441dcb-d28c-4991-a0aa-8686bd099e47" class="code"><code class="language-C++">template &lt;typename foo, typename bar = bool&gt;</code></pre></li></ul><ul id="3af5d575-9b92-4459-8259-e0b04566dcd9" class="bulleted-list"><li style="list-style-type:disc"><strong>实例化模版时，模版中的参数也可以使用</strong><strong><code>const</code></strong><strong>关键字来修饰</strong>，例如<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="3526913d-c258-44b9-a1ad-3dc3d7fbaf94" class="code"><code class="language-C++">using value_type = std::pair&lt;const K, M&gt;;</code></pre></li></ul><h3 id="c2b4d5a5-e033-4aec-ba01-62f363075fc9" class="block-color-blue_background">非类型模版参数</h3><ul id="8b050642-46ea-44fa-bea6-47ae73391a3d" class="bulleted-list"><li style="list-style-type:disc"><strong><mark class="highlight-red">非类型模版参数</mark></strong>：非类型模板参数允许模板具体化时<strong>传递一个值而不是类型</strong>，而且这个值也可以有默认值</li></ul><ul id="375648fa-d61a-4797-90df-970f16cc807e" class="bulleted-list"><li style="list-style-type:disc">一个case<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="e9e58cfa-9694-4417-b5aa-27cfb62e3448" class="code"><code class="language-C++">	template &lt;typename foo, typename bar = bool, int buz, bool foobar = true&gt;

// 这里的buz和foobar就是非类型模版参数，其中foobar还有默认值</code></pre></li></ul><ul id="325f0693-2232-4660-af83-549149451f41" class="bulleted-list"><li style="list-style-type:disc">⚠️：C++标准对于<span style="border-bottom:0.05em solid"><strong>非类型模板参数的类型有明确的限制</strong></span>，这些限制<strong>确保模板参数在编译时是完全确定</strong>的，以便模板可以根据这些参数进行实例化。（因此像std中很多动态类型的容器就无法作为非类型模版参数传给模版）<blockquote id="6076656e-ac4f-4e4f-adc0-8e90611885fd" class="block-color-gray_background">例如，非模版类型参数不能是<em>std::string</em>，因为<em>std::string</em>作为一个动态内存管理的类类型，不符合非类型模板参数的要求，因为它无法在编译时就是完全确定的，</blockquote><ul id="bfec8500-d18b-4ad5-a9bc-f0bba48726f6" class="bulleted-list"><li style="list-style-type:circle">截至C++20标准，允许以下类型作为非类型模板参数：<ul id="1d1e496a-00b3-4fc0-9c32-fb32cd159e18" class="bulleted-list"><li style="list-style-type:square">整型、布尔型、枚举类型</li></ul><ul id="8081f488-1390-435c-a20e-4ce7402dd2df" class="bulleted-list"><li style="list-style-type:square">指针类型（包括函数指针和成员指针）</li></ul><ul id="84c204de-a57d-419f-a9fc-75b54d967850" class="bulleted-list"><li style="list-style-type:square">引用类型</li></ul><ul id="a72e3d97-0417-4cc9-9976-f044f54431ed" class="bulleted-list"><li style="list-style-type:square"><em>std::nullptr_t</em>：专门表示空指针字面量<em>nullptr</em>对应的类型。</li></ul><ul id="e4868962-2c3e-42f5-84c9-7a772bfaaccc" class="bulleted-list"><li style="list-style-type:square">从C++20开始，允许字面值常量类类型（满足certain conditions，如有常量表达式构造函数、析构函数是平凡的等）</li></ul><ul id="a48f177e-ff52-4757-9880-3b42e2f00354" class="bulleted-list"><li style="list-style-type:square">从C++20开始，允许浮点和其他字面值类型（符合相同的条件）</li></ul></li></ul></li></ul><h3 id="87ceba30-68d0-4bd1-8d71-bc57efa83128" class="block-color-blue_background">在模版类中定义一个成员模版函数（易混淆）</h3><ul id="998e8e96-e24d-4027-861a-5b968408da39" class="bulleted-list"><li style="list-style-type:disc">C++还允许<mark class="highlight-purple"><strong>在模版类中定义一个成员模版函数</strong></mark>（一个常见的场景就是定义一个<span style="border-bottom:0.05em solid"><strong>模版构造函数</strong></span>）<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="6272e2af-a541-4008-ab5a-71d93ea6ded1" class="code"><code class="language-C++">template &lt;typename K, typename M, typename H&gt;
template &lt;typename InputIt&gt;
HashMap&lt;K, M, H&gt;::HashMap(InputIt first, InputIt last, size_t bucket_count, const H&amp; hash) :
   HashMap(bucket_count, hash) {
   for (auto iter = first; iter != last; ++iter) {
      insert(*iter);
   }
}</code></pre><ul id="7f9874ce-b218-492b-ac1d-7b3b5e49e2f3" class="bulleted-list"><li style="list-style-type:circle"><span style="border-bottom:0.05em solid"><strong>注意与以下代码进行区分</strong></span>，以下代码是定义了一个模版为四个类型的模版类<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="eb69801a-21f2-4052-8790-7475a56ff5ad" class="code"><code class="language-C++">template &lt;typename K, typename M, typename H, typename InputIt&gt;
HashMap&lt;K, M, H&gt;::HashMap(InputIt first, InputIt last, size_t bucket_count, const H&amp; hash) :
   HashMap(bucket_count, hash) {
   for (auto iter = first; iter != last; ++iter) {
      insert(*iter);
   }
}</code></pre></li></ul></li></ul><h2 id="4464256d-125b-4592-ba0f-da07f6c6e78b" class="block-color-orange_background">模版函数</h2><ul id="61a2a011-36f8-492f-bc92-b3e7c2e122ff" class="bulleted-list"><li style="list-style-type:disc"><strong><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">与模版类同理</a></strong>，对于模版函数，<mark class="highlight-purple"><strong>模版函数的声明和定义（实现）必须写在同一个.h文件里</strong></mark>。<ul id="6edc24d0-e669-4018-a3e9-b9d0b4081374" class="bulleted-list"><li style="list-style-type:circle">同样，对于模版函数的声明，前面也要加上template&lt;typename ..&gt;</li></ul></li></ul><ul id="c021f27b-189d-4cfc-a4e8-d3874abbff50" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>模版函数</strong></span>：<figure id="1e47f042-5184-4b71-89b3-aa9a8d870029" class="image" style="text-align:center"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2023-11-30_14.04.12.png"><img style="width:480px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2023-11-30_14.04.12.png"/></a></figure><ul id="835f2240-5927-4145-ae45-7fd0940d2758" class="bulleted-list"><li style="list-style-type:circle"><strong>编译器可以自己推断传入参数的类型</strong>；<strong>也可以用auto来让编译器推断返回结果的类型</strong><figure id="9a19f4ae-f2b4-460b-a315-588b857ece26" class="image" style="text-align:center"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2023-11-30_14.04.32.png"><img style="width:480px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2023-11-30_14.04.32.png"/></a></figure></li></ul><ul id="4d9ab404-0aa0-4f1a-91c3-9bf956b7398a" class="bulleted-list"><li style="list-style-type:circle">如果让编译器自己进行类型推断，一定要<span style="border-bottom:0.05em solid"><strong>注意一些坑点</strong></span>，<span style="border-bottom:0.05em solid"><strong>比如传入一个字符串常量时，模版接受到的其实是一个char*类型</strong></span>（因为编译器会推断类型是char*， 而不是string）<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="72e6d809-8f12-4676-b03f-48ac97f3fea6" class="code"><code class="language-C++">// auto-return type + multiple types
template &lt;typename T, typename U&gt;
auto smarterMyMin(const T&amp; a, const U&amp; b) {
    return a &lt; b ? a : b;
}

// string literals like the ones below are c-strings, with a &quot;char *&quot; data type.
// char *&#x27;s are pointers, which means myMin is comparing the addresses of these two strings,
// and not the letters themselves! this is a danger of type deduction.
cout &lt;&lt; myMin(&quot;lhy999&quot;, &quot;lhy&quot;) &lt;&lt; &#x27;\n&#x27;;  // 实际上比较的不是两个string，而是两个地址的大小
// 返回的结果是&quot;lhy54&quot;, 错误！(因为比较的是两个字符串的首地址char*)

// 正确用法：
cout &lt;&lt; myMin&lt;std::string, std::string&gt;(&quot;lhy999&quot;, &quot;lhy&quot;) &lt;&lt; &#x27;\n&#x27;
// 返回的结果是“lhy”, 正确 </code></pre><ul id="d50d6111-f17d-42e7-8c32-e317b92604ec" class="bulleted-list"><li style="list-style-type:square">因此尽量手动指定类型</li></ul></li></ul></li></ul><ul id="ffa5e2a4-332a-4cce-8b5b-4db5c730bdbc" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>在模版中使用</strong></span><a href="https://www.notion.so/C-6e15a78480a542c49efdb2d2c4035a01?pvs=21"><span style="border-bottom:0.05em solid"><strong>函数指针</strong></span></a>：<figure id="8ac7110d-19c3-4125-aa8b-510b6760a21f" class="image" style="text-align:center"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2023-12-10_19.09.07.png"><img style="width:528px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2023-12-10_19.09.07.png"/></a></figure><ul id="8df16dd0-bbf2-44b2-a321-25759ca98d26" class="bulleted-list"><li style="list-style-type:circle">其中，UniPrd就是一个函数指针类型<figure id="9bc25c70-b163-49d3-b34a-6512d507b36d" class="image" style="text-align:center"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2023-12-10_19.12.31.png"><img style="width:384px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2023-12-10_19.12.31.png"/></a></figure></li></ul></li></ul><ul id="9f10026c-4ff1-4cdc-8293-6cb33a674445" class="bulleted-list"><li style="list-style-type:disc">模版类和模版函数的编译<figure id="b6ae8d05-0bbd-4b5b-acca-05e075b9a4c5" class="image" style="text-align:center"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2023-11-30_00.15.28.png"><img style="width:480px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2023-11-30_00.15.28.png"/></a></figure><ul id="36cfc20b-6a1e-4967-8083-eb4cc4e1132c" class="bulleted-list"><li style="list-style-type:circle">模版类和模版函数<span style="border-bottom:0.05em solid"><strong>在编译时被实例化</strong></span>，并且只有当被用到时才会被编译<ul id="c6e57156-66de-4fc3-b7b5-e4724309e74b" class="bulleted-list"><li style="list-style-type:square"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html"><span style="border-bottom:0.05em solid"><strong>模版元编程</strong></span></a>利用了模版的这个特性，实现编译时计算，从而加速程序。</li></ul></li></ul><ul id="29896ea9-db5d-4b0d-b6d2-66c26265a181" class="bulleted-list"><li style="list-style-type:circle">编译后，相当于编译器自动生成了各种类型版本的类和函数</li></ul></li></ul><h2 id="0fd07e57-f90c-4712-8be0-3a470989cc69" class="block-color-orange_background"><strong>Concepts 和 Constraints：使模版代码更容易维护（C++20）</strong></h2><ul id="dce35892-2647-4ae0-8f6c-ea4d59149cdd" class="bulleted-list"><li style="list-style-type:disc"><em><span style="border-bottom:0.05em solid"><strong>Concepts 和 Constraints</strong></span></em>（对应于<code>concept</code>与<code>requires</code>关键字）：在 <mark class="highlight-red"><span style="border-bottom:0.05em solid"><em><strong>C++20</strong></em></span></mark> 中引入，是模板元编程的强大工具。它们提高了代码的表达能力，使模板的意图更加明确，同时也让编译器能够生成更有用的错误消息。这些特性使得模板代码更容易理解和维护，有助于减少模板实例化错误。<ul id="e935b00c-a751-4d86-b68d-3bdaa4bc3807" class="bulleted-list"><li style="list-style-type:circle">比如<strong>它可以要求模版的类型必须满足某些要求</strong>：比如要求传入的类型必须具有<code>end()</code>，<code>begin()</code>方法；要求支持+，-，*，/运算；要求它只能是int, float, double类型</li></ul></li></ul><ul id="585e6619-463a-441f-b697-5f05c506fc32" class="bulleted-list"><li style="list-style-type:disc">给模版修饰了requires后，会在编译前就对模版的实例化进行检查。</li></ul><ul id="a0f7ea00-36f8-4afd-a6ec-14900ce2525b" class="bulleted-list"><li style="list-style-type:disc"><code>requires</code>和<code>concept</code>的用法<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="87ed9fb1-bcad-4b17-acad-7ba3d7a4c740" class="code"><code class="language-C++">template &lt;typename T&gt;
concept Addable = requires(T a, T b) {
    { a + b } -&gt; std::convertible_to&lt;T&gt;;
};

template &lt;typename T&gt;
concept Comparable = requires(T a, T b) {
    { a &lt; b } -&gt; std::convertible_to&lt;bool&gt;;
};

template &lt;typename T&gt;
concept Arithmetic = requires(T a, T b) {
    { a + b } -&gt; std::same_as&lt;T&gt;;
    { a - b } -&gt; std::same_as&lt;T&gt;;
    { a * b } -&gt; std::same_as&lt;T&gt;;
    { a / b } -&gt; std::same_as&lt;T&gt;;
		{a % b}; //只进行操作检查，不进行结果类型约束
};

template&lt;typename T&gt;
concept Iterable = requires(T x) {
    { std::begin(x) } -&gt; std::input_or_output_iterator;
    { std::end(x) } -&gt; std::input_or_output_iterator;
};

/*  这个requires表达式是C++20引入的一种新语法，
		用于定义一个所谓的 &quot;约束&quot;（Constraint），它是用于创建 Concepts 的一部分。 */</code></pre><ul id="a43c01d1-e372-4a01-aa28-4197e8f466db" class="bulleted-list"><li style="list-style-type:circle"><span style="border-bottom:0.05em solid"><strong>requires表达式</strong></span>含义如下：<ul id="b1d21c6a-2011-42da-8719-db7b7ec25e0a" class="bulleted-list"><li style="list-style-type:square"><strong>参数列表</strong>：<code>(T a, T b)</code>指定了这个约束需要两个类型为<code>T</code>的参数<code>a</code>和<code>b</code>。</li></ul><ul id="5315ef6b-5853-43c2-a886-95a4d627bdbe" class="bulleted-list"><li style="list-style-type:square"><strong>操作检查</strong>：<code>{ a + b }</code>是一个复合语句，它尝试执行<code>a + b</code>。这个复合语句的目的是检查类型<code>T</code>是否支持<code>+</code>运算符。</li></ul><ul id="35171d9e-596a-473b-834e-cca5c67e5d8c" class="bulleted-list"><li style="list-style-type:square"><strong>结果类型约束</strong>：<code>-&gt; std::convertible_to&lt;T&gt;</code>是一个约束，它要求上述复合语句的结果（即<code>a + b</code>的结果）必须能够转换为类型<code>T</code>。<ul id="afa232e3-1785-44a2-8320-0d7ff98e47e9" class="bulleted-list"><li style="list-style-type:disc">如果只需要进行操作检查，那么这部分可以不写</li></ul></li></ul></li></ul><ul id="c48faabd-a0a4-4972-8d31-37ac8432a0c9" class="bulleted-list"><li style="list-style-type:circle">std本身提供了一些常用的concept模版<figure id="0beeea0e-05fe-4c6d-be7b-e3d271c124db" class="image" style="text-align:center"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2023-11-29_23.30.57.png"><img style="width:480px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2023-11-29_23.30.57.png"/></a></figure><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="4c6acc56-8160-4c12-bd06-0224fa7e23f7" class="code"><code class="language-C++">/* std提供一些常用的concept */
// 检查两个类型是否相同。
template &lt;typename T, typename U&gt;
concept Same = std::same_as&lt;T, U&gt;;

// 检查一个类型是否是整数类型。
template &lt;typename T&gt;
concept Integral = std::integral&lt;T&gt;;

// 检查一个类型是否可以被赋值。
template &lt;typename T, typename U&gt;
concept AssignableFrom = std::assignable_from&lt;T, U&gt;;

// 还可以组合concept
template &lt;typename T&gt;
concept IntegralAndDefaultConstructible = Integral&lt;T&gt; &amp;&amp; std::default_initializable&lt;T&gt;; 
// 还可以用或运算符&#x27;||&#x27;来组合concept</code></pre></li></ul><ul id="ad016e47-c43c-493c-adad-108979352243" class="bulleted-list"><li style="list-style-type:circle">之后定义模版时就可以利用定义好的<code>concept</code>（或者是std中已经定义好的一些<code>concept</code>，如）：<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="68f6f85b-ff4c-4f7d-857c-5216b57fc0cb" class="code"><code class="language-C++">/* 用法1：使用requires关键字(更推荐这种写法) */
template &lt;typename T&gt;
	requires Addable&lt;T&gt;
T add(T a, T b) {
    return a + b;
} //这个模版要求实例化时，T类型必须满足concept Addable


/* 用法2:直接把concept写到模版的定义中 */
template &lt;Addable T&gt;
T add(T a, T b) {
    return a + b;  // 只有当 T 是 Addable 时，这个函数才有效
}</code></pre></li></ul><ul id="6c7cd62d-ac21-4f67-8b70-3079309290b2" class="bulleted-list"><li style="list-style-type:circle">还可以结合使用多个<code>concept</code><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="c43186eb-ac18-40a1-9986-39f95efda3cc" class="code"><code class="language-C++">template &lt;Addable T, Comparable T, Arithmetic T&gt;
T exampleFunction(T a, T b) {
    // ...
}

// 或者写成requires（更加灵活，所以推荐使用requires语法）
template &lt;typename T&gt;
    requires Addable&lt;T&gt; &amp;&amp; Comparable&lt;T&gt; || Arithmetic&lt;T&gt;
void exampleFunction(T a, T b) {
    // ...
}</code></pre></li></ul></li></ul><h2 id="e7ca8bae-0680-44f9-850e-264e33beba28" class="block-color-orange_background">模版元编程TMP与constexpr  </h2><ul id="36cf122b-4e3b-4e6c-a943-c2e74f673de5" class="bulleted-list"><li style="list-style-type:disc"><code><strong>constexpr</strong></code>是 C++11 引入的一个关键字，如果变量、函数或对象构造函数被<code>constexpr</code>进行修饰，则<strong>表示它们可以在编译时进行求值</strong>。这个特性<span style="border-bottom:0.05em solid"><strong>允许某些计算在编译阶段而非运行时完成</strong></span>，从而<span style="border-bottom:0.05em solid"><strong>提高程序的性能和可预测性</strong></span>。<figure id="3d97af24-edf1-41e1-8fcb-3bb0de15edd2" class="image" style="text-align:center"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2023-11-30_13.55.32.png"><img style="width:480px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2023-11-30_13.55.32.png"/></a></figure></li></ul><ul id="b545a878-a059-437e-a794-5cc1320c1a11" class="bulleted-list"><li style="list-style-type:disc"><code><strong>constexpr</strong></code>提供了一种相对简单的方式来<span style="border-bottom:0.05em solid"><strong>实现编译时计算</strong></span>，而<span style="border-bottom:0.05em solid"><strong>模板元编程</strong></span>（<em><span style="border-bottom:0.05em solid"><strong>TMP</strong></span></em>）则是一种更高级和复杂的技术，用于在编译时执行更复杂的逻辑。<ul id="e4711b1d-f844-4dd9-89be-8e98761512bc" class="bulleted-list"><li style="list-style-type:circle">模版元编程TMP：Writing code that runs during compilation (instead of run time)<figure id="abf80aa5-b576-4388-bc32-b25fd78e1ad9" class="image" style="text-align:center"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2023-11-30_14.10.44.png"><img style="width:432px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2023-11-30_14.10.44.png"/></a></figure><figure id="985564f1-9d0c-436d-b922-5dfe4ba87a0c" class="image" style="text-align:center"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2023-11-30_14.01.04.png"><img style="width:432px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2023-11-30_14.01.04.png"/></a></figure></li></ul></li></ul><ul id="e124d9e7-c596-4949-b891-390872fe3eae" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>constexpr变量</strong></span>：当<code>constexpr</code>用于变量时，它<span style="border-bottom:0.05em solid"><strong>指示该变量的值在编译时是已知且不变的（编译时常量）</strong></span>。这意味着变量必须在声明时就被初始化，且初始化表达式也必须是常量表达式。<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="5f9dfca7-dc7a-4906-b819-49e1e0449413" class="code"><code class="language-C++">constexpr int max_size = 100; // max_size 是一个编译时常量</code></pre><ul id="f456193c-cacc-4e1e-bbd8-f33a89e4bb0a" class="bulleted-list"><li style="list-style-type:circle"><code>const</code>变量和<code>constexpr</code>变量的区别：如果<code>const</code>变量在声明时使用了编译时常量表达式进行初始化，则它是一个<span style="border-bottom:0.05em solid"><strong>编译时常量</strong></span>；但如果是用一个运行时变量进行初始化，则它不是一个编译时常量，而是<span style="border-bottom:0.05em solid"><strong>运行时常量</strong></span><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="cb38f6c8-a909-48ee-a559-ef4798f0824c" class="code"><code class="language-C++">const int max_size = 100;  // 编译时常量，因为 100 是常量表达式

void function(int x) {
    const int run_time_const = x;  // 运行时常量，因为 x 的值在运行时才确定
    // ...
}</code></pre><p id="52cc854c-5136-4f9b-9af2-f3de977e9748" class="">因此，<code>const</code>关键字用于声明不可变的变量，<strong>但这些变量可以在编译时或运行时赋值</strong>。如果你需要保证变量在编译时就已经确定其值，应该使用<code>constexpr</code>。这是 C++11 引入的一个关键字，<strong>专门用于定义编译时常量</strong>。</p><p id="a108263b-c018-4b33-aa03-4981ae30050b" class=""><code>constexpr</code>关键字就是告诉编译器：这个变量或函数要在编译的时候进行求值（而不是运行时）</p></li></ul></li></ul><ul id="80e2d9fa-d6f0-4806-a80d-7e3ed553bf39" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>constexpr函数</strong></span>：当<code>constexpr</code>用于函数时，它<span style="border-bottom:0.05em solid"><strong>表明该函数可以在编译时对常量表达式参数进行求值</strong></span>。这样的函数必须足够简单，以便编译器可以在编译时计算其结果。<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="17117d6a-7e50-41be-97bc-b62a54c6a462" class="code"><code class="language-C++">constexpr int add(int x, int y) {
    return x + y; // 如果 x 和 y 都是常量表达式，add 可以在编译时求值
}</code></pre></li></ul><ul id="daa9f25e-6d05-41d9-8e0f-6bb95df28551" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>constexpr对象构造函数</strong></span>：当<code>constexpr</code>用于类的构造函数时，它<span style="border-bottom:0.05em solid"><strong>表示该构造函数可以用于创建编译时常量对象</strong></span>。这<span style="border-bottom:0.05em solid">要求所有成员变量也必须用常量表达式初始化</span>。<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="d6005aea-81a3-406a-bccd-46b66f5327a7" class="code"><code class="language-C++">class Point {
public:
    constexpr Point(double x, double y) : x(x), y(y) {}
    double x, y;
};

constexpr Point origin(0.0, 0.0); // origin 是一个编译时常量对象</code></pre></li></ul><ul id="601110cf-1b5c-4457-99cd-089d42b8a00b" class="bulleted-list"><li style="list-style-type:disc">case1：编译时计算数学常量<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="76a67943-b906-4555-b5cb-6724391ce1d7" class="code"><code class="language-C++">constexpr double pi() {
    return 3.14159265358979323846;
}

constexpr double square(double x) {
    return x * x;
}

constexpr double circleArea(double radius) {
    return pi() * square(radius);
}

int main() {
    constexpr double radius = 5.0; // radius必须用constexpr进行修饰
    constexpr double area = circleArea(radius);
    // ...
}</code></pre><ul id="22c8b382-cea9-480e-a257-f0fd08266538" class="bulleted-list"><li style="list-style-type:circle">这里的radius和area必须用<code>constexpr</code>进行修饰，如果只用double进行修饰，则它们是在程序运行时进行赋值的运行时常量（而不是编译时赋值的编译时常量）</li></ul><ul id="f5cc306b-a087-425e-831c-69324297cbb4" class="bulleted-list"><li style="list-style-type:circle">但如果radius和area没有用<code>constexpr</code>修饰，则实际运行时，circleArea(radius)仍然是运行时求值的（不会报错）</li></ul></li></ul><ul id="490a152a-4fd7-458c-897a-e8951641e4c3" class="bulleted-list"><li style="list-style-type:disc">case2：编译时生成查找表<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="52c22f8d-cbab-47ff-ac06-06eda3585b9a" class="code"><code class="language-C++">constexpr int factorial(int n) {
    return n &lt;= 1 ? 1 : n * factorial(n - 1);
}

constexpr int fac5 = factorial(5);  // 在编译时计算 5 的阶乘

constexpr std::array&lt;int, 10&gt; facLookup = {factorial(0), factorial(1), factorial(2),
                                           factorial(3), factorial(4), factorial(5),
                                           factorial(6), factorial(7), factorial(8),
                                           factorial(9)};</code></pre></li></ul><ul id="e4005537-6073-424e-ab70-f36bf7b35b51" class="bulleted-list"><li style="list-style-type:disc">case3：编译时构造常量对象<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="544f0353-5455-41de-b368-f64941acfb8d" class="code"><code class="language-C++">class Point {
public:
    constexpr Point(double x, double y) : x(x), y(y) {}

    constexpr double getX() const { return x; }
    constexpr double getY() const { return y; }

private:
    double x, y;
};

constexpr Point origin(0.0, 0.0);
constexpr Point unitX(1.0, 0.0);
constexpr Point unitY(0.0, 1.0);</code></pre></li></ul><ul id="d84ee535-6424-4b56-b501-4756108410b6" class="bulleted-list"><li style="list-style-type:disc">case4：编译时处理字符串<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="5df40a81-3193-47bc-a769-43aaadfa88f2" class="code"><code class="language-C++">constexpr size_t stringLength(const char* str) {
    return *str ? 1 + stringLength(str + 1) : 0;
}

constexpr size_t len = stringLength(&quot;Hello, world!&quot;);</code></pre></li></ul><ul id="e8a9e745-99bd-4253-97f9-ced4a8255e29" class="bulleted-list"><li style="list-style-type:disc">case5：编译时求fib数<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="7575e9bb-8899-49f7-9bec-5e11e5920680" class="code"><code class="language-C++">constexpr double fib(int n) { // function declared as constexpn
	if (n == 1) return 1;
	return fib(n-l) * n;
}

int main() {
	constexpr long long bigval = fib(20);
	std: : cout &lt;&lt; bigval &lt;&lt; std::endl;
}</code></pre></li></ul><h2 id="f49a47c3-cc65-4358-acfd-bb3fba6fd39f" class="block-color-orange_background">Lambda表达式  </h2><ul id="95601e12-cf61-4f87-9f54-bf8452cf52fb" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>Lambda表达式</strong></span>：C++11引入的特性，提供了一种方便、简洁的方式来定义在局部作用域内可以执行的一次性函数。</li></ul><ul id="86d3a0f4-cbb7-4128-8a4e-11c1e12e2118" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>语法</strong></span>：<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="a4f71326-c59a-49be-8b3b-6cffab6a3a45" class="code"><code class="language-C++">[捕获列表](参数列表) -&gt; 返回类型 {
    函数体
};
注意：最后还有一个分号</code></pre><ul id="8c857f84-a601-4dae-a615-933fd0d01879" class="bulleted-list"><li style="list-style-type:circle"><strong>捕获列表</strong>：用于引用外部的变量（实现了闭包）<ul id="03c9ea25-5c8f-4323-ba23-b84ead080c9d" class="bulleted-list"><li style="list-style-type:square">捕获列表中不需要声明变量的类型（只有参数列表中需要），只需要声明变量名</li></ul><ul id="8c60bfac-b7bf-41a1-9c09-ffa9e17e7636" class="bulleted-list"><li style="list-style-type:square">捕获列表中可以在变量名前面加上&amp;，从而防止进行值传递，同时还可以修改外部变量的状态 </li></ul></li></ul><ul id="86b602a6-38c0-47a0-ae83-e3fd0afe1f74" class="bulleted-list"><li style="list-style-type:circle"><strong>返回类型</strong>：可以让编译器自动进行推断，但<strong>显式地指明返回类型是一个good practice</strong>（除非这个返回类型不是固定的）<ul id="5f148af6-96b6-4400-9dd8-c3448c04693b" class="bulleted-list"><li style="list-style-type:square">如果不返回任何数据，则返回类型是void</li></ul></li></ul></li></ul><ul id="6edaa801-e19d-4580-bf3d-7107ba1dd3ae" class="bulleted-list"><li style="list-style-type:disc">示例用法<figure id="c860a086-6d33-4426-b8ec-1507d46b2903" class="image" style="text-align:center"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2023-12-10_22.15.25.png"><img style="width:480px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2023-12-10_22.15.25.png"/></a></figure><ul id="6196d09c-0cd2-47e0-bd88-8ba8f6b5b7f9" class="bulleted-list"><li style="list-style-type:circle">case1：<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="358ec79b-33e5-4a82-b8d6-7d19c231c049" class="code"><code class="language-C++">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;numeric&gt;

int main() {
    std::vector&lt;int&gt; nums = {1, 2, 3, 4, 5};
    int sum = 0;

    // 捕获外部变量sum（使用引用）
    std::for_each(nums.begin(), nums.end(), [&amp;sum](int n) -&gt; void{
        sum += n;
    });

    std::cout &lt;&lt; &quot;Sum: &quot; &lt;&lt; sum &lt;&lt; std::endl;
    return 0;
}</code></pre></li></ul><ul id="62712801-5da2-483c-8901-d60aa13188d8" class="bulleted-list"><li style="list-style-type:circle">case2：<a href="https://www.notion.so/C-6e15a78480a542c49efdb2d2c4035a01?pvs=21">函数指针</a> + Lambda表达式<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="b534dbbf-0980-4d39-bd46-75cc25597ec0" class="code"><code class="language-C++">int main() {
    std::function&lt;int(int, int)&gt; func = [](int a, int b) -&gt; int{
        return a * b;
    };

    std::cout &lt;&lt; &quot;Lambda Result: &quot; &lt;&lt; func(6, 7) &lt;&lt; std::endl;
    return 0;
}</code></pre><ul id="78683b49-2ff0-4d00-b15b-ee178e4fa5f7" class="bulleted-list"><li style="list-style-type:square">通过Lambda表达式来构造一个函数指针</li></ul></li></ul></li></ul><ul id="f1b4fd95-3c58-4439-832b-63fd0fa8cfbf" class="bulleted-list"><li style="list-style-type:disc">由于Lambda表达式有一个捕获列表，所以它可以<strong>构造“假参数”</strong>，例如<figure id="b72d2f45-0963-4e18-9ad6-69c48cc01e8e" class="image" style="text-align:center"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2023-12-10_22.12.19.png"><img style="width:576px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2023-12-10_22.12.19.png"/></a></figure><ul id="79e9351c-a462-4973-8e01-6f9bc35f3b70" class="bulleted-list"><li style="list-style-type:circle">其中，<code>limit</code>就是一个“假参数”</li></ul><ul id="8da1ee5e-8ab0-40b1-8865-86a52366d707" class="bulleted-list"><li style="list-style-type:circle">通过这种方法，既能使用“假参数”limit来控制函数isMoreThan的行为，又能使函数的参数量只有1个</li></ul></li></ul><ul id="55668bd0-35d6-4d5a-becf-05860c1b0260" class="bulleted-list"><li style="list-style-type:disc">在大部分的简单场景下，lambda表达式通常用来表述一个<a href="https://www.notion.so/C-6e15a78480a542c49efdb2d2c4035a01?pvs=21">谓词函数</a></li></ul><h2 id="514fa35e-30e6-4b52-8fbf-1173f0fb033b" class="block-color-orange_background">Functor （函数对象） </h2><ul id="09a3ad47-c8f7-44ed-93bc-d0cee45adcd6" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>如果一个类重载了</strong></span> <code><strong>operator()</strong></code>，那么它就是一个 <code>Functor</code>。当创建这个类的对象时，这个对象可以像调用函数那样被使用。</li></ul><ul id="18d43522-9aa2-4655-8ef9-f54aad2c8273" class="bulleted-list"><li style="list-style-type:disc"><code>Functor</code>相较于普通的函数，它<span style="border-bottom:0.05em solid"><strong>可以存储或改变状态</strong></span>，这使得它们可以根据内部状态或以前的计算结果改变行为。</li></ul><ul id="1817ffbf-a7d1-4676-bd81-ee471622da76" class="bulleted-list"><li style="list-style-type:disc">用法：<ul id="8b1b5592-88ac-42d1-8cc1-59f9b67f334c" class="bulleted-list"><li style="list-style-type:circle">case1：functor + 函数指针<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="207ef4e2-385c-462d-b2fd-288f1c2c1cf1" class="code"><code class="language-C++">class Adder {
public:
    Adder(int increment) : increment_(increment) {}

    int operator()(int x) const {
        return x + increment_;  // 也可以改变increment_的值
    }

private:
    int increment_;
};


int main() {
    Adder addFive(5);
    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; addFive(10) &lt;&lt; std::endl; // 输出 15
		std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; addFive(20) &lt;&lt; std::endl; // 输出 25

    // functor + 函数指针
    std::function&lt;int(int)&gt; func = addFive;
    std::cout &lt;&lt; &quot;Result: &quot; &lt;&lt; func(10) &lt;&lt; std::endl; // 输出 15

    return 0;
}</code></pre></li></ul></li></ul><ul id="14df9b33-e6f3-4c0d-9d9b-077ad9281f13" class="bulleted-list"><li style="list-style-type:disc"><code>functor</code>与类的区别：使用类可以实现与<strong><code>functor</code></strong>类似的功能，但<code>functor</code><span style="border-bottom:0.05em solid"><strong>仍然作为函数类型存在</strong></span>，相较于类有以下优势<ul id="276bc9c5-2aa3-4b49-bf56-5c826654ec8f" class="bulleted-list"><li style="list-style-type:circle"><strong>作为回调函数</strong>：functor仍然作为函数类型存在，因此函数指针可以使用functor，<code>std::function</code>也可以用来修饰<code>functor</code></li></ul><ul id="f2d4aa1c-71fd-4574-ace6-3cbb2623b8e9" class="bulleted-list"><li style="list-style-type:circle"><strong>状态保持</strong>：functor可以捕获和保持状态，这在需要基于之前操作结果的情况下非常有用。</li></ul></li></ul><h2 id="b31af386-fc14-4f99-bed0-478ee12f8520" class="block-color-orange_background">algorithm包</h2><figure id="1b3132a6-484f-4076-b6ac-3f2b149bb49e"><a href="https://en.cppreference.com/w/cpp/algorithm" class="bookmark source"><div class="bookmark-info"><div class="bookmark-text"><div class="bookmark-title">Algorithms library - cppreference.com</div><div class="bookmark-description">The algorithms library defines functions for a variety of purposes (e.g. searching, sorting, counting, manipulating) that operate on ranges of elements. Note that a range is defined as [first, last) where last refers to the element past the last element to inspect or modify.</div></div><div class="bookmark-href"><img src="https://en.cppreference.com/favicon.ico" class="icon bookmark-icon"/>https://en.cppreference.com/w/cpp/algorithm</div></div></a></figure><ul id="8d0523e7-c391-4410-a3df-8a767ed4f8b1" class="bulleted-list"><li style="list-style-type:disc"><code><strong>std::for_each</strong></code>：遍历容器，对每个元素作用一个传入的函数</li></ul><ul id="8f8ad041-d614-4cfa-a9fe-e720831d2776" class="bulleted-list"><li style="list-style-type:disc"><strong><code>any_of</code></strong>、<strong><code>all_of</code></strong>、<strong><code>none_of</code></strong>：可以判断一个容器内的元素是否满足某个条件<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="20f4de5b-313f-4de6-a523-5f2951169695" class="code"><code class="language-C++">#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;vector&gt;
#include &lt;functional&gt;

int main() {
  std::vector&lt;int&gt; v = {1, 2, 3, -4, 5};
	std::function&lt;bool(int)&gt; f = [](int i) {
		return i &lt; 0;
	};

  std::cout &lt;&lt; std::any_of(v.begin(), v.end(), f)  &lt;&lt; &#x27;\n&#x27;;  // 输出1
	std::cout &lt;&lt; std::all_of(v.begin(), v.end(), f)  &lt;&lt; &#x27;\n&#x27;;  // 输出0
 	std::cout &lt;&lt; std::none_of(v.begin(), v.end(), f) &lt;&lt; &#x27;\n&#x27;;  // 输出0
	// 如果-4改为4，则输出结果变为：0 0 1
}</code></pre></li></ul><ul id="0b580682-6a98-467d-9e8a-a138240ce59d" class="bulleted-list"><li style="list-style-type:disc"><strong><code>find</code></strong><strong>、</strong><code><strong>find_if</strong></code>和<strong><code>search</code></strong><ul id="009ff647-4e7a-4da6-a9b6-426943e73360" class="bulleted-list"><li style="list-style-type:circle"><em><code>find</code></em>：用于在一个容器的某个范围内查找<span style="border-bottom:0.05em solid"><strong>某个元素</strong></span>的第一个匹配项。返回一个迭代器，找不到的话会返回end()</li></ul><ul id="9bf07ea2-8f24-4c65-811c-ca54fa054e26" class="bulleted-list"><li style="list-style-type:circle"><em><code>find_if</code></em>：根据某个<a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">谓词函数</a>，在一个容器中找出第一个满足这个谓词的元素的位置（返回一个迭代器）<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="f53300a0-e7c4-4130-bcfa-a8ab5745a12e" class="code"><code class="language-C++">std::vector&lt;int&gt; v = {1, 3, 5, 2, 4, 6, 7};
auto is_even = [](int i) { return i % 2 == 0; };
// 查找第一个偶数
auto it = std::find_if(v.begin(), v.end(), is_even);</code></pre></li></ul><ul id="7d4d4f82-e2a3-4a05-8952-23a0ccf27058" class="bulleted-list"><li style="list-style-type:circle"><em><code>search</code></em>：用于在一个序列（如vector, list, string）中查找另<span style="border-bottom:0.05em solid"><strong>一个序列</strong></span>的第一次出现。<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="a6108f3d-2928-4a9a-9638-b7ec7369501b" class="code"><code class="language-C++">std::vector&lt;int&gt; v = {1, 2, 3, 4, 5};
std::vector&lt;int&gt; pattern = {3, 4};
auto it = std::search(v.begin(), v.end(), pattern.begin(), pattern.end());</code></pre></li></ul></li></ul><ul id="7be7286d-6390-43b2-aede-00f99d954aa0" class="bulleted-list"><li style="list-style-type:disc"><strong><code>copy</code></strong>与<code><strong>copy_backward</strong></code>：都用于将一个容器中某个范围的元素拷贝到另一个容器里，只不过拷贝时的方向不同。copy是从前往后的顺序一个一个拷贝，而copy_backward是从后往前的顺序一个一个拷贝<br/><br/><mark class="highlight-default"><strong>当两个容器的拷贝区域中有重叠部分时，</strong></mark><mark class="highlight-purple"><strong>比如向前移动拷贝和向后移动拷贝的的场景</strong></mark><mark class="highlight-default"><strong>，</strong></mark><span style="border-bottom:0.05em solid"><mark class="highlight-default"><strong>copy和copy_backward分别会产生不同的效果</strong></mark></span><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="5fa9353b-6b87-4cb2-9c2b-e1d24d98c193" class="code"><code class="language-C++">// 把v1的所有元素拷贝到v2里
std::copy(v1.begin(), v1.end(), v2.begin());

// 把v1的pos处开始的所有元素往后移一个单位
std::copy_backward(pos, v1.end(), v1.end() + 1); </code></pre></li></ul><ul id="ea72eebc-1f34-4c50-95aa-736afd16791a" class="bulleted-list"><li style="list-style-type:disc"><strong><code>count_if</code></strong>：用于计算容器中某个范围内，满足特定条件的元素数量<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="83f4d0e2-ebee-4d81-81b8-20ad99dadbc1" class="code"><code class="language-C++">#include &lt;iostream&gt;
#include &lt;map&gt;
#include &lt;algorithm&gt;

using std::string, std::map, std::pair, std::count_if, std::cout;
int main() {
    map&lt;int, tring&gt; myMap = {
        {1, &quot;apple&quot;}, {2, &quot;banana&quot;}, {3, &quot;cherry&quot;}
    };

    // 计算键大于1的元素数量
    int count = count_if(myMap.begin(), myMap.end(), [](const pair&lt;int, string&gt;&amp; p) {
        return p.first &gt; 1; // p.first 是键，p.second 是值
    });

    cout &lt;&lt; &quot;Number of elements with key &gt; 1: &quot; &lt;&lt; count &lt;&lt; &#x27;\n&#x27;;

    return 0;
}</code></pre></li></ul><ul id="ed136d61-a1cb-4333-a41c-9251177c7362" class="bulleted-list"><li style="list-style-type:disc"><code><strong>std::max_element</strong></code><strong> / </strong><code><strong>std::min_element</strong></code>：找到序列中的最大或最小元素。</li></ul><ul id="555919f0-2228-4b4a-ac1b-2c283951da7c" class="bulleted-list"><li style="list-style-type:disc"><code><strong>std::max</strong></code><strong> / </strong><code><strong>std::min</strong></code>：在两个值中找到最大或最小值。</li></ul><ul id="e142123b-e2b2-4145-b8b1-1643ae4f162b" class="bulleted-list"><li style="list-style-type:disc"><code><strong>std::fill</strong></code><strong> </strong>：用特定值填充序列。</li></ul><ul id="0b661aef-30a5-4c67-8508-96de89d70692" class="bulleted-list"><li style="list-style-type:disc"><code><strong>std::replace</strong></code><strong> / </strong><code><strong>std::replace_if</strong></code>：替换序列中满足条件的元素。</li></ul><ul id="33a12555-421a-4bea-ba99-ec0136ec55d2" class="bulleted-list"><li style="list-style-type:disc"><code><strong>std::remove</strong></code><strong> / </strong><code><strong>std::remove_if</strong></code>：移除满足条件的元素。</li></ul><h2 id="6a073728-12b4-4946-aca4-92f13541fe92" class="block-color-orange_background">ranges库(C++ 20)：STL 2.0，函数式编程</h2><figure id="592dd6f2-5e40-453c-b12b-699d4b254c04"><a href="https://zhuanlan.zhihu.com/p/86809598" class="bookmark source"><div class="bookmark-info"><div class="bookmark-text"><div class="bookmark-title">ranges for C++20简介</div><div class="bookmark-description">ranges可以省掉很多循环，包括多重循环，写出来的代码又简单，可读性又好。从此以后很多算法和逻辑的实现都将进入到easy模式。本文通过一个例子说明这一点。如果自己用循环去实现，会麻烦很多，ranges将手写循环很…</div></div><div class="bookmark-href"><img src="https://static.zhihu.com/heifetz/assets/apple-touch-icon-152.81060cab.png" class="icon bookmark-icon"/>https://zhuanlan.zhihu.com/p/86809598</div></div></a></figure><h3 id="2a86cba9-4c49-4ea0-8713-34bec9d541f3" class="block-color-blue_background">基本概念：Range与view</h3><ul id="c1f1167c-f975-43df-92c9-cc57892c3e77" class="bulleted-list"><li style="list-style-type:disc"><em><mark class="highlight-red"><span style="border-bottom:0.05em solid"><strong>Range</strong></span></mark></em><mark class="highlight-default">：对传统容器的补充和增强，用于</mark><span style="border-bottom:0.05em solid"><strong><mark class="highlight-default">描述一个数据序列</mark></strong></span><ul id="c527ec68-6e83-4a66-86fb-cdf4c12d1836" class="bulleted-list"><li style="list-style-type:circle">一个<code>Range</code>类必须提供<code>begin()</code>和<code>end()</code>方法，这两个方法分别指向这个数据序列<span style="border-bottom:0.05em solid"><strong>迭代器</strong></span>的开始和结束的位置<ul id="403ea611-d873-4bb9-bbaa-74c7154ebd83" class="bulleted-list"><li style="list-style-type:square"><span style="border-bottom:0.05em solid"><strong>迭代器</strong></span>：具有运算符*、→、++、==、≠的一种类</li></ul><blockquote id="0eaec045-37ba-4b11-9141-de77e1863b7e" class="block-color-gray_background">所以使用一个<code>Range</code>与使用一个容器的用法是完全一样的（无论是迭代的方式，还是取值的方式）</blockquote></li></ul><ul id="dc94df08-af87-4a9a-aea7-5c7a4f8a2713" class="bulleted-list"><li style="list-style-type:circle">stl中所有的容器都是<code>Range</code></li></ul></li></ul><ul id="d7a4ab26-126e-4369-8d02-7201e94ad976" class="bulleted-list"><li style="list-style-type:disc"><code>Range</code>的API和容器的API是完全一致的，<span style="border-bottom:0.05em solid"><strong>用起来没有区别</strong></span>（因为容器也是一个Range）<blockquote id="99d5cc99-5c34-4c95-b83c-a137e5ad3bff" class="block-color-gray_background">例如Range也提供了begin()、eng()、size()、empty()等方法</blockquote><script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="62fe1f53-6aa2-4807-bef0-3c774388797f" class="code"><code class="language-C++">int main() {
    std::vector&lt;int&gt; v = {1, 2, 3, 4, 5};
    // 假设我们想在视图的前三个元素中查找数字 3
    // vector也是一个range，所以可以直接调用std::ranges::find
    auto it = std::ranges::find(v.begin(), v.begin() + 3, 3);
    if (it != view.begin() + 3) {
        std::cout &lt;&lt; &quot;Found: &quot; &lt;&lt; *it &lt;&lt; &quot;\n&quot;;
    } else {
        std::cout &lt;&lt; &quot;Not found in the specified range\n&quot;;
    }
}</code></pre></li></ul><ul id="5a16d129-2493-4c2e-82ac-5debc8dd281a" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><mark class="highlight-red"><strong>函数式编程</strong></mark></span>：一种编程范式，强调使用函数来处理数据，以及<span style="border-bottom:0.05em solid"><strong>避免状态变化和可变数据</strong></span>。<ul id="4ccb29a8-0650-4b83-8634-2094d203d569" class="bulleted-list"><li style="list-style-type:circle"><mark class="highlight-purple"><strong>不可变性</strong></mark>：在函数式编程中，<span style="border-bottom:0.05em solid"><strong>数据是不可变的</strong></span>。这意味着一旦创建了一个对象，就不能修改它。所有的变化都通过创建新的对象来实现，而不是更改现有的对象。</li></ul><ul id="35251f9d-6ba2-4497-a820-16f5669c0eb3" class="bulleted-list"><li style="list-style-type:circle"><mark class="highlight-purple"><strong>函数链和管道</strong></mark>：函数式编程经常利用<span style="border-bottom:0.05em solid"><strong>函数链和管道</strong></span>的概念来处理数据。通过这种方式，可以<span style="border-bottom:0.05em solid"><strong>将多个函数调用串联</strong></span>起来，每个函数的输出作为下一个函数的输入。</li></ul></li></ul><ul id="161b15be-4134-44e3-bf88-f49df3113e11" class="bulleted-list"><li style="list-style-type:disc"><code>Ranges</code>库引入了<span style="border-bottom:0.05em solid"><strong>函数式风格的编程方法</strong></span>，其中可以将多个操作组合成一个流水线，数据可以通过一系列的转换和过滤，从而生成最终结果。<ul id="3141e556-50bf-48de-803a-f828f3b253aa" class="bulleted-list"><li style="list-style-type:circle">某些支持随机索引的<code>Range</code>在经过某个操作后，会<strong>变成一个不支持随机索引的</strong><strong><code>Range</code></strong></li></ul></li></ul><ul id="94e69d87-5ce9-4ced-8775-93c26e785024" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><mark class="highlight-red"><em><strong>view</strong></em></mark></span>（视图）：一种特殊类型的<code>Range</code>（view同样是一个Range类），<em><strong>view are ranges with lazy evaluation</strong></em><ul id="24b3e26a-22ea-4ba4-868d-2a1e7e333d70" class="bulleted-list"><li style="list-style-type:circle"><strong><code>view</code></strong><strong>是一种特殊类型的</strong><strong><code>Range</code></strong>，它提供了<strong>对现有</strong><strong><code>Range</code></strong><strong>的一个“视图”</strong>，<code><mark class="highlight-purple"><strong>Range</strong></mark></code><mark class="highlight-purple"><strong>的一个视图也可以理解为就是针对</strong></mark><mark class="highlight-purple"><strong><code>Range</code></strong></mark><mark class="highlight-purple"><strong>的一种操作</strong></mark>（这个操作不作用在<code>Range</code>本身，而是通过“视图”的方式展示出来）</li></ul><ul id="84f762c7-2ac9-45b3-bf02-d0a8e8e128c1" class="bulleted-list"><li style="list-style-type:circle"><code>view</code><mark class="highlight-red"><strong>本身不拥有数据</strong></mark>，而是<span style="border-bottom:0.05em solid"><mark class="highlight-purple"><strong>引用或转换</strong></mark></span><mark class="highlight-purple"><strong>自一个现有的</strong></mark><mark class="highlight-purple"><strong><code>Range</code></strong></mark>(如容器或其他view)，在对Range作用一个操作后，就会变成一个view<blockquote id="ace3bcdf-462a-4d85-aaaf-7cb61d9eb718" class="block-color-gray_background">view的这个特性继承了函数式编程的特点</blockquote></li></ul><ul id="7dcff054-90ae-475e-8517-ee114504c126" class="bulleted-list"><li style="list-style-type:circle"><strong>惰性求值</strong>：<code>view</code>通常设计为轻量级，并且可以<mark class="highlight-purple"><span style="border-bottom:0.05em solid"><strong>懒惰地进行计算</strong></span></mark>，这意味着它们<strong>在需要时才计算元素的值</strong>，从而提高了效率，节省了内存。</li></ul></li></ul><ul id="88b2c523-7a31-4630-b757-d26528874c0f" class="bulleted-list"><li style="list-style-type:disc"><code>Range</code>与<code>view</code>的一些<span style="border-bottom:0.05em solid"><strong>关键区别</strong></span><ol type="1" id="320bc0d5-4022-4cd8-a514-ca5cc349f88a" class="numbered-list" start="1"><li><strong>所有权和数据复制</strong>：<ul id="ae38e2eb-ceb2-41fa-8e68-7f3eef1ce4f6" class="bulleted-list"><li style="list-style-type:disc"><code>Range</code>：用于表示数据的整个集合，<strong>拥有自己的数据</strong>，<strong>可以直接修改数据</strong>。</li></ul><ul id="5a4b260d-ac2a-42ed-aa10-85d89dedf586" class="bulleted-list"><li style="list-style-type:disc"><code>View</code>：不拥有数据，<mark class="highlight-purple"><span style="border-bottom:0.05em solid"><strong>只是引用或提供对现有数据的不同视角</strong></span></mark>。因此，view通常<mark class="highlight-purple"><span style="border-bottom:0.05em solid"><strong>不涉及数据的复制</strong></span></mark>。<br/><br/><code>view</code>用于<span style="border-bottom:0.05em solid"><strong>以不同方式查看和操作数据的子集或转换</strong></span>，例如筛选、转换或延迟计算。例如，<code>std::ranges::filter_view</code> 或 <code>std::ranges::transform_view</code> 提供了对原始数据的过滤或转换视图。</li></ul></li></ol><ol type="1" id="6ad04ae1-922f-436b-8f72-e5c0966727f1" class="numbered-list" start="2"><li><strong>性能考虑</strong>：<ul id="14d09aca-31af-455c-8582-2d32d5a54d63" class="bulleted-list"><li style="list-style-type:disc"><code>Range</code>：可能因为<span style="border-bottom:0.05em solid"><strong>拥有数据而具有更大的性能和内存影响</strong></span>。</li></ul><ul id="b1e7c121-5731-42e6-b60e-8d4af247cec8" class="bulleted-list"><li style="list-style-type:disc"><code>View</code>：通常更轻量级，有更低的性能和内存开销，因为它们避免了数据的复制和拥有。</li></ul></li></ol></li></ul><h3 id="cfbe9edf-a38c-478a-8d67-e543c8dcb6f0" class="block-color-blue_background">一些用例</h3><ul id="1593d20f-de13-408d-8a0a-73e374079fa4" class="bulleted-list"><li style="list-style-type:disc">多个<code>view</code>组成函数链 ：<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="4a4aa8ab-00fc-42a1-a3d4-6ad26a5b1901" class="code"><code class="language-C++">std::vector&lt;int&gt; v = {1, 2, 3, 4, 5};
auto even = [](int i){ return i % 2 == 0; };
auto square = [](int i){ return i * i; };

for (auto i : v | std::views::filter(even) | std::views::transform(square)) {
    std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;  // 输出: 4 16
}</code></pre></li></ul><ul id="523bf0fc-4f9f-4b1e-88f6-d158260caac0" class="bulleted-list"><li style="list-style-type:disc">使用std::ranges直接对<code>Range</code>进行操作（就像algorithm算法一样直接操作容器）<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="b41e8135-4cd1-4748-95fb-9102822e4e56" class="code"><code class="language-C++">std::vector&lt;int&gt; v = {1, 2, 3, 4, 5};
if (auto it = std::ranges::find(v, 3); it != v.end()) {
    std::cout &lt;&lt; &quot;Found: &quot; &lt;&lt; *it &lt;&lt; &quot;\n&quot;;
}</code></pre><ul id="e4979c4c-0fe8-4b06-8151-979689e2c551" class="bulleted-list"><li style="list-style-type:circle">⚠️：std::ranges直接操作一个Range后，<mark class="highlight-red"><span style="border-bottom:0.05em solid"><strong>返回的是一个view</strong></span></mark></li></ul></li></ul><ul id="bcea8ac1-44fc-474f-9aab-057c47c8765d" class="bulleted-list"><li style="list-style-type:disc">自定义一个<code>view</code> <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="ad524eb7-2cc1-4330-a492-3ae9bf3f5d2f" class="code"><code class="language-C++">auto custom_view = std::views::transform(square) | std::views::filter(even);
for (auto i : v | custom_view) {
    std::cout &lt;&lt; i &lt;&lt; &quot; &quot;;
}</code></pre></li></ul><h3 id="797952b6-9882-4dab-870a-9be4c8763c91" class="block-color-blue_background">std::views支持的操作</h3><ul id="db0c2541-1cc3-4a53-88fe-26f5969c010f" class="bulleted-list"><li style="list-style-type:disc"><code>std::views</code>中<span style="border-bottom:0.05em solid"><mark class="highlight-purple"><strong>提供了很多针对</strong></mark></span><span style="border-bottom:0.05em solid"><mark class="highlight-purple"><strong><code>Range</code></strong></mark></span><span style="border-bottom:0.05em solid"><mark class="highlight-purple"><strong>的视图类型</strong></mark></span><strong>，</strong><span style="border-bottom:0.05em solid"><mark class="highlight-red"><strong>这些视图可以通过 </strong></mark></span><mark class="highlight-red"><strong><code>|</code></strong></mark><span style="border-bottom:0.05em solid"><mark class="highlight-red"><strong> 运算符来进行连接</strong></mark></span><blockquote id="5da1851e-bc26-4af7-a39e-bc12542c253f" class="block-color-gray_background">⚠️：<code>view</code>本身就是特殊的<code>Range</code>，所以<code>view</code>可以作用在<code>view</code>上</blockquote><ul id="03a12c39-0282-40d3-866b-fc7853f51fa2" class="bulleted-list"><li style="list-style-type:circle"><code><strong>views::filter</strong></code>: 过滤视图，基于条件函数过滤元素</li></ul><ul id="05015b71-7296-43f4-9b74-24507ce69929" class="bulleted-list"><li style="list-style-type:circle"><code><strong>views::transform</strong></code>: 转换视图，对每个元素应用一个函数</li></ul><ul id="44bf9824-10e0-461e-8c79-4a8b5bd7adc3" class="bulleted-list"><li style="list-style-type:circle"><code><strong>views::take</strong></code>: 取值视图，只取序列的前N个元素</li></ul><ul id="23d46de3-59cb-401d-9fca-5495484f752e" class="bulleted-list"><li style="list-style-type:circle"><code><strong>views::drop</strong></code>: 跳过视图，跳过序列的前N个元素</li></ul><ul id="1fe72fd7-fd5e-4a9b-99da-ae28f9af3046" class="bulleted-list"><li style="list-style-type:circle"><code><strong>views::reverse</strong></code>: 反转视图，反转序列</li></ul><ul id="09e22834-1cb5-4ee8-93e0-20da4420c703" class="bulleted-list"><li style="list-style-type:circle"><code><strong>views::split</strong></code>: 拆分视图，根据指定分隔符拆分序列，<strong>不止适用于字符串</strong></li></ul><ul id="5ac4ebb2-0f1a-48a6-81aa-7ad27d150b70" class="bulleted-list"><li style="list-style-type:circle"><code><strong>views::join</strong></code>: 连接视图，连接多个序列（传入的是一个序列of序列，然后变成一个更长的序列）</li></ul><ul id="fa293173-db7b-4e86-aacb-7750bb51c6dc" class="bulleted-list"><li style="list-style-type:circle"><code><strong>std::views::concat</strong></code>：连接视图，连接两个独立的序列（传入的是两个序列，然后变成一个更长的序列）</li></ul><ul id="2f20b9d9-23c9-4571-b638-74d2bfb8005e" class="bulleted-list"><li style="list-style-type:circle"><strong><code>views::all</code></strong>: 用于将已有的<code>Range</code>显式地转换为一个<code>view</code>（虽然view本身就是特殊的Range）<blockquote id="fec266a0-61fb-4924-83a7-4f344bc11985" class="block-color-gray_background">例如，<code>views::all(v)</code> 会创建一个代表整个 <code>v</code> 容器的视图</blockquote></li></ul><ul id="d686f8df-8417-499a-a45f-be9148c1233e" class="bulleted-list"><li style="list-style-type:circle"><code><strong>views::empty</strong></code>: 生成一个空的视图。这在某些算法中作为默认参数很有用</li></ul><ul id="ab8e2da9-f134-4eb1-8151-9e4c6068f5e6" class="bulleted-list"><li style="list-style-type:circle"><code><strong>views::iota</strong></code>: 生成一个包含连续整数的范围<blockquote id="e9c37ff1-cefd-4c32-8bb1-c98478e6fe1b" class="block-color-gray_background">例如，<code>views::iota(0, 10)</code> 会生成一个从 0 到 9 的整数序列</blockquote></li></ul><ul id="3f137954-5d49-4b8a-8f85-b675c20723c2" class="bulleted-list"><li style="list-style-type:circle"><code><strong>views::single</strong></code>: 生成一个只包含一个元素的视图<blockquote id="b6c6b252-bfd7-412a-bbd8-18f7659843c2" class="block-color-gray_background">例如，<code>views::single(x)</code> 会生成一个只包含 <code>x</code> 的视图</blockquote></li></ul><ul id="998a57a6-17ce-45ce-8dc4-558709f5d20b" class="bulleted-list"><li style="list-style-type:circle"><code><strong>views::keys</strong></code><code> 和 </code><code><strong>views::values</strong></code>: 当处理 <code>map</code> 或类似关联容器时，这些视图分别允许单独访问键或值<blockquote id="5dfb86fe-37b9-4b77-bc12-db7924e015d3" class="block-color-gray_background">例如，<code>views::keys(map)</code> 会生成一个包含 <code>map</code> 所有键的视图</blockquote></li></ul></li></ul><ul id="36206cbb-1b73-49af-9f84-a8c1d4e4d89c" class="bulleted-list"><li style="list-style-type:disc">大多数支持随机索引的<code>Range</code>在经过某个<code>view</code>后，会<strong>变成一个不支持随机索引的</strong><strong><code>Range</code></strong><blockquote id="4d48aba9-0b6a-4175-9c51-e31c296cef0f" class="block-color-gray_background">例如一个支持随机索引的vector (vector也是一个Range)，在经过某个view后(例如views::transform)，这个view会不支持随机索引。</blockquote></li></ul><h3 id="8db35b94-d289-4580-be18-e80da79d4937" class="block-color-blue_background">std::ranges</h3><figure id="3e12c3d0-313e-4b20-b7e7-5d0e2af6872f"><a href="https://en.cppreference.com/w/cpp/algorithm" class="bookmark source"><div class="bookmark-info"><div class="bookmark-text"><div class="bookmark-title">Algorithms library - cppreference.com</div><div class="bookmark-description">The algorithms library defines functions for a variety of purposes (e.g. searching, sorting, counting, manipulating) that operate on ranges of elements. Note that a range is defined as [first, last) where last refers to the element past the last element to inspect or modify.</div></div><div class="bookmark-href"><img src="https://en.cppreference.com/favicon.ico" class="icon bookmark-icon"/>https://en.cppreference.com/w/cpp/algorithm</div></div></a></figure><ul id="b55ca694-cfe6-4507-bdd2-62e1fed34f48" class="bulleted-list"><li style="list-style-type:disc"><code>std::ranges</code>中<mark class="highlight-purple"><strong>提供了很多针对</strong></mark><mark class="highlight-purple"><strong><code>Range</code></strong></mark><mark class="highlight-purple"><strong>的</strong></mark><mark class="highlight-red"><strong>算法</strong></mark>，绝大部分在<a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">algorithm</a>库针对容器的算法，在std::ranges都能找到对应的实现<ul id="33c5081d-7cdf-4fa0-a10f-f0c71aae7e16" class="bulleted-list"><li style="list-style-type:circle"><strong>std::ranges库的API比algorithm更好用一些</strong>，它既<span style="border-bottom:0.05em solid"><strong>可以传入一个Range对某个子范围，也可以直接传入一个Range</strong></span>（传入整个Range后，就是作用于整个Range）</li></ul><blockquote id="ed4e8d51-c855-43fe-8152-f87bf34090e3" class="block-color-gray_background">注意std::ranges与std::views的区别：<strong>std::ranges提供的是算法，而std::views提供的是视图类型</strong></blockquote></li></ul><ul id="dfa1e5fa-1030-419d-871f-c868032cf473" class="bulleted-list"><li style="list-style-type:disc">std::ranges直接操作一个Range后，<mark class="highlight-red"><span style="border-bottom:0.05em solid"><strong>返回的是一个view</strong></span></mark></li></ul><ul id="9a9e0212-4b8a-4c68-bc97-46492dbcbd74" class="bulleted-list"><li style="list-style-type:disc"><code><strong>std::ranges::find</strong></code>: 对范围内的元素查找某个元素，找不到时返回range.end()</li></ul><ul id="eba5f73d-ebec-4193-961f-c6cd24cb6d04" class="bulleted-list"><li style="list-style-type:disc"><code><strong>std::ranges::search</strong></code>: 对范围内的元素查找某个子序列，找不到时返回range.end()</li></ul><ul id="50bd0f2c-cf19-41dd-9cb4-4690ae50e6eb" class="bulleted-list"><li style="list-style-type:disc"><code><strong>std::ranges::sort</strong></code>: 对范围内的元素进行排序。</li></ul><ul id="243afe74-80a6-4e37-b059-03ffe182d6ab" class="bulleted-list"><li style="list-style-type:disc"><code><strong>std::ranges::copy</strong></code>: 复制范围内的元素到另一个目的地。</li></ul><ul id="9e98db29-b58a-4c69-9920-989129295f64" class="bulleted-list"><li style="list-style-type:disc"><code><strong>std::ranges::all_of</strong></code>, <code><strong>std::ranges::any_of</strong></code>, <code><strong>std::ranges::none_of</strong></code>: 检查元素是否满足特定条件。</li></ul><ul id="38bf59ba-152f-492a-af6e-b505b449b111" class="bulleted-list"><li style="list-style-type:disc"><code><strong>std::ranges::for_each</strong></code>: 对范围内的每个元素执行一个函数。</li></ul><ul id="fe5db0ff-d9dc-4185-97bb-4b839ed1b02e" class="bulleted-list"><li style="list-style-type:disc"><code><strong>std::ranges::count</strong></code>: 计算满足特定条件的元素数量。</li></ul><h2 id="4e1f4490-3879-4b92-ba39-897238f03cfa" class="block-color-orange_background">std::optional模版类：提供类型安全</h2><h3 id="23db45b0-7239-400c-b663-e37c179ace35" class="block-color-blue_background">Undefined behavior</h3><ul id="0c70a858-0f65-4cea-a6c8-28b384deb744" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><em><strong>Undefined behavior</strong></em></span>：未定义行为，即执行函数时不会按照返回某个预期值，而是返回垃圾值（随机值）、也可以返回一些真实值（但不是预期值），甚至直接崩溃<ul id="671b0d7f-c23f-4864-8032-6895c64ae768" class="bulleted-list"><li style="list-style-type:circle">例如vec.back()（获取vector中最后一个元素）在vec为空时会发生<strong>未定义行为</strong>；</li></ul><ul id="e55d8d89-c6a9-4dfc-8f6e-dc1f0e56a787" class="bulleted-list"><li style="list-style-type:circle">例如取索引out of range时会发生Undefined behavior<figure id="3fc5813c-33c3-4c09-9b18-ecbda2ef14a3" class="image" style="text-align:center"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-01-24_20.24.27.png"><img style="width:480px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-01-24_20.24.27.png"/></a></figure></li></ul></li></ul><h3 id="f0cd0451-ae6b-4ea2-8b76-02625e3ffd83" class="block-color-blue_background">std::optional与nullopt</h3><ul id="7fce5005-e65f-4a85-8249-a29c1b6814cc" class="bulleted-list"><li style="list-style-type:disc"><strong><code>std::optional</code></strong>：<mark class="highlight-purple"><span style="border-bottom:0.05em solid"><strong>一个模版类</strong></span></mark>，可以用于包装其它的类，<blockquote id="e7faa615-d6d2-4f46-bc6e-a22b1be7d8e3" class="block-color-gray_background">由于是一个模版类，<mark class="highlight-default">所以可以传入一个类型，从而将模版类进行实例化，例如：<br/><br/></mark><code>std::optional&lt;int&gt;</code>、<code>std::optional&lt;myclass&gt;</code><br/><br/>当把这个模版类实例化以后，就会得到一个真正的类（所以std::optional才可以包装其它的类）<br/></blockquote><ul id="83426cac-d357-4b2b-bfba-a5fa6b728c78" class="bulleted-list"><li style="list-style-type:circle">当使用<code>std::optional&lt;int&gt;</code>或<code>std::optional&lt;myclass&gt;</code>时，表示一个新的类型，这个类型在int/myclass 类型的基础上<strong>额外提供了一种新的“空类型”</strong>，这个”空类型<strong>”用</strong><strong><code>nullopt</code></strong><strong>来表示</strong><figure id="d2e90015-3fc7-474f-bec3-e72d8e57d36d" class="image"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-01-24_20.51.32.png"><img style="width:528px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-01-24_20.51.32.png"/></a></figure></li></ul><ul id="396e617b-ff2c-43ae-abe1-e36b305fea3f" class="bulleted-list"><li style="list-style-type:circle"><strong>使用场景</strong>：比如获取一个int vector的最后一个元素时(vec.back())，可以把这个back函数的返回值写成std::optional&lt;int&gt;，这样就可以在vector为空时，仍保证类型安全（返回一个<code>nullopt</code>，而不是造成Undefined behavior），并且能让这个情况（vector为空）让程序员获知</li></ul></li></ul><ul id="0b8796de-0c2e-40b8-adba-da32b878eea0" class="bulleted-list"><li style="list-style-type:disc"><strong><code>nullopt</code></strong>与<strong><code>nullptr</code></strong>的区别：<code>nullptr</code> 和 <code>nullopt</code> 在 C++ 中用于表示不同类型的“无值”或“空”状态，它们的用途和含义各不相同。<ol type="1" id="698f64cb-8c46-41ba-83bf-6883026e2664" class="numbered-list" start="1"><li><code><strong>nullptr</strong></code>：<ul id="ad003bef-c861-4fe6-b1e5-3cb0c2e5337d" class="bulleted-list"><li style="list-style-type:disc">nullptr 是 C++11 引入的一个字面量，用于表示空指针。</li></ul><ul id="62ece850-9093-457e-b88e-c77ac1eabfb6" class="bulleted-list"><li style="list-style-type:disc">它是 std::nullptr_t 类型的唯一值，<span style="border-bottom:0.05em solid"><strong>可以转换为任何原生指针类型。</strong></span></li></ul><ul id="34a2139a-cbe1-420a-8ff9-da0cce02a231" class="bulleted-list"><li style="list-style-type:disc"><code>nullptr</code> 的主要用途是提供一种清晰、类型安全的方式来表示空指针，取代了以前使用的 <code>NULL</code>。</li></ul></li></ol><ol type="1" id="9004b85e-7133-401d-95f4-419d27f8a6c1" class="numbered-list" start="2"><li><code><strong>nullopt</strong></code>：<ul id="0a19c111-63b5-45c7-8c6b-2b5beb62284d" class="bulleted-list"><li style="list-style-type:disc"><code>nullopt</code> 是 C++17 引入的一个字面量，用于表示 <code>std::optional</code> 类型的空状态。</li></ul><ul id="bd94ce4e-7211-49e1-8542-7b71968251c6" class="bulleted-list"><li style="list-style-type:disc"><code>std::optional</code> 是一个模板类，用于表示可能包含值也可能不包含值的情况。</li></ul><ul id="427e869d-9898-4be6-ac0c-3fbbf3649554" class="bulleted-list"><li style="list-style-type:disc">当有一个 <code>std::optional&lt;T&gt;</code> 类型的对象时，使用<code>nullopt</code>可以明确地表示该对象不包含任何值。</li></ul></li></ol><p id="72c6b47c-0b8d-4b9f-8b37-d8822bb973a4" class="">总结起来，<code><strong>nullptr</strong></code> 用于指针类型，而 <code><strong>nullopt</strong></code> 用于 <code><strong>std::optional</strong></code> 类型。它们都表达了“无值”的概念，但应用于不同的上下文和类型。</p></li></ul><ul id="3dc59ff0-d9ca-4507-8508-50da7a41ef06" class="bulleted-list"><li style="list-style-type:disc"><strong>用</strong><code><strong>std::optional&lt;ValueType&gt;</strong></code><strong>定义一个函数的返回值类型时</strong>，<em><span style="border-bottom:0.05em solid">return {}就相当于return一个std::nullopt</span></em><ul id="f3a9abc2-ace1-405e-91ba-fe8d8823925d" class="bulleted-list"><li style="list-style-type:circle">但这不是一个good pratice，应该清楚地直接return std::nullopt</li></ul></li></ul><ul id="f158d453-68d0-46db-9037-0af4c074925b" class="bulleted-list"><li style="list-style-type:disc"><strong>用</strong><strong><code>std::optional&lt;ValueType&gt; x = {}</code></strong><strong>定义并初始化一个变量时</strong>，就相当于给x的初始值为std::nullopt<ul id="4144e5ab-8954-4553-ab55-681c53350427" class="bulleted-list"><li style="list-style-type:circle">但这不是一个good pratice，应该直接进行清楚地定义<code>std::optional&lt;ValueType&gt; x = std::nullopt</code></li></ul></li></ul><h3 id="3a72c194-ac4f-43ba-99e1-53822f430b63" class="block-color-blue_background">std::optional&lt;ValueType&gt;模版类提供的类方法</h3><ul id="df6dae36-13b0-482a-8aed-d554f5f63243" class="bulleted-list"><li style="list-style-type:disc"><code><strong>std::optional</strong></code><span style="border-bottom:0.05em solid"><strong>模版类</strong></span><mark class="highlight-purple"><span style="border-bottom:0.05em solid"><strong>无法直接进行算数运算</strong></span></mark>，必须先取到里面的值</li></ul><ul id="a9ee70fa-1493-4324-a42a-cef40b36536a" class="bulleted-list"><li style="list-style-type:disc">std::optional&lt;ValueType&gt;模版类提供的类方法：<ul id="e7c91b16-f26c-4afe-b333-3629a6d65fcd" class="bulleted-list"><li style="list-style-type:circle"><code><em><strong>.has_value()</strong></em></code>：判断是否有值<ul id="7c813a8d-9d10-4563-9b0e-acb9f154d6d1" class="bulleted-list"><li style="list-style-type:square">也可以直接用if来进行判断</li></ul></li></ul><ul id="4b6700e6-1eac-4797-b3f5-a9bdae8921dc" class="bulleted-list"><li style="list-style-type:circle"><em><strong><code>.value()</code></strong></em>：<strong>returns the contained value</strong> or throws <strong><em><code>bad_optional_access</code></em></strong> error<ul id="403632e9-fd2e-4f9c-a0f0-963b22ae5a66" class="bulleted-list"><li style="list-style-type:square">也可以直接用*来解引用，拿出对应的值（对应ValueType的实例）</li></ul></li></ul></li></ul><h3 id="98ecaa62-5882-4dd1-9a03-f2c4b93bcb20" class="block-color-blue_background">std::optional&lt;Myclass&gt;与自定义类的构造函数之间的关系</h3><ul id="f2ec1c17-a1d9-41a6-b33a-50322a97cc3f" class="bulleted-list"><li style="list-style-type:disc">使用<code><strong>std::optional&lt;Myclass&gt;</strong></code>时，调用<code>std::optional&lt;Myclass&gt; foo</code>或<code>std::optional&lt;Myclass&gt; foo{}</code>都会<mark class="highlight-purple"><strong>调用std::optional模版类的构造函数</strong></mark>，此时foo会<mark class="highlight-red"><strong>被初始化为</strong></mark><mark class="highlight-red"><code><em><strong>nullopt</strong></em></code></mark>（而不是调用Myclass的无参构造函数）<ul id="569c21e8-a335-44fa-a076-099b6ae7d178" class="bulleted-list"><li style="list-style-type:circle">所以此时如果想调用Myclass的无参构造函数，就必须用<code>std::optional&lt;Myclass&gt; foo = Myclass()</code></li></ul></li></ul><div id="c86ba0d7-3030-41e4-886a-df098f16c43e" class="column-list"><div id="20234581-cff9-46b0-bb36-6826ba80cd58" style="width:56.25%" class="column"><figure id="41f39562-6cb4-483c-b027-6ccfa30a6339" class="image" style="text-align:center"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-01-24_21.49.18.png"><img style="width:432px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-01-24_21.49.18.png"/></a></figure></div><div id="bed539dc-c27a-4a9f-a288-85dc65b80796" style="width:43.75000000000001%" class="column"><p id="729fd679-01de-4f18-8e10-f9721a553a37" class=""><div class="indented"><figure id="cd78ba8a-49b0-4dd9-9b27-4370d28be884" class="image" style="text-align:center"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-01-24_21.49.40.png"><img style="width:288px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-01-24_21.49.40.png"/></a></figure><p id="d6664bba-6b56-4987-bcc7-ba3a46a384c8" class="">
</p></div></p></div></div><h3 id="f84e827e-0932-42af-bf02-a29e38757ea4" class="block-color-blue_background">使用std::optional的pros and cons</h3><ul id="e6400a45-d5a7-45cc-ab40-920c66e6930b" class="bulleted-list"><li style="list-style-type:disc">使用<code>std::optional</code>带来的<strong>好处</strong>：带来了类型安全，防止了Undefined behavior</li></ul><ul id="f4de9392-2d83-434c-a47d-99e4db0a3b38" class="bulleted-list"><li style="list-style-type:disc">使用<code>std::optional</code>带来的坏处<ul id="43552729-6942-4231-a914-dd0d6fc10a09" class="bulleted-list"><li style="list-style-type:circle">使用起来会更麻烦，要用.value()方法才能拿到原始的值</li></ul><ul id="90f85942-15d9-42ca-8622-0b8e1f554b38" class="bulleted-list"><li style="list-style-type:circle"><mark class="highlight-red"><strong>使用</strong></mark><mark class="highlight-red"><strong><code>std::optional</code></strong></mark><mark class="highlight-red"><strong>时</strong></mark><mark class="highlight-red"><strong><span style="border-bottom:0.05em solid">不能使用引用&amp;</span></strong></mark>，所以会造成性能下降。例如std::optional&lt;T&amp;&gt;这种用法<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2dfeab87-0289-4cbf-b07b-245a579a05e1" class="code"><code class="language-C++">std::optional&lt;int&amp;&gt; foo() {  /* 错误，没有std::optional&lt;T&amp;&gt;这种用法 */
                             /* 因此使用std::optional时只能按值返回，按值传递 */
    ...
}</code></pre><ul id="361016b1-c976-408a-a936-75c2d6e78407" class="bulleted-list"><li style="list-style-type:square">所以使用<code>std::optional</code>作为类型后，只能按值返回，按值传递</li></ul><ul id="32be5155-2c67-4733-8b56-4b5b0e342f3a" class="bulleted-list"><li style="list-style-type:square"><span style="border-bottom:0.05em solid"><strong>然而在很多情况下我们为了性能要求都需要有引用</strong></span></li></ul></li></ul></li></ul><ul id="baf68b6a-d97c-4784-b428-fc7c1a0a3e6e" class="bulleted-list"><li style="list-style-type:disc">但是<span style="border-bottom:0.05em solid"><strong>总的来说，能用std::optional来保证类型安全就尽量用</strong></span>（除非会极大影响性能）<figure id="c41aa69e-11dd-4790-97f5-4fc0b8b4bc7c" class="image" style="text-align:center"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-01-24_22.42.27.png"><img style="width:432px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-01-24_22.42.27.png"/></a></figure></li></ul><h2 id="d7e60c07-2b20-4e63-9837-5940bd6793e1" class="block-color-orange_background">RAII：一种在很多编程语言中具有的实践或者理念</h2><ul id="1650e054-fe1e-432c-97e3-6b43d27acf9c" class="bulleted-list"><li style="list-style-type:disc">How to we ensure that we properly release resources in the case that we have an exception?<figure id="49472ada-54f0-46fc-835e-0961f51c82a7" class="image"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-02-13_13.32.24.png"><img style="width:528px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-02-13_13.32.24.png"/></a></figure></li></ul><ul id="b05d373e-002d-413a-b599-677f6104756f" class="bulleted-list"><li style="list-style-type:disc">So what is RAII(Resource Acquisition Is Initialization)? ：RAII是一种在很多编程语言中具有的实践或者理念<ul id="5b343bce-faf9-4dfd-b9e0-d5a1d428c10d" class="bulleted-list"><li style="list-style-type:circle">All resources used by a class should be acquired in the constructor!</li></ul><ul id="7921c347-6a49-4cf8-8ba2-76f51a2e7564" class="bulleted-list"><li style="list-style-type:circle">All resources that are used by a class should be released in the destructor.</li></ul><blockquote id="3fb52726-6fe3-4f19-9941-468deff6887a" class="block-color-gray_background">可以看到，python的with上下文管理器也是一种RAII实践</blockquote></li></ul><ul id="d44c2b4e-efba-4ac3-97fc-bdbd6558a4b3" class="bulleted-list"><li style="list-style-type:disc">RAII的实践使得<ul id="79ab2549-82cb-44a6-bca2-adb04f25f287" class="bulleted-list"><li style="list-style-type:circle">It turns out that by abiding by the RAII policy we avoid “half-valid” states.</li></ul><ul id="7be81fda-f555-43e7-988d-82380052e9bc" class="bulleted-list"><li style="list-style-type:circle">No matter what, the destructor is called whenever the resource goes out of scope.</li></ul><ul id="3e844553-bf33-4a61-8348-9e62a829d2ab" class="bulleted-list"><li style="list-style-type:circle">One more thing: the resource/object is usable immediately after it is created.</li></ul></li></ul><ul id="4a6ef8cc-9d19-441c-98f3-c7f3ac57ddf7" class="bulleted-list"><li style="list-style-type:disc">以下代码都不满足RAII准则<figure id="bf9c10b3-4adc-4942-a6a4-cb6e9b7f50c1" class="image"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-02-13_13.45.04.png"><img style="width:432px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-02-13_13.45.04.png"/></a><figcaption>如果在open和close中间出了异常，input就不会被close</figcaption></figure><figure id="87f52582-1a13-4934-8a14-b90f9e3d3199" class="image"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-02-13_13.45.38.png"><img style="width:384px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-02-13_13.45.38.png"/></a></figure><ul id="96d14bdd-79aa-4dd7-8127-dac09a1ef094" class="bulleted-list"><li style="list-style-type:circle">可以通过使用lock guard来解决：A lock guard is a RAII-compliant wrapper that attempts to acquire the passed in lock. It releases the the lock once it goes out of scope. Read more <a href="https://en.cppreference.com/w/cpp/thread/lock_guard#:~:text=The%20class%20lock_guard%20is%20a,the%20mutex%20it%20is%20given."><span style="border-bottom:0.05em solid">here</span></a><figure id="1bde3195-79d7-4948-b3b9-91b73e2f17a1" class="image"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-02-13_13.50.06.png"><img style="width:480px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-02-13_13.50.06.png"/></a></figure></li></ul></li></ul><h3 id="36240169-e440-43e6-ab93-5d621de00810" class="block-color-blue_background">智能指针：内存管理的RAII实践</h3><ul id="03831071-73b7-4bd7-bf6c-537e96172071" class="bulleted-list"><li style="list-style-type:disc">bad practice：<span style="border-bottom:0.05em solid"><strong>“裸露地”使用new和delete在大型项目中很容易出bug</strong></span><figure id="85b55548-7c99-488b-87df-b46228e77ac4" class="image" style="text-align:center"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-02-13_14.10.03.png"><img style="width:576px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-02-13_14.10.03.png"/></a><figcaption>来源：<a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#r11-avoid-calling-new-and-delete-explicitly">https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#r11-avoid-calling-new-and-delete-explicitly</a></figcaption></figure><ul id="824c4406-9908-44e4-9ac7-f2b351b8655f" class="bulleted-list"><li style="list-style-type:circle">例如以下代码<figure id="d217da9e-f46a-41f3-8bc7-da77550fd603" class="image"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-02-13_14.27.52.png"><img style="width:528px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-02-13_14.27.52.png"/></a><figcaption>只要在delete p之前出现了任何异常，就会导致内存泄漏，而在这段代码中，有23处产生异常的可能（比如调用拷贝构造函数、==运算符、&lt;&lt;运算符等等）</figcaption></figure></li></ul></li></ul><ul id="fbda8df5-4672-4c62-a301-f229e036e2d7" class="bulleted-list"><li style="list-style-type:disc">所以一个good practice就是（<mark class="highlight-red"><strong>一种最典型的RAII实践</strong></mark>）：<strong>构造要管理的对象的构造函数和析构函数</strong>，在创建对象时通过构造函数来获取资源时，在对象out of scope（或者被显示地置空）通过析构函数释放资源，这样即使发生了异常，只要对象out of scope了，就会调用对应的析构函数。<blockquote id="7f22e165-20e7-4402-bca7-bc66b483d0c6" class="block-color-gray_background"><mark class="highlight-red"><strong>简单来说就是</strong></mark>：<strong>定义一个node类</strong>，<strong>定义好里面的析构函数和构造函数</strong>，<br/>然后<br/><mark class="highlight-purple"><strong>通过foo的构造函数</strong></mark><strong>，即</strong><strong><em><code>node foo{}</code></em></strong><strong>来获取资源</strong>，这样就是一个RAII的实践。<br/><br/>而不是像平常那样定义一个node结构体，<br/>然后通过<br/><em><code>node* foo = new(node)</code></em>，显示地用<em><code>new</code></em>来申请资源，这种做法就不是一个RAII实践（在<strong>裸露的使用new，bad practice</strong>，<mark class="highlight-purple"><strong>除非使用智能指针</strong></mark>）<br/><br/>因此，通过构造函数来获取资源就是good practice，通过new来获取资源就是bad practice；<br/><br/>使用构造函数获取资源就不需要管理内存，使用new就需要自己管理，很容易出bug（这也是为什么在使用std提供的容器时，可以像在python中一样完全不用去考虑内存管理的问题）<br/></blockquote></li></ul><ul id="a016e612-78ae-43ab-86e9-545767b59f45" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-red"><strong>智能指针</strong></mark>：<strong>有时候难免会在项目中显示地使用new（</strong>因为某个对象可能不会频繁使用，专门为这个对象定义一个类会使得代码很啰嗦），<strong>此时就需要通过智能指针在这种情况下（裸露的使用new）实现RAII实践</strong><ul id="3d37d70c-803e-49ba-a8e3-7e6723c81108" class="bulleted-list"><li style="list-style-type:circle">因此智能指针就是实现了RAII理念(RAII-compliant)的内存管理<figure id="19c82a94-7c5f-4847-82db-a1fe4ba79a81" class="image"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-02-13_14.31.07.png"><img style="width:480px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-02-13_14.31.07.png"/></a></figure></li></ul></li></ul><ul id="e04a8025-560e-4090-b96d-2805942c085b" class="bulleted-list"><li style="list-style-type:disc">有三种RAII-compliant指针<figure id="3b78de27-9b03-40c5-bf84-f6a677da24f5" class="image"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-02-13_14.41.47.png"><img style="width:528px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-02-13_14.41.47.png"/></a><figcaption>或者显示地把指针置空（nullptr），也算out of scope</figcaption></figure><blockquote id="859b2108-a210-4b6c-aa3e-d0c19721763d" class="block-color-gray_background">有关<strong>变量的作用域</strong>：在函数中定义的变量作用域就在这个函数中；在类中定义的变量作用域在这个类。<br/><br/>⚠️：作用域取决于定义的位置，如果定义和声明变量时位于不同的作用域，实际的作用域是定义时所在的作用域<br/></blockquote></li></ul><ul id="180e80ae-cdf9-4fce-b2e6-d6a1358618bb" class="bulleted-list"><li style="list-style-type:disc"><span style="border-bottom:0.05em solid"><strong>一种out of scope常见情况</strong></span>：<span style="border-bottom:0.05em solid"><mark class="highlight-purple"><strong>智能指针作为类成员</strong></mark></span>，<mark class="highlight-red"><strong>当这个类的对象被销毁时，作为类成员的智能指针此时就会发生out of scope<br/><br/></strong></mark><span style="border-bottom:0.05em solid"><strong><mark class="highlight-default">因此当一个链表的node中，next指针是一个智能指针时，释放一个node会导致连环释放</mark></strong></span></li></ul><ul id="2a59d241-34fe-425d-a776-fdd067e5a7c7" class="bulleted-list"><li style="list-style-type:disc">用法<figure id="0eaddb40-a0c7-4463-aa27-d2dbe89319e8" class="image"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-02-13_14.43.21.png"><img style="width:432px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-02-13_14.43.21.png"/></a><figcaption>实例化时传入一个指针，指针类型要与模版化时的类型保持一致</figcaption></figure></li></ul><ul id="79320724-8f1d-488a-acba-baf2cab7ef22" class="bulleted-list"><li style="list-style-type:disc"><em><code><strong>std::unique_ptr</strong></code></em>：只能唯一拥有自己的资源，不能被复制<figure id="980df3f7-ddc8-402c-b499-f3b536f189a8" class="image"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-02-13_14.46.13.png"><img style="width:528px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-02-13_14.46.13.png"/></a><figcaption>因为可能在拷贝前，资源被释放了，导致copy指向了一个被释放的内存上</figcaption></figure><ul id="1940a303-6f51-49e5-9a97-7271e827b146" class="bulleted-list"><li style="list-style-type:circle">当将一个<em><code>std::unique_ptr</code></em>设置为<code><em>nullptr</em></code>或者指针out of scope时，以下步骤会发生：<ol type="1" id="16fb2c35-5a39-4b43-8d84-4ded47b00013" class="numbered-list" start="1"><li><em><code>std::unique_ptr</code></em>会检查它是否当前拥有（指向）一个对象。</li></ol><ol type="1" id="376ec3df-62e8-4f17-8f2e-0f71566a1995" class="numbered-list" start="2"><li>如果是，它会销毁（释放）这个对象。</li></ol><ol type="1" id="e029b2b9-3f87-4f30-be25-a659bb15a533" class="numbered-list" start="3"><li>假如是被置为nullptr的情况：然后，它会接受新的值，这里是<em><code>nullptr</code></em>，意味着它不再指向先前管理的那个对象。</li></ol></li></ul><ul id="06f3a1ae-949c-4a05-af5d-dfbc847f69b4" class="bulleted-list"><li style="list-style-type:circle"><mark class="highlight-red"><strong>⚠️注意点1⚠️</strong></mark>：由于<em><code>unique_ptr</code></em>不能用于指针的赋值，所以一种解决方法是：<span style="border-bottom:0.05em solid"><strong>在赋值前把指针转为右值</strong></span>。以下面这个智能指针链表为例：<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="4753b808-b39d-41dd-b77d-9ef681535c10" class="code"><code class="language-C++">#include &lt;memory&gt; // 引入智能指针的头文件

struct node {
    using namespace node_ptr = std::unique_ptr&lt;node&gt;;
    value_type value;
    node_ptr next; // 使用std::unique_ptr代替原生指针

    node(const value_type&amp; value = value_type{}, node_ptr next = nullptr) :
        value{value}, next{std::move(next)} {} // 注意这里使用std::move来转移所有权
};</code></pre></li></ul><ul id="34ed38b6-6fa8-4674-a03c-e2483ddf67f2" class="bulleted-list"><li style="list-style-type:circle"><mark class="highlight-red"><strong>⚠️注意点2⚠️</strong></mark><mark class="highlight-default">：当在自定义类中使用unique_ptr智能指针时，可能会无法使用默认的构造函数、拷贝构造函数、赋值运算符，</mark><span style="border-bottom:0.05em solid"><strong><mark class="highlight-default">因为默认的实现会直接对unique_ptr指针进行拷贝</mark></strong></span><mark class="highlight-default">（而不是通过move先转成右值）</mark><blockquote id="14cf3dd1-1393-4830-9226-526527121765" class="block-color-gray_background">所以由于unique_ptr过于严格，通常都会用shared_ptr</blockquote></li></ul></li></ul><ul id="b55e7ce9-e626-4b9b-a60e-ea46efe4ece8" class="bulleted-list"><li style="list-style-type:disc"><em><strong><code>std::shared_ptr</code></strong></em>：可以被复制，当所有共享指针out of scope后，即这个内存的指针（地址）<span style="border-bottom:0.05em solid"><mark class="highlight-purple"><strong>引用计数</strong></mark></span>变为0，资源才会被释放（这也是python进行资源管理的方式，<strong>可以说python默认使用的智能指针就是shared_ptr</strong>）<blockquote id="4c31cd7d-1e3b-4075-8d01-d07f3db43879" class="block-color-gray_background">所以shared_ptr时通过引用计数来管理一个共享的地址的</blockquote><ul id="8d0d72df-db0b-40f3-afa6-5bdaef4e70dc" class="bulleted-list"><li style="list-style-type:circle">当将一个<code><em>std::share_ptr</em></code>设置为<code><em>nullptr</em></code>或者指针out of scope时，以下步骤会发生：<ol type="1" id="dcfd4f2c-b36f-4754-ace3-2f84246d41eb" class="numbered-list" start="1"><li>它会<strong>减少当前对象(指针，也即某块内存对应的地址)的引用计数</strong>。</li></ol><ol type="1" id="630df5b6-e477-4a09-9c87-836bc46b6efc" class="numbered-list" start="2"><li>如果这个引用计数变为0（意味着没有其他<code><strong>std::shared_ptr</strong></code>实例再指向这个对象），对象会被销毁。</li></ol><ol type="1" id="e6b13155-6985-4c0f-bfef-cf736a216226" class="numbered-list" start="3"><li><code><strong>std::shared_ptr</strong></code>接着会被设置为<code><strong>nullptr</strong></code>，表示它不再指向任何对象。</li></ol></li></ul></li></ul><ul id="b70fd3db-8b7c-4f13-b5a5-5e065df09df3" class="bulleted-list"><li style="list-style-type:disc">初始化一个智能指针，并申请对应的内存：<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="70244b38-740b-4840-81fb-aa64c2fd2bbb" class="code"><code class="language-C++">auto foo = std::unique_ptr&lt;MyClass&gt;{new MyClass{}};
std::unique_ptr&lt;MyClass&gt; bar{new MyClass{}};</code></pre></li></ul><ul id="f549c9fc-3bac-4ec3-ae74-f0b4c2753eea" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-purple"><strong>初始化一个智能指针</strong></mark><strong>：使用</strong><em><code><strong>std::make_unique&lt;T&gt;</strong></code></em><strong>、</strong><em><code><strong>std::make_shared&lt;T&gt;</strong></code></em><strong>来，而不是通过</strong><em><code>new T</code></em>：因为这样会导致两次内存分配（指针本身一次，new T时一次）例如<ul id="38849721-1cee-462d-9f69-e8193a914e94" class="bulleted-list"><li style="list-style-type:circle">bad case<figure id="8f467893-bf35-4f7d-8606-c3efaee68586" class="image"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-02-13_15.13.39.png"><img style="width:432px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-02-13_15.13.39.png"/></a></figure></li></ul><ul id="d0fa181b-88fc-45cd-a5f4-4e180c32d678" class="bulleted-list"><li style="list-style-type:circle">good case <figure id="d3c3248b-b898-420b-aab5-1a3188b3a4fa" class="image"><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-02-13_15.17.14.png"><img style="width:432px" src="CPP%2099ebd66f69ef430782fa4d74512a2c5b/%25E6%2588%25AA%25E5%25B1%258F2024-02-13_15.17.14.png"/></a></figure></li></ul></li></ul><h2 id="4f898396-ad25-4292-8c89-5a879df5bf77" class="block-color-orange_background">一些可能会用到的std函数、类、模版</h2><h3 id="e460899b-5560-495b-807e-3280bf476623" class="block-color-blue_background">std::conditional_t：在编译时根据条件在两种类型中进行选择</h3><ul id="472f77c9-671d-4df9-b52b-cd2ab72f02d6" class="bulleted-list"><li style="list-style-type:disc">一个类型特征，用于基于编译时的条件选择两种类型之一</li></ul><ul id="1c7d7ab4-b384-4725-8f64-7098b49012fa" class="bulleted-list"><li style="list-style-type:disc">这个类型特征非常有用，因为它允许开发者编写依赖于编译时条件的泛型代码，从而可以在不同情况下选择不同的类型。这种技术经常被用于模板元编程和编译时决策，增加了代码的灵活性和可重用性。</li></ul><ul id="8122c987-05c6-4e9b-b2fd-96bd51c414d0" class="bulleted-list"><li style="list-style-type:disc">例如：根据类型的大小选择使用指针或是值来存储这个类型<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="f5c7cad3-8fdb-424a-86b6-6e8df02155f0" class="code"><code class="language-C++">template&lt;typename T&gt;
using StorageType = std::conditional_t&lt;sizeof(T) &gt; sizeof(void*), T*, T&gt;;

int main() {
    StorageType&lt;int&gt; intValue = 42; // 使用int，因为int的大小小于指针的大小
    StorageType&lt;long long&gt; longPtr = new long long(42); // 使用long long*，因为long long的大小大于指针的大小
    
    std::cout &lt;&lt; &quot;intValue: &quot; &lt;&lt; intValue &lt;&lt; std::endl;
    std::cout &lt;&lt; &quot;longPtr: &quot; &lt;&lt; *longPtr &lt;&lt; std::endl;
    
    // 如果StorageType是指针类型，需要手动释放内存
    delete longPtr;
}</code></pre></li></ul><h3 id="628b5806-cef5-4102-af49-4bc0d610c65a" class="block-color-blue_background"><strong>static_cast：静态类型转换</strong></h3><ul id="3977e4a5-e2e9-4ec1-8f89-725d718c9ca2" class="bulleted-list"><li style="list-style-type:disc">用于在不同类型之间进行显式类型转换。它可以用于基本数据类型之间的转换（例如，将<code><strong>float</strong></code>转换为<code><strong>int</strong></code>），也可以用于对象指针和引用之间的转换，以及在类层次结构中进行向上（向基类）或向下（向派生类）的转换。</li></ul><ul id="b326f460-d63f-413f-a6d0-6a74e991c262" class="bulleted-list"><li style="list-style-type:disc">static_cast与强制类型转换的区别：<ul id="0c44780f-b626-4009-9a56-a10187a9f27c" class="bulleted-list"><li style="list-style-type:circle">强制类型转换（例如int(x)），会在转换时进行类型检查（动态转换），而static_cast是静态的类型转换，不会进行类型检查。<blockquote id="f1a9222b-ca01-4a01-985b-4dae61384334" class="block-color-gray_background">因此使用static_cast时需要确保转换的安全性，否则会造成未定义行为</blockquote></li></ul><ul id="14dd3481-196a-4d13-849d-8bad3947257a" class="bulleted-list"><li style="list-style-type:circle">由于static_cast不涉及类型检查，所以性能更好一些。</li></ul></li></ul><ul id="4940ea3d-eaa4-4c0b-9910-51b5fe72c6c9" class="bulleted-list"><li style="list-style-type:disc">case1：基本数据类型的转换<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="f7264773-2642-4cea-a9d4-5a87d82e222b" class="code"><code class="language-C++">// 基本类型之间的转换
double pi = 3.14159;
int integerPart = static_cast&lt;int&gt;(pi); // 将double转换为int，丢弃小数部分
std::cout &lt;&lt; &quot;Integer part of pi is: &quot; &lt;&lt; integerPart &lt;&lt; std::endl;
return 0;</code></pre></li></ul><ul id="9b34b16b-9e4c-44f1-bacb-eaf07d9a5ef2" class="bulleted-list"><li style="list-style-type:disc">case1：基类父类的转换<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="af107647-209a-4825-ba02-ce2489c958a0" class="code"><code class="language-C++">class Base {
public:
    virtual void print() const { std::cout &lt;&lt; &quot;Base class&quot; &lt;&lt; std::endl; }
};

class Derived : public Base {
public:
    void print() const override { std::cout &lt;&lt; &quot;Derived class&quot; &lt;&lt; std::endl; }
    void derivedOnlyFunction() const { std::cout &lt;&lt; &quot;Function only in Derived&quot; &lt;&lt; std::endl; }
};

int main() {
    Derived d;
    Base* bp = &amp;d; // 隐式向上转换：安全

    // 向下转换：将Base类型指针转换回Derived类型指针
    Derived* dp = static_cast&lt;Derived*&gt;(bp);
    dp-&gt;derivedOnlyFunction(); // 现在可以安全调用Derived中特有的函数了
}</code></pre></li></ul><h3 id="dab1c036-a5f9-4f16-95e7-37ec0dc7fa06" class="block-color-blue_background">const_cast：实现const类型转换</h3><ul id="c5af3ccd-3459-44ab-9004-964d751e7202" class="bulleted-list"><li style="list-style-type:disc"><code><strong>const_cast</strong></code>可以用来添加或移除对象的<code><em>const</em></code>属性。这允许你在一个常量成员函数中调用非常量成员函数，通过先移除对象的<em><code>const</code></em>限定，进行操作，然后再将其恢复。<blockquote id="84d8747e-4b94-4f6e-ad20-1362d1ff44fd" class="block-color-gray_background">⚠️：const是一个修饰符，因此不能用于强制类型转换，比如<strong>return const ...</strong>，这个用法就是错误的</blockquote></li></ul><ul id="0049131d-1e94-4a13-8bb3-98336521a6eb" class="bulleted-list"><li style="list-style-type:disc">⚠️：const_cast<mark class="highlight-purple"><strong>只能作用于一个指针，或一个左值引用</strong></mark>，<span style="border-bottom:0.05em solid"><strong>不能作用在一个对象上</strong></span><blockquote id="3b699fdb-6e47-43c2-9452-ab2061c2aab1" class="block-color-gray_background">因为const只有修饰指针和引用才有意义</blockquote></li></ul><ul id="25010c91-f5f2-4ce3-86eb-3cda350000d6" class="bulleted-list"><li style="list-style-type:disc"><mark class="highlight-purple"><strong>因此，</strong></mark><mark class="highlight-purple"><strong><code>const_cast</code></strong></mark><mark class="highlight-purple"><strong>常用于实现</strong></mark><mark class="highlight-purple"><strong><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">const接口</a></strong></mark>，它可以在实现const接口时，通过调用非const的版本，从而很轻松地<span style="border-bottom:0.05em solid"><strong>实现代码的复用</strong></span></li></ul><ul id="6c28baa4-b152-4a59-8d5b-affba285425a" class="bulleted-list"><li style="list-style-type:disc">case：使用<em><code>const_cast</code></em>转换const <strong><a href="CPP%2099ebd66f69ef430782fa4d74512a2c5b.html">this指针</a></strong>为非const，然后调用非const接口，然后再把非const接口的非const返回值通过<em><code>const_cast</code></em>转换为const返回值<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="bd589879-ca24-4bb0-85f2-d362b41a6777" class="code"><code class="language-C++">class MyClass {
public:
    int&amp; getNonConst() {
        // 实现非常量接口
        return data;
    }

    const int&amp; getConst() const {
        // 使用const_cast和static_cast调用非常量版本
        return const_cast&lt;const int&amp;&gt;(
            const_cast&lt;MyClass*&gt;(this)-&gt;getNonConst()
        );
    }
private:
    int data;
};</code></pre></li></ul><h3 id="973b3732-ca74-469e-8c7e-d15acb4c514b" class="block-color-blue_background">std::distance：计算两个iterator的距离</h3><ul id="0d5c0eaf-b9ea-459c-ba71-255ed5c21ee0" class="bulleted-list"><li style="list-style-type:disc">常用于实现iterator的operator -</li></ul><h3 id="2444638e-c77c-4b29-9526-fde88d3cc674" class="block-color-blue_background">std::move：把一个左值转换为右值</h3><p id="d98944d8-15a1-4a21-9903-d68ecbc7f5da" class=""> </p><h3 id="cedb7245-edbd-4acf-8995-6308cadfd492" class="block-color-blue_background">std::is_permutation：比较两个序列是否相等（顺序可以不同）</h3><ul id="fe17f221-07b7-414d-b479-df1b06595b44" class="bulleted-list"><li style="list-style-type:disc">常用于实现容器的operator==()</li></ul><h3 id="e4400047-128f-4752-b6b8-03de0f335fff" class="block-color-blue_background"><strong>std::ostringstream：适用于复杂的字符串处理和格式化的场景</strong></h3><ul id="9aafdbf2-356f-45d5-8ff9-365b86c546ae" class="bulleted-list"><li style="list-style-type:disc"><em><code><strong>std::ostringstream</strong></code></em>是C++标准库中的一个类，用于提供字符串流的输出操作。它继承自<em><code>std::ostream</code></em>，因此拥有所有输出流的功能，但是它将输出内容存储在一个<em><code>std::string</code></em>对象中。</li></ul><ul id="1a14bf4c-b45f-456a-a9bd-869d16193896" class="bulleted-list"><li style="list-style-type:disc">这使得<em><code>std::ostringstream</code></em><mark class="highlight-purple"><span style="border-bottom:0.05em solid"><strong>非常适用于需要字符串处理和格式化的场景</strong></span></mark>。通过使用<em><code>std::ostringstream</code></em>，你可以使用插入运算符(<code><strong>&lt;&lt;</strong></code>)来构建字符串，就像写入到文件或标准输出一样。</li></ul><ul id="660a16b4-a907-4149-b1b8-949fe0ded3e2" class="bulleted-list"><li style="list-style-type:disc">基本用法：<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="198795e8-befb-4c6b-b531-402d4af9d122" class="code"><code class="language-C++">#include &lt;sstream&gt;

int main() {
    // 创建一个std::ostringstream的实例
    std::ostringstream oss;

    // 使用插入运算符(&lt;&lt;)向流中添加内容
    oss &lt;&lt; &quot;Hello, &quot; &lt;&lt; &quot;World!&quot;; 

    // 使用str()成员函数来获取流中的内容作为std::string对象
    std::string result = oss.str();

    // 重用同一个std::ostringstream对象来构建新的字符串，可以先清空流内容。
    oss.str(&quot;&quot;);
    oss.clear(); /** 清除任何错误标志，例如
    * std::ios_base::goodbit：表示流状态良好，没有发生错误。
    * std::ios_base::eofbit：表示已到达输入序列的末尾。
    * std::ios_base::failbit：表示一个非致命的输入/输出操作失败。
    * std::ios_base::badbit：表示一个致命的输入/输出操作失败。
    */

}</code></pre></li></ul><ul id="9d5f49d5-032f-468c-8b23-2340038303e8" class="bulleted-list"><li style="list-style-type:disc">复杂用法：复杂的格式化场景<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js" integrity="sha512-7Z9J3l1+EYfeaPKcGXu3MS/7T+w19WtKQY/n+xzmw4hZhJ9tyYmcUS+4QqAlzhicE5LAfMQSF3iFTK9bQdTxXg==" crossorigin="anonymous" referrerPolicy="no-referrer"></script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" integrity="sha512-tN7Ec6zAFaVSG3TpNAKtk4DOHNpSwKHxxrsiw4GHKESGPs5njn/0sMCUMl2svV4wo4BK/rCP7juYz+zx+l6oeQ==" crossorigin="anonymous" referrerPolicy="no-referrer"/><pre id="2ea7a3e1-c417-4e39-8202-2dec718737e6" class="code"><code class="language-C++">#include &lt;iostream&gt;
#include &lt;sstream&gt;
#include &lt;iomanip&gt; // 对于std::setw和std::setprecision

int main() {
    std::ostringstream oss;
    oss &lt;&lt; &quot;Date: &quot; &lt;&lt; std::setw(2) &lt;&lt; std::setfill(&#x27;0&#x27;) &lt;&lt; 9 &lt;&lt; &quot;/&quot; &lt;&lt; std::setw(2) &lt;&lt; 10 &lt;&lt; &quot;/&quot; &lt;&lt; 2023;
    oss &lt;&lt; &quot;. Temperature: &quot; &lt;&lt; std::fixed &lt;&lt; std::setprecision(2) &lt;&lt; 23.456 &lt;&lt; &quot;C&quot;;
    std::string logEntry = oss.str();

    std::cout &lt;&lt; logEntry &lt;&lt; std::endl;
    return 0;
}</code></pre><ul id="dd1a0b37-f09e-4b0f-95a5-52b2b00eee03" class="bulleted-list"><li style="list-style-type:circle"><code><strong>std::setw(int n)</strong></code>：设置下一个输出字段的宽度。<em>n</em>是希望的宽度。如果输出的字段宽度小于<em>n</em>，则根据当前对齐设置（默认为右对齐）<ul id="90158c4c-9821-4088-a062-86b0ecdcbc09" class="bulleted-list"><li style="list-style-type:square">默认在左侧填充空格，也可以通过<code><strong>std::setfill</strong></code>设置的其他字符。</li></ul><ul id="b2eab086-176f-48fc-b39c-ef51678311d7" class="bulleted-list"><li style="list-style-type:square">如果输出的字段宽度大于或等于<em>n</em>，则不填充。</li></ul></li></ul><ul id="233155d3-76df-4a5a-a77b-86c343b289d7" class="bulleted-list"><li style="list-style-type:circle"><code><strong>std::setfill(char c)</strong></code>：设置用于填充的字符，通常与<em><code>setw</code></em>配套使用。<ul id="671cd45e-87b3-412d-80b4-758093b1a2ba" class="bulleted-list"><li style="list-style-type:square">当使用<em><code>std::setw</code></em>指定的宽度大于要输出的数据的实际宽度时，<em><code>std::setfill</code></em>指定的字符将被用来填充额外的空间。</li></ul><ul id="7c52fbe7-50c7-45a1-b129-5b84c9bc3eae" class="bulleted-list"><li style="list-style-type:square">默认填充字符是空格。</li></ul></li></ul><ul id="8f1163ff-96de-4029-b74d-f1813ab5b567" class="bulleted-list"><li style="list-style-type:circle"><code><strong>std::fixed</strong></code>：用于设置浮点数的输出格式为固定点表示法。<ul id="28fe67c3-35cf-44c9-a317-f896e8579010" class="bulleted-list"><li style="list-style-type:square">使用<code><strong>std::fixed</strong></code>后，<strong>浮点数将被格式化为普通的小数形式</strong>，而不是科学记数法形式。</li></ul></li></ul><ul id="d0f37403-98e6-44d2-b1bf-f4e887e0b252" class="bulleted-list"><li style="list-style-type:circle"><code><strong>std::setprecision(int n)</strong></code>：设置浮点数输出时的精度，即小数点后的数字位数，通常与<em><code>fixed</code></em>配套使用。对固定点表示法和科学记数法都有效。<ul id="c4707b72-ddd5-46b6-b3e7-c7aebc97561e" class="bulleted-list"><li style="list-style-type:square">如果与<code><em>std::fixed</em></code>一起使用，则<em><code>std::setprecision</code></em>指定小数点后的位数；</li></ul><ul id="73acc379-bd41-4241-81e7-d480377d3906" class="bulleted-list"><li style="list-style-type:square">如果没有使用<code><em>std::fixed</em></code>，则它指定输出的总有效数字位数。</li></ul><p id="8b251b4b-76a2-4515-b060-e5552c25fb1f" class="">
</p></li></ul></li></ul></div></article><span class="sans" style="font-size:14px;padding-top:2em"></span></body></html>